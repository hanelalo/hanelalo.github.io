---
title: 发送消息
date: 2020-10-06 23:13:14
tags: RocketMQ
categories: 消息中间件
cover: https://hanelalo.github.io/images/202111061310545.jpg
---

# 发送消息

## 消息

RocketMQ 的消息封装类是 Message.

```Java
public class Message implements Serializable {
    // 主题 Topic
    private String topic;
    // 消息 Flag
    private int flag;
    // 扩展属性
    private Map<String, String> properties;
    // 消息体
    private byte[] body;
    private String transactionId;
}
```

Message 的扩展属性都在 properties 中, 主要有:

- tag  消息 TAG
- keys  Message 索引键, 多个用逗号隔开, RocketMQ 用这些 key 快速搜索消息
- waitStoreMsgOK  消息发送时是否等待消息存储后再返回
- delayTimeLevel  延时消息的延时等级

## 消息生产者

消息生产者的代码在 client 模块, 相对于 broker 来说, 生产者也算是客户端. 消息生产者的有默认实现 `DefaultMQProducer` , 它实现了 MQAdmin 接口.

DefaultMQProducer 的主要属性有:

- producerGroup 消息生产者组
- createTopicKey 生产者默认 topic
- defaultTopicQueueNums 默认主题在每个 broker 队列个数
- sendMsgTimeout 默认消息发送超时时间
- compressMsgBodyOverHowmuch 消息压缩阈值
- retryTimesWhenSendFailed 同步消息发送失败时重试次数, 默认两次, 也就是最多会发送三次消息
- retryTimesWhenSendAsyncFailed 异步消息默认重试次数
- retryAnotherBrokerWhenNotStoreOK 消息重试选择另一个 broker 时, 是否不等待消息存储成功就返回, 默认为 false
- maxMessageSize 默认消息最大长度, 默认 4M

### 消息生产者启动

DefaultMQProduer 的启动主依靠 DefaultMQProducerImpl.start() 方法.

```Java
    this.serviceState = ServiceState.START_FAILED;
    // 检查配置
    this.checkConfig();
    // 
    if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) {
        // 将 producer 名称改为进程 ID
        this.defaultMQProducer.changeInstanceNameToPID();
    }
    // 创建客户端实例
    this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQProducer, rpcHook);
    boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);
    if (!registerOK) {
        this.serviceState = ServiceState.CREATE_JUST;
        throw new MQClientException(
            "The producer group["
            + this.defaultMQProducer.getProducerGroup()
            + "] has been created before, specify another name please."
            + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL), null);
    }
    this.topicPublishInfoTable.put(
    this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo());
    if (startFactory) {
        mQClientFactory.start();
    }
    this.serviceState = ServiceState.RUNNING;
```

## 消息发送

DefaultMQProducer 支持同步和异步发送一条或者多条消息. 

```Java
    public SendResult send(
        Message msg) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
        // 检查消息
        Validators.checkMessage(msg, this);
        // 设置 topic
        msg.setTopic(withNamespace(msg.getTopic()));
        // 发送消息
        return this.defaultMQProducerImpl.send(msg);
    }
```

send 方法看起来比较简单.

- 检查消息

```Java
    public static void checkMessage(Message msg, DefaultMQProducer defaultMQProducer)
        throws MQClientException {
        if (null == msg) {
            throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, "the message is null");
        }
        // 检查 topic 名称是否合规.
        Validators.checkTopic(msg.getTopic());
        // 是否是不允许发送消息的 topic
        Validators.isNotAllowedSendTopic(msg.getTopic());

        // body
        if (null == msg.getBody()) {
            throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, "the message body is null");
        }

        if (0 == msg.getBody().length) {
            throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, "the message body length is zero");
        }
        
        // 消息体是否过长, 默认 4M
        if (msg.getBody().length > defaultMQProducer.getMaxMessageSize()) {
            throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL,
                "the message body size over max value, MAX: " + defaultMQProducer.getMaxMessageSize());
        }
    }
```

- 设置 topic 
- 发送消息

发送消息会调用到 DefaultMQProducerImpl.sendDefaultImpl() 方法, 在真正发送消息前会先查找主题路由信息, 如此才知道最后要发送到那个 broker.

```Java
  private TopicPublishInfo tryToFindTopicPublishInfo(final String topic) {
    // 1. 尝试从本地缓存获取 TopicPublishInfo
    TopicPublishInfo topicPublishInfo = this.topicPublishInfoTable.get(topic);
    // 如果本地缓存没有, 尝试通过 Name Server 查询
    if (null == topicPublishInfo || !topicPublishInfo.ok()) {
      this.topicPublishInfoTable.putIfAbsent(topic, new TopicPublishInfo());
      // 3. 根据 topic 查询路由信息
      this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);
      topicPublishInfo = this.topicPublishInfoTable.get(topic);
    }
    
    if (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) {
      return topicPublishInfo;
    } else {
      // 3. 如果前面第二步没查询到路由信息, 那就根据默认的 topicKey 查询路由信息
      this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, true, this.defaultMQProducer);
      topicPublishInfo = this.topicPublishInfoTable.get(topic);
      return topicPublishInfo;
    }
  }
```

首先查询本地缓存的路由信息, 如果本地找到了路由信息, 并且包含消息队列信息, 那就返回缓存中的. 不然就向 Name Server 查询更新路由缓存.

先看看 TopicPublishInfo 和 TopicRouteData 的结构.

```Java
public class TopicPublishInfo {
    /** 是否是顺序消息 */
    private boolean orderTopic = false;
    private boolean haveTopicRouterInfo = false;
    /** 该主题队列的消息队列 */
    private List<MessageQueue> messageQueueList = new ArrayList<MessageQueue>();
    /** 每选择一次消息队列, 该值自增 1, 达到 Integer.MAX_VALUE 后重置为 0 */
    private volatile ThreadLocalIndex sendWhichQueue = new ThreadLocalIndex();
    /** topic 路由信息 */
    private TopicRouteData topicRouteData;
}
public class TopicRouteData extends RemotingSerializable {
    private String orderTopicConf;
    // topic 队列数据
    private List<QueueData> queueDatas;
    // topic 分布 broker 数据
    private List<BrokerData> brokerDatas;
    // topic 所在的 broker 上过滤服务器元数据
    private HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable;
}
```

### 更新路由信息

如果本地缓存中没找到路由信息, 就从 Name Server 获取, 先用消息指定的 topic 去查询, 如果没有查询到路由信息, 在使用默认的 topic key 去查询.

```Java
TopicRouteData topicRouteData;
if (isDefault && defaultMQProducer != null) {
    // 使用默认 topic 查询
    topicRouteData = this.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(
        defaultMQProducer.getCreateTopicKey(), 1000 * 3);
    if (topicRouteData != null) {
        for (QueueData data : topicRouteData.getQueueDatas()) {
            int queueNums = Math.min(defaultMQProducer.getDefaultTopicQueueNums(), data.getReadQueueNums());
            data.setReadQueueNums(queueNums);
            data.setWriteQueueNums(queueNums);
        }
    }
} else {
    // 使用 topic 查询
    topicRouteData = this.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, 1000 * 3);
}
```

如果查询到了路由信息, 吧查询到的路由和缓存中的路由对比, 看是否需要更新.

```Java
TopicRouteData old = this.topicRouteTable.get(topic);
boolean changed = topicRouteDataIsChange(old, topicRouteData);
if (!changed) {
    changed = this.isNeedUpdateTopicRouteInfo(topic);
} else {
    log.info(
    "the topic[{}] route info changed, old[{}] ,new[{}]", topic, old, topicRouteData);
}
```

更新路由信息

```Java
TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);
publishInfo.setHaveTopicRouterInfo(true);
Iterator<Entry<String, MQProducerInner>> it = this.producerTable.entrySet().iterator();
while (it.hasNext()) {
    Entry<String, MQProducerInner> entry = it.next();
    MQProducerInner impl = entry.getValue();
    if (impl != null) {
        impl.updateTopicPublishInfo(topic, publishInfo);
    }
}
```

### 选择一个消息队列

选择消息队列的时候, 涉及到一个故障延迟的配置(MQFaultStrategy.sendLatencyFaultEnable), 这个开关默认是关闭的, 

在默认情况下, 消息队列的选择直接交由 TopicPublishInfo 来执行.

```Java
    public MessageQueue selectOneMessageQueue(final String lastBrokerName) {
        // 如果是第一次发送消息, lastBrokerName 为空
        if (lastBrokerName == null) {
            return selectOneMessageQueue();
        } else {
            int index = this.sendWhichQueue.getAndIncrement();
            for (int i = 0; i < this.messageQueueList.size(); i++) {
                int pos = Math.abs(index++) % this.messageQueueList.size();
                if (pos < 0) {
                    pos = 0;
                }
                MessageQueue mq = this.messageQueueList.get(pos);
                if (!mq.getBrokerName().equals(lastBrokerName)) {
                    return mq;
                }
            }
            return selectOneMessageQueue();
        }
    }

    public MessageQueue selectOneMessageQueue() {
        int index = this.sendWhichQueue.getAndIncrement();
        int pos = Math.abs(index) % this.messageQueueList.size();
        if (pos < 0) {
            pos = 0;
        }
        return this.messageQueueList.get(pos);
    }
```

lastBrokerName 是上次发送消息失败的 brokerName, 如果是第一次发送消息, 那么 lastBrokerName 应该是 null.此时直接调用 `selectOneMessageQueue` 方法, 根据发送消息次数, 获取本次发送消息的队列, 该算法的实现, 使得想领两次消息发送的队列尽量都不在同一个 broker, 可以一定程度上规避掉第一次发送失败后, 重试的时候依然发送到上次失败的队列所在 broker.

因为 TopicPublishInfo 中的 `messageQueueList` 是按照 brokerName 来排序, 可能就会出现下面的情况. 当 BrokerA 宕机, 发送消息 A, 第一次选择了 BrokerA 的第一队列, 发送失败, 然后重试. 后来又发送消息 B, 此时 BrokerA 依然宕机, 又得重试. 

### 故障延迟机制

其实在发送消息 A 的时候, 我们就已经知道 BrokerA 可能已经宕机了, 此时为了节省资源, 避免不必要的重试消息, 完全可以在发送消息选择队列时, 将 BrokerA 排除. 这里就涉及到前面提到的故障延迟开关MQFaultStrategy.sendLatencyFaultEnable, 默认是关闭的, 如果开启的话, 在选择队列时, 就会规避掉不可用的 broker.

```Java
if (this.sendLatencyFaultEnable) {
        try {
            int index = tpInfo.getSendWhichQueue().getAndIncrement();
            for (int i = 0; i < tpInfo.getMessageQueueList().size(); i++) {
                // 选择消息队列
                int pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();
                if (pos < 0) {
                    pos = 0;
                }
                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);
                // 判断选择的队列坐在的 broker 是否可用
                if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) {
                    if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName)) {
                        return mq;
                    }
                }
            }
            final String notBestBroker = latencyFaultTolerance.pickOneAtLeast();
            int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);
            if (writeQueueNums > 0) {
                final MessageQueue mq = tpInfo.selectOneMessageQueue();
                if (notBestBroker != null) {
                    mq.setBrokerName(notBestBroker);
                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);
                }
                return mq;
            } else {
                latencyFaultTolerance.remove(notBestBroker);
            }
        } catch (Exception e) {
        log.error("Error occurred when selecting message queue", e);
    }
    return tpInfo.selectOneMessageQueue();
}
```

先对路由信息中的消息队列轮询选择一个消息队列, 然后判断其所在的 broker 是否可用, 然后从 latencyFaultTolerance 删除该 topic 相关信息, 表明其所在 broker 已经恢复.

下面看看故障延迟接口规范.

```Java
/**
 * 故障延迟接口
 * @param <T>
 */
public interface LatencyFaultTolerance<T> {
    // 更新故障延迟条目
    void updateFaultItem(final T name, final long currentLatency, final long notAvailableDuration);
    // 判断 broker 是否可用
    boolean isAvailable(final T name);
    // 删除故障条目
    void remove(final T name);
    // 尝试从规避的 broker 中选择一个可用的 broker, 如果没有, 就返回 null
    T pickOneAtLeast();
}
```

故障条目:

```Java
    class FaultItem implements Comparable<FaultItem> {
        // 故障条目唯一性标识, 这里是 brokerName
        private final String name;
        // 本次消息发送延迟
        private volatile long currentLatency;
        // 故障规避开始时间
        private volatile long startTimestamp;
    }
```

故障延迟策略.

```Java
public class MQFaultStrategy {
    private final static InternalLogger log = ClientLogger.getLog();
    private final LatencyFaultTolerance<String> latencyFaultTolerance = new LatencyFaultToleranceImpl();
    /** Broker 故障延迟机制是否启用, 默认不启用 */
    private boolean sendLatencyFaultEnable = false;
    private long[] latencyMax = {50L, 100L, 550L, 1000L, 2000L, 3000L, 15000L};
    private long[] notAvailableDuration = {0L, 0L, 30000L, 60000L, 120000L, 180000L, 600000L};
}
```

在更新故障条目时,根据本次消息发送延迟从 latencyMax 从后往前找一个比 currentLatency 小的值得索引, 如果没有, 就返回 0, 然后根据这个 index 去 notAvailableDuration 中找到一个故障延迟时长, 在这个时长内, broker 将被设置为不可用.

```Java
    public void updateFaultItem(final String brokerName, final long currentLatency, boolean isolation) {
        if (this.sendLatencyFaultEnable) {
            long duration = computeNotAvailableDuration(isolation ? 30000 : currentLatency);
            this.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);
        }
    }

    private long computeNotAvailableDuration(final long currentLatency) {
        for (int i = latencyMax.length - 1; i >= 0; i--) {
            if (currentLatency >= latencyMax[i])
                return this.notAvailableDuration[i];
        }
        return 0;
    }
```

### 发送

消息发送核心接口方法是 `DefaultMQProducerImpl.sendKernelImpl()` :

```Java
private SendResult sendKernelImpl(
      final Message msg,
      final MessageQueue mq,
      final CommunicationMode communicationMode,
      final SendCallback sendCallback,
      final TopicPublishInfo topicPublishInfo,
      final long timeout)
```

- msg: 要发送的消息
- mq: 目标消息队列
- communicationMode: 消息发送模式. 同步(SYNC), 异步(ASYNC), ONEWAY
- sendCallback: 异步消息回调方法
- topicPublishInfo: 主题路由信息
- timeout: 消息发送超时时间

```Java
    // 获取队列所在 broker 地址
    String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());
    // 如果没有找到, 就主动从 Name Server 更新路由信息再查找
    if (null == brokerAddr) {
      tryToFindTopicPublishInfo(mq.getTopic());
      brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());
    }
```

第一步首先获取 broker 的地址, 如果在缓存中没有找到, 从主动从 Name Server 更新路由信息再查找, 要是还是找不到, 那就抛出 `MQClientException` 异常.

```Java
int sysFlag = 0;
boolean msgBodyCompressed = false;
if (this.tryToCompressMessage(msg)) {
    sysFlag |= MessageSysFlag.COMPRESSED_FLAG;
    msgBodyCompressed = true;
}
final String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);
if (tranMsg != null && Boolean.parseBoolean(tranMsg)) {
    sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;
}
```

第二步, 如果消息大小超过压缩阈值(默认 4k), 就对消息进行压缩, 将sysFlag 设置为 COMPRESSED_FLAG. 如果消息为事务 prepared 消息, 就将 sysFlag 设置为 TRANSACTION_PREPARED_TYPE.

```Java
        if (this.hasSendMessageHook()) {
          context = new SendMessageContext();
          context.setProducer(this);
          context.setProducerGroup(this.defaultMQProducer.getProducerGroup());
          context.setCommunicationMode(communicationMode);
          context.setBornHost(this.defaultMQProducer.getClientIP());
          context.setBrokerAddr(brokerAddr);
          context.setMessage(msg);
          context.setMq(mq);
          context.setNamespace(this.defaultMQProducer.getNamespace());
          String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);
          if (isTrans != null && isTrans.equals("true")) {
            context.setMsgType(MessageType.Trans_Msg_Half);
          }

          if (msg.getProperty("__STARTDELIVERTIME") != null
              || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != null) {
            context.setMsgType(MessageType.Delay_Msg);
          }
          this.executeSendMessageHookBefore(context);
        }
```

第三步, 是否有注册发送消息的钩子函数, 如果有, 那就在发送消息前执行钩子函数, 增强消息.

```Java
        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();
        // 消费者组
        requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());
        // topic
        requestHeader.setTopic(msg.getTopic());
        // 消费者默认 topicKey
        requestHeader.setDefaultTopic(this.defaultMQProducer.getCreateTopicKey());
        // 目标 topic 在每个 broker 默认队列个数
        requestHeader.setDefaultTopicQueueNums(this.defaultMQProducer.getDefaultTopicQueueNums());
        // 队列 id
        requestHeader.setQueueId(mq.getQueueId());
        // 消息系统标记
        requestHeader.setSysFlag(sysFlag);
        // 消息发送时间
        requestHeader.setBornTimestamp(System.currentTimeMillis());
        // 消息 flag
        requestHeader.setFlag(msg.getFlag());
        // 消息的各种 properties, 其中包括了延时等级等
        requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));
        requestHeader.setReconsumeTimes(0);
        requestHeader.setUnitMode(this.isUnitMode());
        // 是否为批量消息
        requestHeader.setBatch(msg instanceof MessageBatch);
        if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
          String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);
          if (reconsumeTimes != null) {
            requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));
            MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);
          }

          String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);
          if (maxReconsumeTimes != null) {
            requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));
            MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);
          }
        }
```

第四步, 构建请求包.

```Java
    public SendResult sendMessage(
        final String addr,
        final String brokerName,
        final Message msg,
        final SendMessageRequestHeader requestHeader,
        final long timeoutMillis,
        final CommunicationMode communicationMode,
        final SendCallback sendCallback,
        final TopicPublishInfo topicPublishInfo,
        final MQClientInstance instance,
        final int retryTimesWhenSendFailed,
        final SendMessageContext context,
        final DefaultMQProducerImpl producer
    )
```

第五步, 发送消息最终调用, 根据消息发送方式, 选择同步, 异步, oneway.

```Java
        if (this.hasSendMessageHook()) {
          context.setSendResult(sendResult);
          this.executeSendMessageHookAfter(context);
        }
```

第六步, 如果注册了消息发送, 那么不管发送过程是否报错, 都会执行 after 逻辑.

#### 同步发送

```Java
    case SYNC:
        long costTimeSync = System.currentTimeMillis() - beginStartTime;
        if (timeout < costTimeSync) {
            throw new RemotingTooMuchRequestException("sendKernelImpl call timeout");
        }
        sendResult = this.mQClientFactory.getMQClientAPIImpl()
            .sendMessage(
                brokerAddr,
                mq.getBrokerName(),
                msg,
                requestHeader,
                timeout - costTimeSync,
                communicationMode,
                context,this);
    break;
```

同步发送消息, 设置请求命令为 RequestCode.SEND_MESSAGE. 发送同步消息的方法在 `MQClientAPIImpl.sendMessageSync()` . 

#### 异步发送

异步发送和同步发送的区别在于， 同步发送需要阻塞线程， 直到接收到 broker 的返回信息， 而异步发送消息，消息发送了就返回，发送时注册了回调函数， 接收到 broker 返回数据后，调用回调函数， 线程并不会阻塞。

#### 单向发送（oneWay）

只关心发送消息， 而不关心结果， 直接返回， 连回调函数都不用注册。