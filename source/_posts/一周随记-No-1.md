---
title: 一周随记 No.1
date: 2021-03-06 17:02:48
tags: 非正式笔记
cover: http://image.hanelalo.cn/images/202111061346683.png
---

# 封装、抽象、继承、多态

* 封装

  通过访问控制，对外隐藏信息，保护对象内部数据不被任意修改，而只暴露必要的接口或信息。

* 抽象
  关注提供了什么方法，什么功能，而不关注具体的实现，比如抽象方法和接口。

* 继承
  继承表现的是一种“is a”的关系，比如，猫是一种动物。继承方便了代码复用，但是过深的继承关系，也会导致代码可读性变差，而且，继承关系使得子类有父类所有信息的，与封装的理念略有相悖。

* 多态
  多态提高代码的复用性和扩展性。在实际编码时，操作的是对象的接口或者父类，可以让代码不只是局限于某种特定的实现，而根据运行时环境，实际调用的方法其实是子类的，所以当新增一种派生类或者新增一个接口的实现时，已有的代码并不需要改动。

> 据说这些东西，面试真的会问。。。

# 微服务架构

> 阅读《微服务架构设计模式》随便记的。

1. 扩展立方体和服务。

   扩展立方体，X 轴是相同应用不同实例之间，通过负载均衡分发请求，Z 轴是根据请求的某些特征在相同应用不同实例之间分发请求，这其实是一种流量分区策略，或者提现的是一种分库分表策略，Y 轴则是根据功能将单体应用拆分为多个服务。X、Z是为了实现单个应用的高可用和吞吐量，Y轴才真正解决了单体应用的复杂度和开发问题。每一个服务都是由一组专注的、内聚的职业组成。


2. 微服务架构是模块化的一种形式。
微服务架构将单体应用拆分为多个微服务应用，因此每个微服务应用可以单独部署。而应用之间功能的协同上，在单体应用中更多是直接访问功能内部的实现代码，而微服务应用因为是需要通过服务的 API 通信的，这也就在服务之间构成了一道不可逾越的墙，因为服务间并不能越过 API 进行交互。


3. 每个微服务都应该有自己的数据库。

   每个服务都应该有自己的数据管理，比如用户有用户数据库 userDB，订单有订单数据库 orderDB，如果用户服务想要订单数据，不能直接查询 orderDB，而只能通过订单服务的 API 获取。这样从数据库上拆分，避免了因数据库被占用导致服务阻塞，也不会出现一个数据库应用挂了导致所有服务不可用的情况。

# Spring Bean 初始化

> 这个很重要，真的的理解。

1. 初始化 Bean 容器，此时会解析出 BeanDefinition，可能是从配置类解析，也可能是从 Xml 等文件解析，同时 bean 的名称和别名也被解析出来，这个阶段就可能会出现 bean 的命名冲突。
2. 执行 PostBeanFactoryProcessor。
3. 注册 PostBeanProcessor，用来做 Bean 初始化前后的一些操作，这里只是注册，而不是执行。
4. 实例化 bean，实例化 bean 的过程中，涉及到 BeanFactory 的三级缓存，都是使用的 Map 结构，key 都是 beanName，一级缓存的 value 是最终的 bean 实体，二级缓存虽然也是 bean 实体，但是并不完整，比如可能对象只是创建了，但依赖的一些 bean 还没有注入，所以认为它还不是完整的，并没有真的实例化完成，三级缓存的 key 是创建 bean 的 BeanFactory，一个函数式的工厂，用@FunctionalInterface 修饰，在必要时会调用这个工厂声音 bean 的实例。
5. 发布加载完成的事件。Spring 循环依赖主要依靠第 4 点中的分级缓存解决，允许在实例化时引用还未实例化完成的实例对象，有一个问题是，三级缓存只能解决以 setXxx 注入的循环依赖问题，而不能解决以构造函数注入的循环依赖问题，因为以构造函数注入也就代表着这个 bean 一旦有实例，那就必须是完整的实例，而不能接受某个依赖的 bean 是 null。
