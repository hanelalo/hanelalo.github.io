---
title: 刷盘机制
date: 2020-10-06 23:22:27
tags: RocketMQ
categories: 消息中间件
cover: https://hanelalo.github.io/images/202111061341145.png
---

# 刷盘机制

RocketMQ 接收到消息后, 分了两种方式将数据写到磁盘, 一种是同步刷盘, 一种是异步刷盘, 在前一篇文章已经讲过这两种方式的细节实现, 这里以 CommitLog 的刷盘为例进行学习.

CommitLog 刷盘处理方法是 CommitLoh.handleDiskFlush() 方法, 查看调用方发现, 是在 broker 接收到消息, 将消息先写入到 MappedFile 的 mappedByteBuffer 或者 TransientStorePool 中, 然后才调用了刷盘的方法.

Broker 的刷盘方式可以通过 broker  配置文件的 `flushDiskType` 进行配置, 同步刷盘 SYNC_FLUSH, 异步刷盘 ASYNC_FLUSH.

# 同步刷盘

```Java
    final GroupCommitService service = (GroupCommitService) this.flushCommitLogService;
    if (messageExt.isWaitStoreMsgOK()) {
        GroupCommitRequest request = new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());
        service.putRequest(request);
        CompletableFuture<PutMessageStatus> flushOkFuture = request.future();
        PutMessageStatus flushStatus = null;
        try {
            // 同步刷盘默认超时时间为 5 秒
            flushStatus = flushOkFuture.get(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout(),
                TimeUnit.MILLISECONDS);
        } catch (InterruptedException | ExecutionException | TimeoutException e) {
        //flushOK=false;
        }
        if (flushStatus != PutMessageStatus.PUT_OK) {
            log.error("do groupcommit, wait for flush failed, topic: " + messageExt.getTopic() + " tags: " + messageExt.getTags()
                + " client address: " + messageExt.getBornHostString());
            putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);
        }
    } else {
        service.wakeup();
    }
```

1. 首先获取了 commit log 刷盘的 service
2. 构建刷盘的请求 GroupCommitRequest, 它主要有以下属性:

```Java
// 刷盘点偏移量
private final long nextOffset;
// 刷盘结果
private CompletableFuture<PutMessageStatus> flushOKFuture = new CompletableFuture<>();
```

- nextOffset, 本次刷盘后刷盘指针位置.
- flushOKFuture, 刷盘是否成功, 最后返回 PutMessageStatus.PUT_OK 才算是刷盘成功.

1. 提交刷盘请求, 然后以阻塞方式获取刷盘结果, 默认超时时间为 5 秒. 

在第三步通过 GroupCommitService.putRequest() 提交刷盘请求时, 还会调用 GroupCommitService.wakeup() 方法唤醒线程进行刷盘操作.

```Java
        protected volatile AtomicBoolean hasNotified = new AtomicBoolean(false);

        public synchronized void putRequest(final GroupCommitRequest request) {
            synchronized (this.requestsWrite) {
                this.requestsWrite.add(request);
            }
            this.wakeup();
        }

        public void wakeup() {
            if (hasNotified.compareAndSet(false, true)) {
                waitPoint.countDown(); // notify
            }
        }
```

GroupCommitService 其实是一个线程对象, 这里将 hasNotified 设置为 true 之后, 其阻塞的线程就会开始执行刷盘任务, 首先会判断当前线程是否是停止状态, 如果不是, 那就是一直 while 循环, waitForRunning() 会使线程在有任务执行时立即执行刷盘, 没有刷盘请求时, 没 10ms 空转一次.

如果 service 时停止状态, 那么这里就不会再循环, 而是直接将剩下未刷盘的数据进行刷盘.

```Java
        public void run() {
            CommitLog.log.info(this.getServiceName() + " service started");

            while (!this.isStopped()) {
                try {
                    this.waitForRunning(10);
                    this.doCommit();
                } catch (Exception e) {
                    CommitLog.log.warn(this.getServiceName() + " service has exception. ", e);
                }
            }

            // Under normal circumstances shutdown, wait for the arrival of the
            // request, and then flush
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                CommitLog.log.warn("GroupCommitService Exception, ", e);
            }

            synchronized (this) {
                this.swapRequests();
            }

            this.doCommit();

            CommitLog.log.info(this.getServiceName() + " service end");
        }
```

然后看看 doCommit(), 这里发现处理的是 requestsRead 里的刷盘请求, 但是明明当初调用 putRequest 时是添加到了 requestsWrite 中, 这是因为在调用 doCommit 前调用的 waitForRunning 方法中将 requestsWrite 和 requestsRead 的数据进行了交换.

```Java
        private void doCommit() {
            synchronized (this.requestsRead) {
                if (!this.requestsRead.isEmpty()) {
                    for (GroupCommitRequest req : this.requestsRead) {
                        // There may be a message in the next file, so a maximum of
                        // two times the flush
                        boolean flushOK = false;
                        for (int i = 0; i < 2 && !flushOK; i++) {
                            flushOK = CommitLog.this.mappedFileQueue.getFlushedWhere() >= req.getNextOffset();
                            if (!flushOK) {
                                CommitLog.this.mappedFileQueue.flush(0);
                            }
                        }
                        req.wakeupCustomer(flushOK ? PutMessageStatus.PUT_OK : PutMessageStatus.FLUSH_DISK_TIMEOUT);
                    }
                    long storeTimestamp = CommitLog.this.mappedFileQueue.getStoreTimestamp();
                    if (storeTimestamp > 0) {
                        CommitLog.this.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);
                    }
                    this.requestsRead.clear();
                } else {
                    // Because of individual messages is set to not sync flush, it
                    // will come to this process
                    CommitLog.this.mappedFileQueue.flush(0);
                }
            }
        }
```

这里首先判断了 requestsRead 是否为空, 如果不为空才执行刷盘, 然后循环处理 requestsRead 中的请求, 如果当前刷盘点大于请求的刷盘点, 那说明数据已经刷写到了磁盘, 否则调用 mappedFleQueue.flush() 进行刷盘, 结合上一篇文章的内容可以知道最终调用了 mappedByteBuffer.force() 方法写数据到了磁盘.

最后更新刷盘监测点, 但是并没有对消息监测点文件进行刷盘.

刷盘完成后, 清空了 requestRead, 表示这次刷盘任务算是完成了, 如果 doCommit 执行时, requestRead 是空的, 那就直接执行一次刷盘.

这里在提交刷盘请求和处理刷盘请求是分成了 requestWrite 和 requestRead 两个容器, 避免了提交请求和处理请求竞争同一把锁的情况.

# 异步刷盘

```Java
            if (!this.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) {
                flushCommitLogService.wakeup();
            } else  {
                commitLogService.wakeup();
            }
            return CompletableFuture.completedFuture(PutMessageStatus.PUT_OK);
```

异步刷盘根据消息存储的 transientStorePoolEnable 配置项决定是通过 FileChannel 刷盘还是通过 MappedByteBuffer 进行刷盘, 这两者的区别在前一篇文章中也已经讲过. 

首先看看当 transientStorePoolEnable 为 false 的情况, 查看 CommitLog 的初始化方法发现, 当 broker 配置为异步刷盘时, flushCommitLogService 初始化成了 FlushRealTimeService, commitLogService 则始终是 CommitRealTimeService:

```Java
        if (FlushDiskType.SYNC_FLUSH == defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) {
            this.flushCommitLogService = new GroupCommitService();
        } else {
            this.flushCommitLogService = new FlushRealTimeService();
        }

        this.commitLogService = new CommitRealTimeService();
```

FlushRealTimeService, CommitRealTimeService, GroupCommitService 三个 service 都是 FlushCommitLogService 的子类, 按照前面同步刷盘使用 GroupCommitService 的机制来看, 另外两个子类应该也是本身就是一个单独的线程, 所以直接查看 FlushRealTimeService 的 run() 方法:

```Java
        public void run() {
            CommitLog.log.info(this.getServiceName() + " service started");

            while (!this.isStopped()) {
                // 线程等待方式, true 时使用 sleep 方法等待, false 时使用 await 方式等待.
                boolean flushCommitLogTimed = CommitLog.this.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();
                // 线程运行间隔时间
                int interval = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();
                // 刷盘最小页数, 默认 4 页
                int flushPhysicQueueLeastPages = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();
                // 两次真实刷盘最大时间间隔, 默认 10s
                int flushPhysicQueueThoroughInterval =
                    CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();

                boolean printFlushProgress = false;

                // Print flush progress
                long currentTimeMillis = System.currentTimeMillis();
                // 如果最后一次刷盘时间距当前时间已经有 10s, 就将最后一次刷盘时间更新为当前时间, 将刷盘最小页数设置为 0,
                // 也就是不管有几页数据, 只要有数据就刷盘
                if (currentTimeMillis >= (this.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) {
                    this.lastFlushTimestamp = currentTimeMillis;
                    flushPhysicQueueLeastPages = 0;
                    printFlushProgress = (printTimes++ % 10) == 0;
                }
                // 线程休眠或阻塞 500s
                try {
                    if (flushCommitLogTimed) {
                        Thread.sleep(interval);
                    } else {
                        this.waitForRunning(interval);
                    }

                    if (printFlushProgress) {
                        this.printFlushProgress();
                    }
                    // 刷盘
                    long begin = System.currentTimeMillis();
                    CommitLog.this.mappedFileQueue.flush(flushPhysicQueueLeastPages);
                    long storeTimestamp = CommitLog.this.mappedFileQueue.getStoreTimestamp();
                    // 更新刷盘检查点
                    if (storeTimestamp > 0) {
                        CommitLog.this.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);
                    }
                    long past = System.currentTimeMillis() - begin;
                    if (past > 500) {
                        log.info("Flush data to disk costs {} ms", past);
                    }
                } catch (Throwable e) {
                    CommitLog.log.warn(this.getServiceName() + " service has exception. ", e);
                    this.printFlushProgress();
                }
            }

            // Normal shutdown, to ensure that all the flush before exit
            // 正常退出时, 为了确保数据在关闭前能刷写到磁盘, 这里直接尝试了 10 次无限制的刷盘
            boolean result = false;
            for (int i = 0; i < RETRY_TIMES_OVER && !result; i++) {
                result = CommitLog.this.mappedFileQueue.flush(0);
                CommitLog.log.info(this.getServiceName() + " service shutdown, retry " + (i + 1) + " times " + (result ? "OK" : "Not OK"));
            }

            this.printFlushProgress();

            CommitLog.log.info(this.getServiceName() + " service end");
        }
```

主要的流程已经在代码里面注明. 首先会判断当前是否已经超过了刷盘最大时间间隔, 默认 10s, 如果超过了那就将最小刷盘页数设置为 0, 也就是直接将未刷盘的数据写入磁盘, 然后让线程休眠 500ms, 然后调用 mappedFileQueue 的刷盘方法进行刷盘, 然后更新刷盘检查点, 和同步刷盘一样, 这里也只是更新刷盘检查点在内存中的数据, 并不会对刷盘检查点的数据进行刷盘.

最后, 如果刷盘线程正常退出, 会循环执行 10 次无限制的刷盘, 也就是刷盘最小页数为 0 的刷盘操作, 以保证在正常关闭之前能将数据写入磁盘, 不然就丢数据了.

源码看到这里, 我之前一直以为同步和异步的区别在于是否有 TransientStorePoolEnable 的 commit 这个过程, 现在看来我理解错了, 其实是最终调用刷盘方法的方式不同, 同步刷盘是有消息来了我直接调用 commitlog 的刷盘方法, 阻塞等待你的返回结果, 失败就返回失败, 成功就返回成功, 而异步刷盘就只是通知异步刷盘线程现在由数据可以进行刷盘, 然后直接返回 PUT_OK 表示刷盘成功, 但最终结果其实并不知道.

上面讲的是在 transientStorePoolEnable 为 false 时的异步刷盘, 调用的是 FlushRealTimeService, 最终也是通过 mappedByteBuffer.force() 方法进行了刷盘, 在 transientStorePoolEnable 为 true 时, 调用的是 CommitRealTimeService, 我们来看看这个 CommitRealTimeService 又有什么不同.

额, 看了一下 CommitRealTimeService.run() 方法, 和 FlushRealTimeService 主要的区别在于, 它调用的并不是 mappedFileQueue 的 flush 方法, 而是 commit, 因为按照上一篇文章的理解, 当开启了 TransientStorePool 时, 数据是需要先写入 TransientStorePool 的 writeBuffer, 然后再提交到 MappedFile 的 FileChannel, 然后再由 flushCommitLogService 进行刷盘.

```Java
    // 提交数据到 FileChannel, 如果有新数据提交成功, 这里会返回 false
    boolean result = CommitLog.this.mappedFileQueue.commit(commitDataLeastPages);
    //  
    long end = System.currentTimeMillis();
    if (!result) {
        this.lastCommitTimestamp = end; // result = false means some data committed.
        //now wake up flush thread.
        flushCommitLogService.wakeup();
    }
```