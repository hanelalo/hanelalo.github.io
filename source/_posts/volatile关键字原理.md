---
title: volatile 关键字原理
date: 2021-03-21 16:03:45
tags: Java
categories: 多线程技术
cover: http://image.hanelalo.cn/images/202111061357907.png
---

> 来自《Java 并发编程的艺术》

# volatile 关键字原理

volatile 关键字是 Java 提供的轻量级的 synchronized 的实现，在多处理器程序中保证共享变量的可见性，也就是当一个线程修改了变量值时，另一个线程读取到的必定是修改后的值。

## CPU 内存术语

* 内存屏障

  一组处理器指令，用于限制内存操作的顺序

* 缓存行

  CPU 高速缓存可已分配的最小存储单元，总所周知，内存比硬盘快，而 CPU 的缓存比内存更快，相应的，越快的地方，成本更好，所以容量更小。处理器填充缓存行的时候会加载整个缓存行。

* 原子操作

  不可中断的一个或者一系列操作。

* 缓存行填充

  当处理器意识到从内存读取的数据是可缓存的，就会读取整个高速缓存行到适当的缓存。

* 缓存命中

  如果进行填充高速缓存行的地址仍然是下次操作的地址，那么处理器从缓存行中读取操作数，而不直接与内存交互。

* 写命中

  如果处理器识别到写数据的地址依然是在有效缓存行中，就会将数据写到缓存行中，而不是写回到内存。

* 写缺失

  有效的缓存行被写入到不存在的内存区域。

> 其实上面这一段我也不是很明白。。。

## 不使用 volatile 关键字时发生的共享变量不可见

就是说当 A 线程更改了 shared 变量的值之后， B 线程读取到的 shared 变量依然是更改后的值。

定义一个线程共享变量 `shared` 在内存中，然后开两个线程 A 和 B 来操作 `shared`，多处理器环境下，可能一个处理器跑 A，一个处理跑 B，两个线程一开始都读取 `shared`，处理器将 `shared` 都放进了各自的缓存行中，就像下面这样。

![unuse-volatile-1](/img/post/unuse-volatile-1.png)

紧接着 A 线程更改了 shared 的值：

![unuse-volatile-2](/img/post/unuse-volatile-2.png)

因为已经将 shared 变量加载进了缓存行中，所以线程 A 在对 shared 进行写操作时，发生了**写命中**，变量值的改变只发生在了处理器的缓存行中，而没有改变内存中的 shared 的值，线程 B 中的值也依然是原来的。

那么，使用 volatile 是什么效果呢？

## 使用 volatile 规避共享变量可见性问题

同样的情况下，如果对 `shared` 加上 `volatile` 修饰，当线程 A 修改了 shared 的值时，会将 shared 的值同步到内存，而其他线程中对应的缓存行则被标记为失效，下次读取 shared 时，会强制从内存读取。

![use-volatile-1](/img/post/use-volatile-1.png)