---
title: 队列同步器原理分析
date: 2020-10-11 14:59:06
tags: Java
categories: 多线程技术
cover: https://hanelalo.github.io/images/202111061308433.jpg
---

# 队列同步器原理分析

上一篇讲了 Lock 和 队列同步器基础，并实现了一个简单的锁。

本文将基于上一篇讲的知识，稍微深入点理解队列同步器。

## 同步队列

当多个线程竞争一个锁时，没有拿到锁的线程会加入到同步队列中等待。

AbstractQueuedSynchronizer 内部维护的是一个双向队列来实现同步队列，同步器保留队列的头节点和尾节点的引用。因为并发场景下可能会有多个线程加入队列，所以新的节点加入队列时，为了保证线程安全，提供了 `compareAndSetTail(Node expect, Node update)` 方法，使用 CAS 的方式将新节点加入同步队列。

每个节点内部维护的属性主要有：

* `int waitState`

  等待状态，有以下 4 中状态：

  * `CANCELED`

    值为 1，由于节点线程等待超时或被中断，该节点需要从同步队列中摘除，该状态时一种终态，进入该状态的节点不会再变化。

  * `SIGNAL`

    值为 -1，后继节点的线程处于等待状态，如果当前节点线程释放了同步状态，将会通知后继节点尝试获取同步状态。

  * `CONDITION`

    值为 -2，该节点等待再 `Condition` 上，当其他线程调用了 `Condition.signal()` 方法时，该节点由等待队列转入同步队列，加入同步状态的竞争中。

  * `PROPAGATE`

    值为 -3，表示下次共享式获取同步状态将会无条件的被传播下去。

* `Node prev`

  前驱节点，节点加入队列时设置。

* `Node next`

  后继节点。

* `Node nextWaiter`

  等待队列中的后继节点。如果当前节点时共享的，那么这个字段是 `Node.SHARED` 常量，该熟悉不仅是等待队列中的后继节点，也是节点类型的（独占 or 共享）标志。

* `Thread thead`

  要获取同步状态的线程。

## 独占式获取同步状态

独占式获取同步状态，同步器提供的方法是 `acquire(int arg)`。

```java
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
```

首先调用需要自定义实现的抽象方法 `tryAcquire(int arg)`，尝试获取同步状态，如果获取失败，则调用`addWaiter(Node nextWaiter)`方法构造同步队列节点并加入同步队列尾部，因为是独占式获取同步队列，所以构造的节点的 `nextWaiter` 属性默认时 `Node.EXCLUSIVE`。在初次尝试调用 `compareAndSetTail` 方法将当前节点设置为为节点失败后，调用 `enq(Node node)` 方法，以死循环的方式设置当前节点为尾节点，直到成功才会退出。

```java
    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }

    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
```

然后调用 `acquireQueued(Node node, int arg)`方法，使新的节点以死循环的方式获取同步状态，如果获取失败，则阻塞线程，线程阻塞后，唤醒方式主要靠前驱节点出队或者中断信号实现，节点会一直检查当前节点是否满足条件，只要满足了条件，就从自旋中退出。

因为同步队列是 FIFO 一个的队列，满足先入先出的原则，所以这里的自旋的退出条件要求当前节点的前驱节点是头节点，才会再继续尝试获取同步状态。

当节点获取同步状态成功后，会把当前节点设置为头节点，将前驱节点的后继节点设为空，从同步队列中摘除。

```java
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
    
	private void setHead(Node node) {
        head = node;
        node.thread = null;
        node.prev = null;
    }
```

## 独占式释放同步状态

独占式释放同步状态通过 `release(int arg)` 方法实现。

首先调用自定义实现的 `tryRelease(int arg)`尝试释放同步状态，如果成功了，就调用 `unparkSuccessor(Node node)` 唤醒后继节点的线程。`unparkSuccessor(Node node)` 方法通过 `LockSupport` 来唤醒处于等待状态的线程。

```java
    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
```

## 共享式获取同步状态

共享式和独占式获取同步状态的最大区别在于，是否支持多个线程同时占有同步状态。

共享式获取同步状态通过 `acquireShared(int arg)` 实现。

当调用 `tryAcquireShared(int arg)`尝试共享式获取同步状态的返回值小于 0 时，表示获取失败，此时调用`doAcquireShared(int arg)`方法，构建一个节点类型为共享式（`nextWaiter=Node.SHARED`）的节点并加入到同步队列中，然后开始自旋获取同步状态，和独占式一样，也是在当前节点的前驱节点是头节点时尝试获取同步状态，如果获取成功，就设置当前节点为头节点，然后判断后继节点是否是共享式节点，如果是，唤醒后继节点的的线程。如果获取同步状态失败，和独占式一样，也会阻塞线程，等待唤醒。

```java
	public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) < 0)
            doAcquireShared(arg);
    }
	
	private void doAcquireShared(int arg) {
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                    int r = tryAcquireShared(arg);
                    if (r >= 0) {
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

```

## 共享式释放同步状态

共享式释放同步状态，会唤醒后继节点。

```java
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
```

## 实现一个可共享锁

结合上面所学，现在来实现一个允许两个线程共享式获取同步状态的锁。

```java
public class TwiceLock implements Lock {

  private static class Sync extends AbstractQueuedSynchronizer {

    public Sync(int count) {
      if (count <= 0) {
        throw new IllegalArgumentException("count must greater than zero: " + count);
      }
      setState(count);
    }

    @Override
    protected int tryAcquireShared(int arg) {
      int state = getState();
      int newState = state - arg;
      if(newState>=0){
        compareAndSetState(state, newState);
      }
      return newState;
    }

    @Override
    protected boolean tryReleaseShared(int arg) {
      int state = getState();
      int newState = state + arg;
      return compareAndSetState(state, newState);
    }
  }

  private final Sync sync = new Sync(2);

  @Override
  public void lock() {
    sync.acquireShared(1);
  }

  @Override
  public void lockInterruptibly() throws InterruptedException {}

  @Override
  public boolean tryLock() {
    return false;
  }

  @Override
  public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
    return false;
  }

  @Override
  public void unlock() {
    sync.releaseShared(1);
  }

  @Override
  public Condition newCondition() {
    return null;
  }
}
```

内部实现的同步器，只实现了`tryAcquireShared(int arg)`和`tryReleaseShared(int arg)`两个方法。

`tryAcquireShared(int arg)`方法先判断获取同步状态之后，同步器的状态是否大于等于 0，如果大于等于 0，获取成功，设置同步状态，返回 true，否则返回 false。

`tryReleaseShared(int arg)`方法则是直接将释放之后的状态通过 CAS 设置了状态，这里其实是有 bug 的，不过因为这里只是简单实现，所以就不管了。

现在来写个测试。

```java
public class TwiceLockTest {

  private static final Logger logger = LoggerFactory.getLogger(TwiceLockTest.class);

  @Test
  public void testTwiceLock(){
    logger.info("started...");
    Lock lock = new TwiceLock();
    CountDownLatch countDownLatch = new CountDownLatch(3);
    Runnable runnable =
        () -> {
          String threadName = Thread.currentThread().getName();
          logger.info("Thread {} started...", threadName);
          lock.lock();
          logger.info("Thread {} lock success...", threadName);
          try {
            Thread.sleep(5000);
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
          logger.info("Thread {} to be release lock...", threadName);
          lock.unlock();
          logger.info("Thread {} lock released...", threadName);
          countDownLatch.countDown();
        };
    Thread firstThread = new Thread(runnable,"First-Thread");
    Thread secondThread = new Thread(runnable, "Second-Thread");
    Thread thirdThread = new Thread(runnable,"Third-Thread");
    firstThread.start();
    secondThread.start();
    thirdThread.start();
    try {
      countDownLatch.await();
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    logger.info("shutdown...");
  }
}
```

测试结果如下。从日志可以看出，三个线程启动后，先是 Second-Thread 和 Third-Thread 两个线程拿到锁，First-Thread 没拿到锁，阻塞中，五秒后锁被释放，此时 First-Thread 拿到锁，五秒后 First-Thread 释放锁。

```
2020-10-11 17:46:10,721 INFO  [main] org.hanelalo.lock.TwiceLockTest - started...
2020-10-11 17:46:10,741 INFO  [Third-Thread] org.hanelalo.lock.TwiceLockTest - Thread Third-Thread started...
2020-10-11 17:46:10,741 INFO  [Second-Thread] org.hanelalo.lock.TwiceLockTest - Thread Second-Thread started...
2020-10-11 17:46:10,741 INFO  [First-Thread] org.hanelalo.lock.TwiceLockTest - Thread First-Thread started...
2020-10-11 17:46:10,742 INFO  [Second-Thread] org.hanelalo.lock.TwiceLockTest - Thread Second-Thread lock success...
2020-10-11 17:46:10,743 INFO  [Third-Thread] org.hanelalo.lock.TwiceLockTest - Thread Third-Thread lock success...
2020-10-11 17:46:15,758 INFO  [Second-Thread] org.hanelalo.lock.TwiceLockTest - Thread Second-Thread to be release lock...
2020-10-11 17:46:15,758 INFO  [Third-Thread] org.hanelalo.lock.TwiceLockTest - Thread Third-Thread to be release lock...
2020-10-11 17:46:15,758 INFO  [Third-Thread] org.hanelalo.lock.TwiceLockTest - Thread Third-Thread lock released...
2020-10-11 17:46:15,758 INFO  [First-Thread] org.hanelalo.lock.TwiceLockTest - Thread First-Thread lock success...
2020-10-11 17:46:15,758 INFO  [Second-Thread] org.hanelalo.lock.TwiceLockTest - Thread Second-Thread lock released...
2020-10-11 17:46:20,772 INFO  [First-Thread] org.hanelalo.lock.TwiceLockTest - Thread First-Thread to be release lock...
2020-10-11 17:46:20,773 INFO  [First-Thread] org.hanelalo.lock.TwiceLockTest - Thread First-Thread lock released...
2020-10-11 17:46:20,775 INFO  [main] org.hanelalo.lock.TwiceLockTest - shutdown...
```