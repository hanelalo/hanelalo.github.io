---
title: 微服务之我见
date: 2021-04-26 23:27:55
tags: 微服务
categories: 微服务
cover: http://image.hanelalo.cn/images/202111061343303.png
---

# 微服务之我见

> 本来是想记一下 dubbo 学习笔记的，不知道为什么写了一个晚上，写的全是个人对微服务的理解。

## 为什么需要微服务？

> 在后端这个方向发展到让人惊呼内卷的时代，后端架构已经经历了好几次变革，从单体应用到微服务应用，再到我看明白了一些的 Service Mesh，再到我还没看明白 Serverless，就离谱。

在互联网的泡沫还没到来时，那时甚至很多人都还在断网状态，也没有什么双十一（可能是我不知道），网站基本上都没什么高并发这种东西，一般都是直接一个应用直接打包放到 Tomcat 或者 Jboss 等服务器上跑，不管是点餐、支付、订单查询，全都一股脑放到一个应用程序里面，姑且叫做青铜时代。

后来，可能时流量稍微多了些，终于，一台服务器撑不住了，就一个应用多部署几个实例，然后找个 Nginx 做负载均衡，又能勉强度日，算是进入白银时代。

慢慢的，诶，越来越多的人联网了，互联网的黄金时代来了，然后网站瞬间就炸了，因为点餐、支付、查询这些操作都在一个应用里面，当访问人数巨多的时候，多个实例一个接一个的挂，一夜直接破产，在思考良久之后，终于又想到了一个问题，我点餐挂了就算了，我不点餐，我查询总可以吧，但是查询也跟着点餐一起挂了，就不合适，那就尝试把这两个功能做成两个应用吧，算了，顺便直接把支付也拆成一个应用，终于，有点微服务那味道了。

从上面一大片废话可以总结出：

其实微服务只是业务发展，导致业务的流量直线上升助推架构发展的必然结果，我觉得除了带来清晰开发团队职责划分（话是这么说，想想其实就是个屁）之外，还保证了整个业务体系的可用性，至少不会再出现点餐功能不可用的同时，查询都不可以的情况，再一个就是，从分布式的角度出发，就整个微服务应用的视角来看，比单体或者分布式单体应用更能抗住高并发。

说了这么多，那么微服务就是和所有场景吗，它就是互联网黄金时代初期，所有场景的最终答案吗？

其实并不是，在文章最开始就讲过，微服务本质上是分布式应用，既然是分布式，那就必定受 CAP 魔咒的约束，况且不管是选择 CP 还是 AP，都逃不开应用之间网络调用带来的延迟问题，所以在一些对网络要求极高极高的场景，微服务还是不行的，比如王者荣耀，比如 LOL，打过游戏的都知道，但凡延迟达到 100ms，就是 PPT 级别的效果，到 70ms 的样子勉强能玩，职业选手觉得 30ms 都有点卡，可见这种场景的低延迟要求之变态，这个时候要是还玩微服务，那基本就凉了。

换个角度讲，其实也没必要上来就搞微服务，从前面的废话里面可以发现，应用架构的演进其实是跟随业务的发展的，如果本身就只有几十上百的流量，这个时候搞微服务就是多此一举，更多的应用其实是一开始都是单体的，然后再慢慢演进成微服务应用。



## 关于服务拆分

前文大概讲了讲架构演进，但是一直都只提到要做微服务，但是从来没提怎么做，换个提问方式就是，如果一个单体应用要拆分为微服务应用，要怎么拆，拆成几个微服务？

先不回答这个问题，先讲另一个故事，就瞎写。

在后端架构体系发展的过程中，代码的艺术也在发展，Java 是一门面向对象的语言，大家都这样说，但是在 MVC 的开发模式下，硬生生写成了像 bash 脚本一样的脚本语言。

后来有人发现，MVC 模式下，业务操作其实就是 Service 里面那段代码，后来发现简单点总结就是 a 在 b 情况下对 c 做了 d 这件事，这样的勉强叫做一个**用户故事**，而 d 这件事，其实就是真正的业务了，既然使用的事 Java 这种面向对象的语言，那能不能摈弃脚本式的开发，让业务操作通过对象真正体现它的业务意义，就像最开始学习 Java 的时候，讲到动物这种对象的时候，说动物吃了 1 斤食物，它的体重也上涨 1 斤，这个时候老师教我们的不是直接 `animal.setWeight(animal.getWeight+1)`，而是像下面这样：

```java
class Animal {
    private int weight;
    
    public Animal(int weight){
        this.weight = weight;
    }
    
    public void eat(int food){
        this.weight += food;
    }
    
}

public static void main(String[] args){
    Animal animal = new Animal(10);
    animal.eat(1);
}
```

这个时候，真正的体现了吃东西时 Animal 这个对象本身所具有的行为，把吃东西这个动作通过 `animal.eat()` 这个方法来体现了，而不是干瘪的提供一个 `setXxx` 方法，让任何操作都可以操作 Animal 内部的数据。

普通的业务操作其实也可以像上面一样，抽象成某个对象的一种行为。

再进一步思考，发现我可能这个业务在实现的时候，要操作的不只是一个类，可能有多个对象，比如可能我下单的同时，此时就看是不是可以把有些对象的行为的调用这个职责，又放到某个对象里面，等等，那这个对象是什么？

还记得前面说到的用户故事吗？

会 发现，每个用户故事里面似乎都会存在一个被操作的对象，那么这个对象，就可以抽象成为一个包揽了所有操作的那个大对象。

找到了大对象之后，再想象下面的场景，当你要操作一个订单的时候，首先必须要找到这个订单，此时必定总会通过订单号去找，总不能通过订单里面的商品去找吧，那找出来的单子可就不止一个了，所以此时可以把类似订单号这种唯一性标识当作这个大对象的 id。

此时，这个大对象对外暴露的方法不再是单纯的 getXxx 和 setXxx，而是有着业务命名示意的业务操作函数，终于从 MVC 的模式逃脱出来，发挥了 Java 面向对象的特性。

上面是针对单个业务来讲的，加入我原来有一个下单得业务了，得到了 Order 这样一个大对象，现在新增一些场景，网站需要用户吧，我总得有注册和登陆吧，我要是买了东西，那我总得寄快递，那总得给一个窗口让交易双方都能看见快递物流吧，这些场景，太多了，这个时候，如果还是把这些职责全部放在 Order 上，那势必会和下单应用部署在一起，那下单挂了，物流、登陆注册也就跟着一起没了，又回到青铜时代，所以这个时候，还得继续拆分，将物流和登陆注册拆分出去，此时有三个微服务了，物流、下单、用户，这三个微服务，都有自己的大对象，比如 Logistics、Order、Customer 等等，这个时候，又有问题了，既然分了三个微服务，那么每个微服务得数据，得存储吧，那我下单服务能直接动用户服务里边得东西吗？不行啊，这是一个从面向对象设计上就无法理解得东西，明明有 Customer 这样一个对象提供了各种操作，为什么 Order 要直接动数据库里面得用户数据，那还要用户服务干啥？

诶，这个时候，感觉好像有些概念的划分了，有哪些数据或者对象其实是 Order 的，有哪些是 Customer 的，有那些事 Logistics 的，啧，这样似乎就能明确每个微服务的边界了，这不就拆分成功了吗？

话说到这里，想想这个过程，其实是基于某个业务场景出发，基于某些业务名词进行对象模型的建立，然后赋予这些模型有业务含义的行为方法，这玩意儿，我理解着，其实就是**领域驱动设计 (DDD) ，**而 Order 这些就对应了**聚合根**的概念，对建立的模型赋予业务含义命名的方法，其实就是为了做到 DDD 要求的统一语言。

> 太累了，为了直白的反向推导为什么要用 DDD，真的好累。这里推荐 Eric Evans 的《领域驱动设计: 软件核心复杂性应对之道》这本书。

其实 DDD 只是一种思想，诞生时间早于微服务，中间沉寂了几十年，最近这些年微服务盛行，发现 DDD 的思想刚好能解决服务拆分的问题，才又重新火了起来，而 DDD 常常提到的充血模型，我觉得其实不是用不用 DDD 的问题，而是开发的时候没有发挥 Java 特性的问题，所以说充血模型一直存在，只不过 DDD 刚好需要它，而不是 DDD 创造了它，DDD 在微服务解决的问题主要是五福拆分问题，具体写代码的时候，管你充血还是贫血，只要我操作的数据是我自己的就行了，哪怕写成脚本又怎样呢？[狗头保命]



## 关于 CQRS

CQRS，即是**命令查询职责分离**，其实也是在 DDD 模式下对于查询业务的一种解决方案，我的理解就是把查询业务和建立了领域模型的命令式业务（比如下单）分开，因为其实查询业务很少或者根本没有业务，偏激一点甚至可能一个查询业务就是一条复杂点的 SQL 而已，这个时候还非得搞各种建模啥的，就没必要，对于这种业务，直接查即可，在《微服务架构设计》种也有提供解决方案，但是现阶段的实践中，对于 CQRS 的实践做得稀烂。



## 领域事件

其实主要就是，当一个业务操作完成时，可能需要通知其他的应用，可以做某些操作了，这个通知其实就是领域事件了。

> 题外话，但是这种的一般都是跨服务了，涉及到分布式应用必须要面临的问题，那就是分布式事务，目前分布式事务我了解到的解决方案是使用 Saga 模型。同时可能还需要使用到消息中间件，既然使用到了消息中间件，那就还需要考虑如何保证消息发送成功，如何处理重复消费等问题，就很烦。

