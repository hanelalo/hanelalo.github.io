---
title: 消息存储
date: 2020-10-06 23:17:03
tags: RocketMQ
categories: 消息中间件
cover: http://image.hanelalo.cn/images/202111061344086.png
---

# 消息存储

RocketMQ 消息存储主要涉及到三个文件, CommitLog, ConsumeQueue, IndexFile.

CommitLog 文件存储了该 broker 上所有的消息, 也就是说不管是哪个 topic 消息, 都在 commit log 里面, 因为 commit log 里面有所有 topic 的消息, 所以当要消费某个 topic 的消息时, 如果直接去 commit log 里面找的话, 比较耗费性能, 所以又引入了 ConsumeQueue 消息消费队列, ConsumeQueue 是针对每个 topic 建立的, 里面存储了消息在 commit log 里面的位置, 消息长度, 消息 tag 等. 同样为了在查询消息时更加快速, 针对 commit log 又建立了索引 IndexFile, 提供了一种可以通过 key 或者时间区间来查询消息的方法.



消息存储的实现代码在 `DefaultMessageStore.asyncPutMessage()` 可以看见.

```Java
    public CompletableFuture<PutMessageResult> asyncPutMessage(MessageExtBrokerInner msg) {
        PutMessageStatus checkStoreStatus = this.checkStoreStatus();
        if (checkStoreStatus != PutMessageStatus.PUT_OK) {
            return CompletableFuture.completedFuture(new PutMessageResult(checkStoreStatus, null));
        }

        PutMessageStatus msgCheckStatus = this.checkMessage(msg);
        if (msgCheckStatus == PutMessageStatus.MESSAGE_ILLEGAL) {
            return CompletableFuture.completedFuture(new PutMessageResult(msgCheckStatus, null));
        }

        long beginTime = this.getSystemClock().now();
        CompletableFuture<PutMessageResult> putResultFuture = this.commitLog.asyncPutMessage(msg);

        putResultFuture.thenAccept((result) -> {
            long elapsedTime = this.getSystemClock().now() - beginTime;
            if (elapsedTime > 500) {
                log.warn("putMessage not in lock elapsed time(ms)={}, bodyLength={}", elapsedTime, msg.getBody().length);
            }
            this.storeStatsService.setPutMessageEntireTimeMax(elapsedTime);

            if (null == result || !result.isOk()) {
                this.storeStatsService.getPutMessageFailedTimes().incrementAndGet();
            }
        });

        return putResultFuture;
    }
```

首先检查了当前消息存储线程状态, 如果消息存储线程的状态是关闭, 或者当前 broker 不是 master, 当前 broker 不可写, 或者系统 PageCache 繁忙, 就不存储消息.

紧接着检查消息内容, 如果 topic 名称大于 127, 或者消息的 properties 长度大于配置的长度时, 也不再继续走存储的流程.

然后才调用 `commitLog.asyncPutMessage` , 其流程大致如下:

1. 获取 commit log 内存映射文件 MappedFile

```Java
MappedFile unlockMappedFile = null;
MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();
```

但是如果是第一个消息, 有可能会出现获取得 MappedFile 是空的情况.如果获取到的 MappedFile 是空的或者文件已经满了(MappedFile 有固定大小, 满了之后就需要创建新的 MappedFile), 就需要创建新的 MappedFile.

```Java
if (null == mappedFile || mappedFile.isFull()) {
    mappedFile = this.mappedFileQueue.getLastMappedFile(0); // Mark: NewFile may be cause noise
}
```

1. 获取写消息的锁, 也就是说, 消息写入 commit log 是串行的.

```Java
putMessageLock.lock(); 
```

1. 获取当前写消息的指针位置, 如果指针位置小于文件大小, 通过 slice 方法创建一个和原 ByteBuffer 共享的内存区., 并设置 position 为当前 position.

```Java
if (currentPos < this.fileSize) {
    ByteBuffer byteBuffer = writeBuffer != null ? writeBuffer.slice() : this.mappedByteBuffer.slice();
    byteBuffer.position(currentPos);
    // ...
}
```

1. 创建消息唯一性 id

```Java
msgId = MessageDecoder.createMessageId(this.msgIdMemory, msgInner.getStoreHostBytes(storeHostHolder), wroteOffset);
```

1. 获取消息队列写入偏移量.

```Java
// Record ConsumeQueue information
keyBuilder.setLength(0);
keyBuilder.append(msgInner.getTopic());
keyBuilder.append('-');
keyBuilder.append(msgInner.getQueueId());
String key = keyBuilder.toString();
Long queueOffset = CommitLog.this.topicQueueTable.get(key);
if (null == queueOffset) {
    queueOffset = 0L;
    CommitLog.this.topicQueueTable.put(key, queueOffset);
}
```

1. 根据消息长度, 主题长度, 消息属性长度结合消息存储格式计算消息总长度.

```Java
    protected static int calMsgLength(int sysFlag, int bodyLength, int topicLength, int propertiesLength) {
        int bornhostLength = (sysFlag & MessageSysFlag.BORNHOST_V6_FLAG) == 0 ? 8 : 20;
        int storehostAddressLength = (sysFlag & MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == 0 ? 8 : 20;
        final int msgLen = 4 //TOTALSIZE
            + 4 //MAGICCODE
            + 4 //BODYCRC
            + 4 //QUEUEID
            + 4 //FLAG
            + 8 //QUEUEOFFSET
            + 8 //PHYSICALOFFSET
            + 4 //SYSFLAG
            + 8 //BORNTIMESTAMP
            + bornhostLength //BORNHOST
            + 8 //STORETIMESTAMP
            + storehostAddressLength //STOREHOSTADDRESS
            + 4 //RECONSUMETIMES
            + 8 //Prepared Transaction Offset
            + 4 + (bodyLength > 0 ? bodyLength : 0) //BODY
            + 1 + topicLength //TOPIC
            + 2 + (propertiesLength > 0 ? propertiesLength : 0) //propertiesLength
            + 0;
        return msgLen;
    }
```

- TOTALSIZE 消息总长度, 4 字节
- MAGICCODE 魔数, 4 字节, 固定值 0xdaa320a7
- BODYCRC CRC 校验码, 4 字节
- QUEUEID 消息队列 ID, 4 字节
- FLAG 消息 flag, 一般是业务逻辑中处理, 4 字节
- QUEUEOFFSET 消息在消息队列中的偏移量, 8 字节
- PHYSICALOFFSET 消息在 commit log 中的偏移量, 8 字节
- SYSFLAG 消息系统 flag, 比如消息是否压缩, 是否为事务消息等, 4 字节
- BORNTIMESTAMP 消息生产者发送消息的时间戳, 8 字节
- BORNHOST 消息发送者 ip, 端口号, 一般 8 字节
- STORETIMESTAMP 消息存储时间戳, 8 字节
- STOREHOSTADDRESS 存储消息的 broker ip 和 端口, 8 字节
- RECONSUMETIMES 消息重试次数, 4 字节
- Prepared Transaction Offset 事务消息偏移量
- BODYLENGTH 消息体长度, 4 字节(代码中未注释)
- BODY 消息体
- propertiesLength 消息属性长度

如果计算出的消息长度比配置的消息最大长度大, 返回 *MESSAGE_SIZE_EXCEEDED.*

```Java
// Exceeds the maximum message
if (msgLen > this.maxMessageSize) {
    CommitLog.log.warn("message size exceeded, msg total size: " + msgLen + ", msg body size: " + bodyLength
        + ", maxMessageSize: " + this.maxMessageSize);
    return new AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);
}
```

如果计算出的长度+END_FILE_MIN_BLANK_LENGTH 大于 commit log 文件剩余空间大小, 会重新创建一个 MappedFile:

```Java
// Determines whether there is sufficient free space
if ((msgLen + END_FILE_MIN_BLANK_LENGTH) > maxBlank) {
    this.resetByteBuffer(this.msgStoreItemMemory, maxBlank);
    // 1 TOTALSIZE
    this.msgStoreItemMemory.putInt(maxBlank);
    // 2 MAGICCODE
    this.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);
    // 3 The remaining space may be any value
    // Here the length of the specially set maxBlank
    final long beginTimeMills = CommitLog.this.defaultMessageStore.now();
    byteBuffer.put(this.msgStoreItemMemory.array(), 0, maxBlank);
    return new AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),
        queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills);
}
```

这里在返回 END_OF_FILE 之前, 先写入了当前 MappedFile 的空闲空间大小, 4 字节, 还写了魔数 BLANK_MAGIC_CODE, 4 字节, 也就是说, 每个 MappedFile 都至少会有 8 字节空闲, 用来存储魔数和剩余空间大小.

1. 消息写入 MappedFile 内存映射空间, 返回 PUT_OK.

```Java
final long beginTimeMills = CommitLog.this.defaultMessageStore.now();
// Write messages to the queue buffer
byteBuffer.put(this.msgStoreItemMemory.array(), 0, msgLen);

AppendMessageResult result = new AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgId,
    msgInner.getStoreTimestamp(), queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills);
```

1. 释放锁

```Java
putMessageLock.unlock();
```

1. 消息刷盘

```Java
CompletableFuture<PutMessageStatus> flushResultFuture = submitFlushRequest(result, putMessageResult, msg);
CompletableFuture<PutMessageStatus> replicaResultFuture = submitReplicaRequest(result, putMessageResult, msg);
```