---
title: 注册中心重试机制
date: 2021-05-16 00:22:18
tags: Dubbo
categories: Dubbo
cover: http://image.hanelalo.cn/images/202111061325725.png
---

# 注册中心重试机制

在之前的文章中，很多次涉及 FailbackRegistry 的时候，都只是说明这个类主要是实现各种重试任务的，但是一直没有细细说明。

> 从上上篇文章一直拖到了现在。。。

首先介绍一下 FailbackRegistry 中的四个重要属性：

* `ConcurrentMap<URL, FailedRegisteredTask> failedRegistered `

  key 是注册失败的 URL，value 是注册的重试任务。

* `ConcurrentMap<URL, FailedUnregisteredTask> failedUnregistered`

  key 是取消注册失败的 URL，value 是取消注册的重试任务。

* `ConcurrentMap<Holder, FailedSubscribedTask> failedSubscribed`

  key 是订阅失败的 URL 的 Holder，value 是订阅的重试任务。

* `ConcurrentMap<Holder, FailedUnsubscribedTask> failedUnsubscribed`

  key 是取消订阅失败的 Holder，value 是取消订阅的重试任务。

> 在 dubbo 的源码的历史里面，以及一些将到 FailbackRegistry 的文章中可能还会提到一个 failedNotified 属性，这个确实是存在过的，但是在 dubbo 的 `#6401` 这个 issue 中删除了。

现在先提出 2 个问题，带着问题去源码中寻找答案，能更好的学习源码，以及理解它的机制。

1. 上述的几个 map 中的键值对，是什么时候添加的 ？又是什么时候删除的 ？
2. 为什么 key 有些是 URL，有些是 Holder ？

第一个问题，既然是失败才会重试，那么肯定是在第一次做操作失败时开启的重试任务，以服务注册为例，查看 `FailbackRegistry#register()` 方法就能找到蛛丝马迹。

```java
    @Override
    public void register(URL url) {
        if (!acceptable(url)) {
            logger.info("URL " + url + " will not be registered to Registry. Registry " + url + " does not accept service of this protocol type.");
            return;
        }
        super.register(url);
        removeFailedRegistered(url);
        removeFailedUnregistered(url);
        try {
            // Sending a registration request to the server side
            doRegister(url);
        } catch (Exception e) {
            Throwable t = e;

            // If the startup detection is opened, the Exception is thrown directly.
            boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)
                    && url.getParameter(Constants.CHECK_KEY, true)
                    && !CONSUMER_PROTOCOL.equals(url.getProtocol());
            boolean skipFailback = t instanceof SkipFailbackWrapperException;
            if (check || skipFailback) {
                if (skipFailback) {
                    t = t.getCause();
                }
                throw new IllegalStateException("Failed to register " + url + " to registry " + getUrl().getAddress() + ", cause: " + t.getMessage(), t);
            } else {
                logger.error("Failed to register " + url + ", waiting for retry, cause: " + t.getMessage(), t);
            }

            // Record a failed registration request to a failed list, retry regularly
            addFailedRegistered(url);
        }
    }
```

这段代码其实在分析服务注册和订阅的源码时就看过，只不过添加重试任务的代码直接略过了。

从代码逻辑上可以了解到，在真正调用实现了进行注册之前，就调用了`removeFailedRegistered(url)`、               `removeFailedUnregistered(url)` 两个方法，从命名上就可以知道其实就是删除重试任务的，事实上也确实就是如此，通过 URL 将 failedRegisterd 和 failedUnregistered 中的键值对映射删除，然后调用重试任务的 `cancel()` 方法取消重试任务。

```java
    private void removeFailedRegistered(URL url) {
        FailedRegisteredTask f = failedRegistered.remove(url);
        if (f != null) {
            f.cancel();
        }
    }

    private void removeFailedUnregistered(URL url) {
        FailedUnregisteredTask f = failedUnregistered.remove(url);
        if (f != null) {
            f.cancel();
        }
    }
```

现在知道了重试任务的删除条件，继续在 `register()` 方法里面往下看，调用子类`doRegister()` 失败，做异常处理时，最后添加了重试任务。

```java
            Throwable t = e;

            // If the startup detection is opened, the Exception is thrown directly.
            boolean check = getUrl().getParameter("check", true)
                    && url.getParameter("check", true)
                    && !"consumer".equals(url.getProtocol());
            boolean skipFailback = t instanceof SkipFailbackWrapperException;
            if (check || skipFailback) {
                if (skipFailback) {
                    t = t.getCause();
                }
                throw new IllegalStateException("Failed to register " + url + " to registry " + getUrl().getAddress() + ", cause: " + t.getMessage(), t);
            } else {
                logger.error("Failed to register " + url + ", waiting for retry, cause: " + t.getMessage(), t);
            }
            // Record a failed registration request to a failed list, retry regularly
            addFailedRegistered(url);
```

如果子类抛出的异常是 `SkipFailbackWrapperException`，或者注册的 url 里面的 `check` 参数为 `true` 时，直接抛异常，也不会添加重试任务。

然后再看看 `addFailedRegistered(url)` 的逻辑：

```java
    private void addFailedRegistered(URL url) {
        // 查询是否已经存在重试任务
        FailedRegisteredTask oldOne = failedRegistered.get(url);
        if (oldOne != null) {
            // 已经存在重试任务，直接返回
            return;
        }
        // 新建一个任务，并添加到 failedRegistered 中。
        FailedRegisteredTask newTask = new FailedRegisteredTask(url, this);
        oldOne = failedRegistered.putIfAbsent(url, newTask);
        if (oldOne == null) {
            // dobbo 内部实现的一个时间轮的 Timer
            retryTimer.newTimeout(newTask, retryPeriod, TimeUnit.MILLISECONDS);
        }
    }
```

1. 首先是通过注册的 URL 查询是否已经存在这个 URL 的重试任务了，如果有，那就直接返回。
2. 如果没有，那就新建一个服务注册的重试任务，并添加到 failedRegistered 中。
3. 通过`retryTimer.newTimeout()` 方法执行重试任务，这个 retryTimer 是 dubbo 自己实现的时间轮算法 `HashedWheelTimer`（放到后面专门记学习过程中比较零碎的小发现里面剖析了）。

