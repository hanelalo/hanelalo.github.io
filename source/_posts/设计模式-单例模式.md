---
title: '设计模式:单例模式'
date: 2021-01-09 11:41:08
tags: 设计模式
categories: 设计模式
cover: https://hanelalo.github.io/images/202111061339337.png
---

> 本文是学习极客时间《设计模式之美》专栏的笔记。

# 单例模式

单例模式，虽然平时编码不怎么用到，但是时常听到，甚至于常常会用到一些使用了单例模式的工具类。

坦白说，**单例模式就是一个类，只允许创建一个对象或实例。**

要实现一个单例模式的设计，需要考虑一下 4 个关键点：

* 构造函数必须要以`private`关键字修饰。
* 对象创建时是否线程安全。
* 是否支持延迟加载。
* getInstance() 方法性能是否高。

## 饿汉式

饿汉式的设计比较简单，会在加载类的时候就创建实例，这样可以避免线程安全的问题，但是也因此不支持延迟加载。

```java
public class IdGenerator {
	private AtomicInteger id = new AtomicInteger();
	private static final IdGenerator instance = new IdGenerator();
	private IdGenerator(){
	}
    
	public IdGenerator getInstance(){
		return instance;
	}
    
	public int generate(){
		return id.getAndIncrement();
	}

}
```

## 懒汉式

懒汉式，和饿汉式恰恰相反，就是用到的时候再初始化对象，从而支持了延迟加载。

```java
public class IdGenerator {
	private AtomicInteger id = new AtomicInteger();
	private static IdGenerator instance;
	private IdGenerator(){
	}
    
	public IdGenerator getInstance(){
		if(instance == null){
			instance = new IdGenerator();
		}
		return instance;
	}
    
	public int generate(){
		return id.getAndIncrement();
	}

}
```

但是按照上面的写法会有个问题，那就是在高并发场景下并不是线程安全的。

比如当线程 A 发现 instance 是 null 时尝试初始化 instance，但是还没有初始化完成，此时线程 B 也通过 IdGenerator 生成 ID，此时也会认为 instance 是 null，也会尝试初始化 instance，此时就违背了单例模式的设计初衷。

## 双重检测

为了解决懒汉式的线程安全问题，需要对初始化的过程加锁，优化之后的代码如下：

```java
public class IdGenerator {
	private AtomicInteger id = new AtomicInteger();
	private static IdGenerator instance;
	private IdGenerator(){
	}
    
	public IdGenerator getInstance(){
		if(instance == null){
			// 对类加锁，保证线程安全
			synchronized (IdGenerator.class){
				if(instance == null){
					instance = new IdGenerator();
				}
			}
		}
		return instance;
	}

	public int generate(){
		return id.getAndIncrement();
	}

}
```

双重检测的实现方式，支持延迟加载，并且也没有现成安全问题，但是，在低版本的 JDK 中依然可能会因为指令重排导致线程安全问题。

## 静态内部类

使用静态内部类的实现方式，比较取巧，就是将单例的初始化委托给静态的内部类：

```java
public class IdGenerator {
	private AtomicInteger id = new AtomicInteger();
	private static IdGenerator instance;
	private IdGenerator(){
	}

	private static class SingletonHolder{
		private static final IdGenerator instance = new IdGenerator();
	}

	public IdGenerator getInstance(){
		// 调用 getInstance() 方法时才会加载 SingletonHolder 类，
		// 实现了延迟加载
		return SingletonHolder.instance;
	}

	public int generate(){
		return id.getAndIncrement();
	}

	public int generate(){
		return id.getAndIncrement();
	}
}
```

这种方式也支持延迟加载，因为是在第一次调用 getInstance() 方法时才会加载 `SingletonHolder`，顺便将 `SingletonHolder.instance`初始化，而且这个过程是线程安全的。

## 枚举

通过枚举实现单例模式，说实话我对没见过(是我见识短浅了)。

但是这种方式依然也是能保证线程安全，但是个人认为，这种方式应该也之适用于比较简单的单例设计。

```java
public enum IdGenerator {
	INSTANCE;
	private AtomicLong id = new AtomicLong(0);
	public long getId() {
		return id.incrementAndGet();
	}
}
```

