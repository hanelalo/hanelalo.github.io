---
title: 实现一个简单的线程池
date: 2020-10-07 15:33:32
tags: Java
categories: 多线程技术
cover: https://hanelalo.github.io/images/202111061341804.png
---

> 本文是在学习《Java 并发编程艺术》的笔记。

一个简单的线程池，应该有工作线程（Worker），统一的线程管理（ThreadPool），任务对象（Job）。

# 定义接口

遵从接口隔离原则，上述三个对象都以接口形式提供。

```Java
public interface Worker extends Runnable {
  /** 
   * 关闭工作线程
   */
  void shutdown();
}

public interface Job {
  /**
   * 执行任务逻辑
   */
  void run();
}

public interface ThreadPool {

  /**
   * 添加带执行任务
   *
   * @param job job
   */
  void execute(Job job);

  /** 关闭线程池 */
  void shutdown();

  /**
   * 添加工作线程
   *
   * @param nums nums
   */
  void addWorkers(int nums);

  /**
   * 删除工作线程
   *
   * @param nums nums
   */
  void removeWorkers(int nums);

  /**
   * 当前待执行任务数
   *
   * @return int
   */
  int getJobSize();
}
```

# 实现

现在实现线程池，因为工作线程会一直扫描线程池中的任务列表，所以工作线程的实现类也直接当作了线程池的内部类。

```Java
class ThreadPoolImpl implements ThreadPool {
  /** 线程池最大工作线程数 */
  private static final int MAX_WORKER_NUMS = 10;
  /** 线程池默认工作线程数 */
  private static final int DEFAULT_WORKER_NUMS = 5;
  /** 线程池最小线程数 */
  private static final int MIN_WORKER_NUMS = 1;
  /** 任务列表 */
  private final LinkedList<Job> jobs = new LinkedList<>();
  /** 工作线程 */
  private final List<Worker> workers = Collections.synchronizedList(new ArrayList<>());
  /** 工作线程数 */
  private int WORKING_NUMS = DEFAULT_WORKER_NUMS;
  /** 线程 id 生成器 */
  private AtomicLong threadIdGenerator = new AtomicLong();

  public ThreadPoolImpl() {
    initWorkers(WORKING_NUMS);
  }

  public ThreadPoolImpl(int nums) {
    WORKING_NUMS = nums > MAX_WORKER_NUMS ? MAX_WORKER_NUMS : Math.max(nums, MIN_WORKER_NUMS);
    initWorkers(WORKING_NUMS);
  }

  private void initWorkers(int nums) {
    for (int i = 0; i < nums; i++) {
      Worker worker = new WorkerImpl();
      workers.add(worker);
      Thread thread = new Thread(worker, "Worker_Thread_" + threadIdGenerator.incrementAndGet());
      thread.start();
    }
  }

  @Override
  public void execute(Job job) {
    if (Objects.nonNull(job)) {
      synchronized (jobs) {
        jobs.add(job);
        jobs.notify();
      }
    }
  }

  @Override
  public void shutdown() {
    Iterator<Worker> iterator = workers.iterator();
    while (iterator.hasNext()) {
      Worker worker = iterator.next();
      worker.shutdown();
      workers.remove(worker);
    }
  }

  @Override
  public void addWorkers(int nums) {
    synchronized (jobs) {
      if (WORKING_NUMS + nums <= MAX_WORKER_NUMS) {
        initWorkers(nums);
        WORKING_NUMS += nums;
        jobs.notify();
      }
    }
  }

  @Override
  public void removeWorkers(int nums) {
    synchronized (jobs) {
      if (WORKING_NUMS - nums >= MIN_WORKER_NUMS) {
        for (int i = 0; i < nums; i++) {
          Worker worker = workers.get(i);
          workers.remove(worker);
          worker.shutdown();
        }
        WORKING_NUMS -= nums;
        jobs.notify();
      }
    }
  }

  @Override
  public int getJobSize() {
    return jobs.size();
  }

  class WorkerImpl implements Worker {

    private volatile boolean running = true;

    @Override
    public void run() {
      if (running) {
        Job job = null;
        synchronized (jobs) {
          try {
            while(jobs.isEmpty()){
              jobs.wait();
            }
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
          job = jobs.removeFirst();
        }
        if(job != null){
          job.run();
        }
      }
    }

    @Override
    public void shutdown() {
      this.running = false;
    }
  }
}
```

在添加工作线程、删除工作线程、添加新的任务的时候，都对 jobs 进行了锁定，防止并发操作。

工作线程 `WorkerImpl` 通过一个 `running` 属性对工作线程的启停进行控制，当 `running = true` 时，工作线程处于工作状态，先判断任务列表是否为空，如果是空的，就调用 `jobs.wait()` 进入等待，直到其他线程唤醒，或者 jobs 不为空，从 jobs 中取出第一个 job，并从任务列表中删除，最后调用 `job.run()` 执行任务。