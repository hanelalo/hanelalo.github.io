---
title: JVM类加载机制
date: 2022-01-29 15:21:40
tags: 
  - JVM
  - 读书笔记
  - 深入理解Java虚拟机
categories: Java虚拟机
cover: https://hanelalo.github.io/images/20220129152458.jpg
---

# JVM 类加载机制

## 加载

在加载阶段，JVM 要完成以下 3 件事：

1. 通过一个类的全限定名来获取一个类的字节流。
2. 将这个二进制数据流代表的静态数据结构转换成为方法区的运行时数据结构。
3. 内存中为这个类生成一个 java.lang.Class 对象，作为方法区中这个类各种访问的入口。

因为第 1 点并没有明确规定从哪里获取一个类的字节流，也就是说这是交给开发者自己实现的，所以就有了现在的以 jar、war 的形式启动的方式，这种相当于是从压缩文件获取字节流，还有一些比较少见的从数据库获取字节流的场景，以及现在很多 AOP 框架还会在运行时动态构建字节流来实现动态代理，甚至一些闭源的代码的字节流在这一步还需要进行解密，总之因为这一步没有明确定义路径，所以很灵活得支持了很多场景。

上面的操作，都是基于加载的是一个类而不是数组的前提的。对于数组，它最后在方法区中也会有一个对应的 java.lang.Class 对象，只不过不是由类加载器加载，而是 JVM 在内存中直接构建的，但是根据数组的元素类型(不管是一维数组还是多维数组，将所有纬度去掉之后的类型)和组件类型(指去掉一个纬度之后的类型，如果是多维数组，这里的组件类型可能还是个数组)，还是会和类加载器有关系，比如有一个数组 C[][]，它的元素类型是 C，组件类型是 C[]，根据 C 类型的不同，分为 2 种情况：

1. 如果组件类型是引用类型，最终还是会使用类加载器来加载 C 这个类，而整个 C[][] 的加载也是通过递归的方式进行加载，每次递归加载的时候也依然会根据具体的类型决定如何加载，而数组也将会标识在类加载器上。
2. 如果组件类型是基础类型，比如 int 或者 int[]，JVM 会把这个类标识在引导类加载器上。

加载阶段完成后，方法区就会有类型对应的 java.lang.Class 对象，并且，加载过程和下一阶段的验证很多时候是交叉着在执行的，因为字节流转换成 java.lang.Class 对象时需要进行一些必要的格式校验，比如魔数。虽然这两步是交叉运行，但是开始时间依然是先加载、后验证的顺序严格执行的。

## 连接
连接阶段又细分成了验证、准备、解析 3 个阶段。

### 验证
验证阶段主要是验证字节码的合法性，验证字节码是否对的《Java 虚拟机规范》的全部约束要求，主要分为文件格式验证、元数据验证、字节码验证、符号引用验证。

验证阶段其实是非常重要但非必要的步骤，如果全是经过大量使用的依赖包，可以考虑关掉验证这一步，因为这一步本质上只是通过、不通过两种输出的区别而已，可以通过 `-Xverify:none` 参数关闭。

#### 文件格式验证

这里主要验证二进制流中的魔数、版本号等信息是否正确，除了这两个，其实还验证了很多东西。这一步是基于字节流验证的，在这一步验证通过之后才能通过这个字节流转换成 java.lang.Class 对象，后续的验证都是基于这一步验证之后生成的字节码对象进行验证。

#### 元数据验证

元数据验证阶段，主要是对字节码描述信息进行语意验证，比如是否继承了不能被继承的类(final 修饰的类)，是否实现了继承的抽象类中必须要实现的方法。

#### 字节码验证

整个验证过程中最复杂的阶段，这里主要通过数据流分析和控制流分析判断语义合法性和逻辑正确性，确保不会做出危害虚拟机的行为，比如：
* int 类型变量不会按照 long 类型加载到本地变量表中。
* 任何跳转指令不会跳转到字节码之外的字节码指令上。

如果一个类型中有方法没有校验通过，那么一定是不合法的，但是如果所有方法都检验通过了，也不能保证一定是合法的，因为不可能用一段程序来判断另一端程序是否有 bug（比如平时写单元测试的时候，不能保证一定覆盖了所有场景，只能说能想到的场景都覆盖了）。

#### 符号引用验证

其实主要就是检查当前的类型中是否缺少、进制访问依赖的方法、类、接口、字段等资源，比如直接访问另一个类的 private 修饰的字段，通常是过不了这一个检查的。

### 准备

### 解析

## 初始化

## 使用

## 卸载
