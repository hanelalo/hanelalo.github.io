---
title: 动态规划（二）
date: 2021-01-19 22:45:31
tags: 动态规划
categories: 算法
cover: https://hanelalo.github.io/images/202111061037617.jpg
---





# 动态规划（二）

上一篇文章分析了几道比较经典的动态规划算法题，这一讲依然是刷题笔记了。

## 最大递增子序列

给定一个序列`[5,4,2,3,1,6,7]`，输出 4，因为它的最大递增子序列为 `[2,3,6,7]`。

首先，定义 dp 表，`dp[0...i]`，dp[i] 表示以第 i 个元素结尾的序列的最大递增子序列长度。

然后 base case 就是，`dp[0] = 0`。

最后，列出状态转移方程，`dp[0] = 0，当 0 <= j <= i 时，如果 nums[i]>nums[j]，dp[i] = max(dp[0...j]+1)，否则 nums[i] = max(dp[0...j]) `。

那么，代码实现如下：

```java
publiv int solution(int[] nums) {
    int[] dp = new int[nums.length];
    Arrays.fill(dp, 1);
    for(int i = 0; i < nums.length; i++){
        for(int j = 0; j < i; j++){
            if(nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j]+1);
            }
        }
    }
    return dp[nums.length - 1];
}
```

## 信封嵌套问题

给一些已知长和宽的信封，要将这些信封层层嵌套，问最多能嵌套几层？

比如`长宽分别为[w,h]信封: [[5,4],[6,4],[6,7],[2,3]]`，输出为 3，可以嵌套的有`[[2,3],[5,4].[6,7]]`。

这个解题思路说实话不容易想到，现根据 w (或者 h) 升序排序，相同的按照 h (或者 w) 降序排序，然后取排序后的 h (或者 w)的最大递增子序列，起始就是经过两次排序之后转换成上一节的最大递增子序列问题。

```java
public int solution(int[][] envelopes) {
    // 排序
    Arrays.sort(envelopes, (o1, o2) -> o1[0] == o2[0] ? o2[1] - o1[1] : o1[0] - o2[0]);
    int[] height = new int[envelopes.length];
    for(int i = 0; i < envelopes.length; i++){
        height[i] = envelopes[i][0];
    }
    // 和上面的最大递增子序列问题一样的代码逻辑
    int[] dp = new int[height.length];
    Arrays.fill(dp, 1);
    for(int i = 0; i < height.length; i++){
        for(int j = 0; j < i; j++){
            if(nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j]+1);
            }
        }
    }
    return dp[height.length - 1];
}
```

## 最小编辑距离

最小编辑距离问题，在只能做插入、替换、删除三种操作的情况下，将字符串 A 转换成为字符串 B，最少需要多少次操作？

