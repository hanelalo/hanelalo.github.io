---
title: 垃圾收集器：G1
date: 2022-01-19 23:10:28
tags: 
    - JVM
    - 读书笔记
    - 深入理解Java虚拟机
categories: Java虚拟机
cover: http://image.hanelalo.cn/images/202201182252051.png
---

> 本文是《深入理解 Java 虚拟机》第 3 版的读书笔记。

# G1 收集器

G1 收集器，全称 Garbage First 收集器。

## 历史

在 JDK 6 Update 14 版本时，G1 就已经提供给了开发人员测试和试用；JDK 7 Update 4 的时候，Oracle 才认为它达到了可商用的程度；在 JDK 8 Update 40 时提供并发的类卸载的卸载，此后 Oracle 称它是全能的垃圾收集器；JDK 9 发布时，它代替了 Parallel Scavenge + Parallel Old 组合成为服务端模式下的默认垃圾收集器组合，同时 CMS 不再是推荐的垃圾收集器，当使用 `-XX:+UseConcMarkSweepGC` 开启 CMS 收集器时，还会收到警告信息，提示 CMS 收集器未来将会被丢弃；JDK 10 时提出了一套“统一垃圾收集器接口”，将内存回收的“行为”与“实现”分离，CMS 及其他收集器重构成了基于该接口的一套实现。 

G1 收集器的论文是在 2004 年 Sun 实验室发表的，但是一直到 2012 年 4 月的 JDK 7 Update 4 才真的发布，可见它是真的复杂。

## 设计思路

### 停顿预测模型

G1 收集器的设计目标是希望能够建立“停顿预测模型”的收集器，停顿预测模型的意思是：能够支持在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不超过 N 毫秒。

### Mixed GC

上一篇笔记讲过，Mixed GC 是指新生代和部分老年代内存区域一起收集。

这是按照分代收集理论的角度来讲的。但是对于 G1 来讲，并不是真的分了一部分内存作为老年代或者新生代，然后针对不同分代收集，它是面向堆内存任何部分来组成回收集进行回收，衡量标准不再是属于那个分代，而是哪块内存的垃圾最多，回收后的收益最高，这就是 G1 收集器的 Mixed GC。

### Region 内存模型

为了实现前面的 Mixed GC，G1 收集器将堆内存划分为多个大小相等的内存块，这种模型叫做 Region 模型，每一个 Region 块可以视情况作为新生代的 Eden 空间或者 Survivor 空间，或者老年代空间，对于扮演不同角色的 Region 块，G1 采用不同的策略去收集，这样不管是新生代还是老年代的对象都能有很好的收集效果。

#### Humongous 区域

Humongous 区域是一种特殊的 Region 块，用来存储大对象。程序运行时不可避免的可能会产生大对象，对于超过一个 Region 一般容量大小的对象，认为是大对象，Region 的大小可以通过 `-XX:G1HeapRegionSize` 设定，取值范围是 1 MB ~ 32 MB，且为 2 的 N 次幂，对于超过整个 Region 块容量的大对象，G1 会使用多个连续的 Humongous 区域来存储，这样的 Hmongous 区域一般都会被当成老年代。

> 到这里可以知道，虽然 G1 收集器也是按照分代收集理论设计，但是它的新生代和老年代区域大小不是固定的，而是一系列可以不连续的 Region 块的动态集合。

### 回收区域优先级

现在我们知道，G1 不像其他收集器那样，要么收集整个新生代，要么收集整个老年代，而是将整个堆内存划分成多个 Region 内存块，每次回收的时候其实是针对一些 Region 块的集合进行回收，这样就能有效避免在整个堆内存或者某个分代的内存区域进行全区域回收。

对于每次收集的 Region 块集合应该是哪些，G1 会跟踪每个 Region 块中垃圾堆积的“价值”大小，也就是回收后会得到的空间和回收所需要的时间，然后在自己维护一个优先级列表，然后根据用户允许的收集停顿时间，优先收集那些“价值”更大的 Region 块。

G1 允许的收集停顿时间通过 `-XX:MaxGCPauseMillis` 设置，默认为 200 ms。

## 面临的问题及解决方案

### 跨 Region 的引用怎么办？

解决跨 Region 引用的问题，其实和解决跨代引用的问题有点像，目前解决跨代引用问题主要使用的思路是**记忆集**，常用的实现是**卡表**。

#### 记忆集

当出现跨代引用时，为了避免将整个老年代一起进行一次扫描，专门设计了叫记忆集的数据结构，它是一种记录从非收集区域指向收集区域的指针的抽象数据结构。

最粗暴的实现就是用非收集区域的跨代引用的对象组成的数组来作为记忆集的实现，但是这种实现的维护成本和空间占用比较高，垃圾收集时，只要能判断出某一块内存区域是否有跨代引用就够了，这样就不用收集整个分代区域。

所以在设计记忆集的具体实现时，有了三种精度：

* 字长精度

  每个记录精确到一个机器字长，该字包含跨代指针。

* 对象精度

  每个记录精确到一个对象，该对象中有跨代指针。

* 卡精度

  精确到一块内存区域，该内存区域中有对象存在跨代引用指针。

卡表就是卡精度的实现。

#### 卡表

可以理解为卡表维护的是一个 Map，内存区域被分为了多个区域，每个区域都有一个编号，如果某个编号在这个 Map 中对应的值为 1，就表示这个区域存在跨代引用，在进行 GC 时将该区域也加入 GC 即可。

#### G1 的跨 Region 的解决方案

G1 收集器采用了卡表的思路，不过实现更加复杂。

每个 Region 块都维护了自己的卡表，记录那个 Region 指向了我，本质上是一个哈希表，Key 是别的 Region 的起始地址，Value 是一个集合，里面存的是每一个卡表的索引号。

因为每个 Region 都会维护自己的记忆集，这就导致 G1 收集器占用的内存相比于其他收集器更高。

### 并发标记阶段，如何保证收集器线程和用户线程互不干扰的运行？

在并发标记阶段，因为 GC 线程的标记动作和用户线程在并发执行，所以整个过程中，对象的引用关系可能会发生变化，当前的主流垃圾收集器都是使用的可达性分析算法来判断对象是否存活，此时就需要考虑如何实现并发下的可达性分析。

#### 并发可达性分析

可达性分析中，是根据 GC Roots 节点开始遍历整个对象数，如果把这个过程分为两步：

1. 遍历 GC Roots 节点。

2. 通过 GC Roots 节点遍历直接或间接关联的节点。

那么第 1 步肯定是很快的，因为相对来讲，整个堆内存中的 GC Roots 节点肯定只是极少数的对象，而第 2 步的执行时间和回收区域的大小成正比，相应的 Stop The World 的时间也会升高，为了降低 Stop The World 的时间，才有了 GC 线程和用户线程并发的标记方法。

但是问题在于，如何保证在 GC 线程标记期间，用户线程运行时修改对象图结构不会造成 GC 标记的错误，这里的错误有两种：一种是应该收集的对象标记为存活，这种情况问题不大，大不了下次 GC 再回收；另一种是应该存活的对象被标记成了要收集的对象，这种情况就会导致用户线程严重错误。

为了解决上述问题，又提出了“三色标记法”。

##### 三色标记法

* 白色

  表示对象未被垃圾收集器扫描过，在可达性分析开始时，所有对象都是白色，如果可达性分析结束后依然是白色，表示对象不可达。

* 灰色

  表示对象已经被垃圾收集器扫描过，但是该对象上至少还有一个引用没有被扫描过。

* 黑色

  表示这个对象及其引用都已经被扫描过了，它是安全存活的对象，如果有其他对象又指向了它，并不需要重新扫描，黑色对象不会直接指向白色对象。

如果在 GC 标记阶段直接 Stop The World，那么扫描完成后，每个对象的颜色要么白色要么黑色，不会有错。

但是如果 GC 线程和用户线程并发运行，就没这么简单了，这里主要解决的是“对象消失”的问题，即原本你应该是黑色的对象误标成了白色，要产生这种问题，只有同时满足下面两个条件才可以：

1. 赋值器插入了一条或多条从黑色对象到白色对象的新引用。
2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

也就是说，只需要打破其中任意一个条件，就能解决“对象消失”问题，针对这两种情况，给出了两种解决方案，分别是增量更新、原始快照。

##### 增量更新

针对第一种情况：

> 赋值器插入了一条或多条从黑色对象到白色对象的新引用。

解决方案是，当有黑色对象指向白色对象的新引用时，将这个新引用记录下来，并发扫描结束后，以这个黑色节点为根节点再进行一次扫描。

什么意思呢？其实可以理解为，当黑色对象有新引用指向白色对象时，其实它就变成了灰色对象，这也和灰色对象的定义符合。

##### 原始快照

针对第二种情况：

> 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

解决方案是，当删除了灰色对象指向白色对象的引用时，将这个引用记录下来，等并发标记结束后，再以这个灰色对象为根节点扫描一次。

什么意思呢？就是不管这个删除操作，以可达性分析开始时的对象图快照为准进行扫描。

以上两种解决方案都提到，需要在并发标记结束后以某个记录的节点为根节点再次扫描，这就说明，使用并发可达性分析的收集器，在并发标记之后，依然需要在 Stop The World 的情况下进行一次小范围的标记。

#### G1 收集器的并发可达性分析

CMS 收集器使用增量更新的算法来实现并发可达性分析，而 G1 收集器使用原始快照算法来实现。

并且，G1 收集器不仅实现了原始快照，还为每个 Region 块设计了两个名为 TAMS 的指针，在 GC 过程中用户线程产生的新对象都在 TAMS 指针之上，以 TAMS 为分界，上面的内存中的对象不会纳入垃圾收集的范围，而如果收集速度比不上产生新对象的速度时，G1 收集器也会暂停用户线程，执行 Full GC，也就导致了更长的 Stop The World 时间。

### 怎么建立可靠的停顿预测模型？

通过 `-XX:MaxGCPauseMillis` 参数可以指定 G1 收集器的停顿时间期望值。

为了达到这个期望值，G1 在运行期间会收集每个 Region 块的收集“价值”，比如回收耗时、记忆集的脏卡数量等，然后通过这些数据预测现在开始回收的话，那些 Region 组成回收集可以在不超过用户期望时间的同时达到最大收集收益。

## G1 收集器运行过程

### 初始标记

只标记 GC Roots 节点能直接关联的对象，这部分对象很少，虽然会 Stop The World，但是时间极短。同时还会修改 Region 中的 TAMS 的值，让下一阶段的标记运行同时，用户线程能正确分配对象。

### 并发标记

从 GC Roots 开始遍历整个堆的对象图，找出要回收的对象，这个时间很长，但是和用户线程并发执行，扫描结束后，还要处理原始快照算法记录下来的引用变动的对象。

### 最终标记

短暂的 Stop The World，处理并发标记结束后依然留下来的少量的原始快照算法记录的引用变动的对象。

### 筛选回收

统计更新 Region 的回收统计数据，分析得出要回收的 Region 集合，然后将这些 Region 中存活的对象复制到空的 Region 中，再将要回收的 Region 整个清理掉，整体来讲，采用的是标记-整理算法，但是局部来讲，因为跨 Region 的操作，又是标记-复制算法。

这个过程需要移动对象，所以需要 Stop The World，但是停顿时间在用户的期望范围内。

> 综上所述，尽管采用了并发标记的方式，但是 G1 收集器本身也是会 Stop The World 的，它的目的不是为了完全实现低延迟，而是为了实现延迟的可控。
>
> 虽然目标是延迟可控，但是如果这个期望的停顿时间设置得过分低了，那么为了达到这个期望值，每次 GC 都不会回收太多内存，久而久之，内存中的垃圾对象越来越多，直到内存不够用导致 Full GC，这只会带来更高的停顿时间，所以期望的停顿时间应该试场景合理配置，一般 100 ~ 300 ms 比较合理。

## 对比 CMS 收集器的优劣

### G1 的优点

* G1 得益于停顿预测模型和 Region 内存模型的红利，最大停顿时间有了可控性。

* G1 整体采用标记-整理算法，局部采用标记-复制算法，不会有内存碎片，而 CMS 采用标记-清除算法，容易有内存碎片，所以 G1 有利于长时间运行，分配大对象时不会因为找不到连续内存空间而触发 Full GC。

### G1 的缺点

* 用户线程运行过程中，为了支持 G1 收集器导致的内存占用比 CMS 更高，比如么个 Region 都维护自己的记忆集，可能会占用 20% 的堆内存空间甚至更高，而 CMS 只有一份记忆集，相应的内存占用就会小很多。
* G1 使用原始快照，CMS 使用增量更新，原始快照本身就比增量更新更耗费性能，况且 G1 的记忆集的结构比 CMS 的记忆集的结构又要复杂很多。

> 目前小内存应用上，CMS 的表现比 G1 更好，而大内存应用上 G1 的表现更好，这个优劣的平衡点在 6 ~ 8 GB 之间。
>
> -- 根据《深入理解 Java 虚拟机》原文删减。
