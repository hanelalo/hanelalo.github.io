---
title: 消息消费
date: 2020-10-06 23:25:56
tags: RocketMQ
categories: 消息中间件
cover: https://hanelalo.github.io/images/202111061344118.png
---

# 消息消费

在之前的章节中有讲到，获取消息的方式分为 pull 和 push 两种模式，而 RocketMQ 的 push 模式其实是通过 pull 模式来实现，后续的章节将会讲到这点，这里先以 push 模式为例学习消息消费的代码。



## DefaultMQPushConsumer 主要的属性

- defaultMQPushConsumerImpl push 模式消费者的默认实现，大部分消费逻辑都封装在了这个里面
- consumerGroup 消费者所属消费者组
- messageModel 消息消费模式，分为集群消费和广播消费，集群消费（CLUSTERING）模式下，订阅的每条消息在一个消费者组内只会有一个消费者消费，广播消费模式（BROADCASTING）下订阅的消息，消费者组内每个消费者都会消费，默认的消费模式是集群消费
- cosumeFromWhere 根据消息消费进度从 broker 拉取不到消息时重新计算消费起始位置的策略

- - CONSUME_FROM_LAST_OFFSET 从队列当前最大偏移量开始消费
  - CONSUME_FROM_FIRST_OFFSET 从队列最小偏移量开始消费
  - CONSUME_FROM_TIMESTAMP 从启动时间戳开始消费

默认是 CONSUME_FROM_LAST_OFFSET

- allocateMessageQueueStrategy 负载均衡策略
- subscription 订阅信息
- messageListener 消息业务监听器
- offsetStore 消息消费偏移量
- consumeThreadMin 最小消费者线程数
- consumeThreadMax 最大消费者线程数
- consumeConcurrentlyMaxSpan 并发消费最大跨度
- pullThresholdForQueue 流量控制阈值
- pullThresholdSizeForQueue 缓存消息大小阈值，达到这个值时进行流量控制



## 启动 DefaultMQPushConsumer

```Java
    public void start() throws MQClientException {
        setConsumerGroup(NamespaceUtil.wrapNamespace(this.getNamespace(), this.consumerGroup));
        this.defaultMQPushConsumerImpl.start();
        if (null != traceDispatcher) {
            try {
                traceDispatcher.start(this.getNamesrvAddr(), this.getAccessChannel());
            } catch (MQClientException e) {
                log.warn("trace dispatcher start failed ", e);
            }
        }
    }
```

DefaultMQPushConsumer 启动主要是启动 defaultMQPushConsumerImpl。



1. 构建订阅信息，从 DefaultMQPushConsumer 获取订阅信息，将订阅信息放进 rebalanceImpl；如果是集群模式，自动订阅重试队列 "%RETRY%+CONSUMER_GROUP"

```Java
    private void copySubscription() throws MQClientException {
        try {
            Map<String, String> sub = this.defaultMQPushConsumer.getSubscription();
            if (sub != null) {
                for (final Map.Entry<String, String> entry : sub.entrySet()) {
                    final String topic = entry.getKey();
                    final String subString = entry.getValue();
                    SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
                        topic, subString);
                    this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
                }
            }

            if (null == this.messageListenerInner) {
                this.messageListenerInner = this.defaultMQPushConsumer.getMessageListener();
            }

            switch (this.defaultMQPushConsumer.getMessageModel()) {
                case BROADCASTING:
                    break;
                case CLUSTERING:
                    // 集群模式自动订阅重试队列
                    final String retryTopic = MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup());
                    SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
                        retryTopic, SubscriptionData.SUB_ALL);
                    this.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);
                    break;
                default:
                    break;
            }
        } catch (Exception e) {
            throw new MQClientException("subscription exception", e);
        }
    }
```

1. 如果是集群消费模式，将实例名称改为进程 PID。

```Java
if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) {
    this.defaultMQPushConsumer.changeInstanceNameToPID();
}
```

1. 获取客户端实例

```
this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);
```

MQClientManager.getInstance() 使用单例模式，一个 JVM 中只会有一个 MQClientManager。

```Java
    public MQClientInstance getOrCreateMQClientInstance(final ClientConfig clientConfig, RPCHook rpcHook) {
        String clientId = clientConfig.buildMQClientId();
        MQClientInstance instance = this.factoryTable.get(clientId);
        if (null == instance) {
            instance =
                new MQClientInstance(clientConfig.cloneClientConfig(),
                    this.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);
            MQClientInstance prev = this.factoryTable.putIfAbsent(clientId, instance);
            if (prev != null) {
                instance = prev;
                log.warn("Returned Previous MQClientInstance for clientId:[{}]", clientId);
            } else {
                log.info("Created new MQClientInstance for clientId:[{}]", clientId);
            }
        }
        return instance;
    }
```

然后会根据 clientId 从 factoryTable 中获取一个实例。

```Java
    /**
     * 使用 ip 地址,和 client 名称作为客户端的 id, 在 Jvm 中是唯一的
     * @return String
     */
    public String buildMQClientId() {
        StringBuilder sb = new StringBuilder();
        sb.append(this.getClientIP());

        sb.append("@");
        sb.append(this.getInstanceName());
        if (!UtilAll.isBlank(this.unitName)) {
            sb.append("@");
            sb.append(this.unitName);
        }

        return sb.toString();
    }
```

从生成 clientId 的逻辑来看，在一个 JVM 上同时运行一个生产者和一个消费者，两者的 clientId 一致，也就是说，两者共用一个 MQClientInstance 实例。



1. 获取消费偏移量存储，如果是广播消费，偏移量存储在本地，如果是集群消费，消息偏移量存储在 broker 上面。

```Java
switch (this.defaultMQPushConsumer.getMessageModel()) {
    // 如果是广播消费, 消费偏移量存储在本地
    case BROADCASTING:
        this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());
        break;
    case CLUSTERING:
    // 如果是集群消费, 消费偏移量存储在 broker 上
        this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());
        break;
    default:
        break;
}
this.defaultMQPushConsumer.setOffsetStore(this.offsetStore);
```

1. 启动消息消费的服务

```Java
// 顺序消费
if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {
    this.consumeOrderly = true;
    this.consumeMessageService = new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());
} else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {
    // 并发消费
    this.consumeOrderly = false;
    this.consumeMessageService = new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());
}
this.consumeMessageService.start();
```

这里以并发消费为例，它的 start 方法只是启动了一个线程用来清除过期的消息，默认每 15 分钟执行一次。

```Java
    public void start() {
        this.cleanExpireMsgExecutors.scheduleAtFixedRate(new Runnable() {

            @Override
            public void run() {
                cleanExpireMsg();
            }

        }, this.defaultMQPushConsumer.getConsumeTimeout(), this.defaultMQPushConsumer.getConsumeTimeout(), TimeUnit.MINUTES);
    }
```

1. 注册消费者，如果当前已经有了对应消费者组的实例存在，就返回 false， 同时关闭新启动的消费消息的服务。

```Java
  public boolean registerConsumer(final String group, final MQConsumerInner consumer) {
    if (null == group || null == consumer) {
      return false;
    }

    MQConsumerInner prev = this.consumerTable.putIfAbsent(group, consumer);
    if (prev != null) {
      log.warn("the consumer group[" + group + "] exist already.");
      return false;
    }

    return true;
  }
boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);
if (!registerOK) {
    this.serviceState = ServiceState.CREATE_JUST;
    this.consumeMessageService.shutdown(defaultMQPushConsumer.getAwaitTerminationMillisWhenShutdown());
    throw new MQClientException("The consumer group[" + this.defaultMQPushConsumer.getConsumerGroup()
        + "] has been created before, specify another name please." + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),null);
}
```

1. 启动 MQClientInstance，前面已经讲过同一个 JVM 里面所有的消费者和生产者会共用一个 MQClientInstance，其实每个 MQClientInstance 只会启动一次。这里着重关注一下 pullMessageService 和 rebalanceService 也是在这里启动的，因为接下来会通过它学习如何从 broker 拉取消息。

```Java
      switch (this.serviceState) {
        case CREATE_JUST:
          this.serviceState = ServiceState.START_FAILED;
          // If not specified,looking address from name server
          if (null == this.clientConfig.getNamesrvAddr()) {
            this.mQClientAPIImpl.fetchNameServerAddr();
          }
          // Start request-response channel
          this.mQClientAPIImpl.start();
          // Start various schedule tasks
          this.startScheduledTask();
          // Start pull service
          this.pullMessageService.start();
          // Start rebalance service
          this.rebalanceService.start();
          // Start push service
          this.defaultMQProducer.getDefaultMQProducerImpl().start(false);
          log.info("the client factory [{}] start OK", this.clientId);
          this.serviceState = ServiceState.RUNNING;
          break;
        case START_FAILED:
          throw new MQClientException(
              "The Factory object[" + this.getClientId() + "] has been created before, and failed.",
              null);
        default:
          break;
      }
```

1. 更新缓存数据，发送心跳信息等

```Java
        this.updateTopicSubscribeInfoWhenSubscriptionChanged();
        this.mQClientFactory.checkClientInBroker();
        this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
        this.mQClientFactory.rebalanceImmediately();
```

## PullMessageService

PullMessageService 继承于 ServiceThread，所以它应该是一个服务线程，看看它的 run() 方法：

```Java
    @Override
    public void run() {
        log.info(this.getServiceName() + " service started");

        while (!this.isStopped()) {
            try {
                PullRequest pullRequest = this.pullRequestQueue.take();
                this.pullMessage(pullRequest);
            } catch (InterruptedException ignored) {
            } catch (Exception e) {
                log.error("Pull Message Service Run Method exception", e);
            }
        }

        log.info(this.getServiceName() + " service end");
    }
```

可以发现，拉取消息一直都是单线程拉取的，这里直接就是从 PullRequest 的队列中获取一个 request，然后再调用 pullMessage() 拉取消息。先看看 PullRequest 队列都是再什么时候入队的，至于 pullMessage() 后面再讲。



我们直接使用 ide 追踪一下 pullRequestQueue 的调用，发现是在 DefaultMQPushConsumerImpl 的executePullRequestImmediately 方法调用了 PullMessageService 的 executePullRequestImmediately 方法来 put 了一个 pullRequest 到队列里面。



然后实在 `RebalancePushImpl#dispatchRequest` 调用了 `DefaultMQPushConsumerImpl#executePullRequestImmediately` 方法， 最终发现是 `RebalanceService` 服务线程得 `run` 方法中调用 `MQClientInstance#doRebalance` 方法一路调用到了这里。



那么什么时候启动的 `RebalanceService` 呢？在上一节 **启动DefaultMQPushConsumer** 得最后，启动 MQClientInstance 时就已经着重提过要注意，启动 MQClientInstance 的时候就会启动 RebalanceService。



PullMessageService 只有在有 PullRequest 的时候才会执行拉取消息的逻辑，现在看看 PullRequest 里面究竟都有什么内容：

- consumerGroup 消费者组
- messageQueue 待拉取消息的消息队列
- processQueue 消息处理队列，从 broker 拉取的消息会先存入 ProcessQueue，再提交到消费者线程进行消费
- nextOffset 待拉取的 MessageQueue 的偏移量
- lockedFirst 是否被锁定



在上面贴出的代码片段里面，PullMessageService 最后是直接调用了 pullMessage 方，而这个人方法里面从 `mqClienFactory` 里面取出来的 MQConsumerInner 没直接强转为 DefaultMQPushConsumerImpl，也就是说，这个 pullMessage 方法是只服务于 Push 方式的实现，细想一下，要是是 pull 模式，似乎也确实不需要这样，要消费的时候自己手动调用就可以了。

```Java
    private void pullMessage(final PullRequest pullRequest) {
        final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());
        if (consumer != null) {
            DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;
            impl.pullMessage(pullRequest);
        } else {
            log.warn("No matched consumer for the PullRequest {}, drop it", pullRequest);
        }
    }
```



## ProcessQueue

在上一节讲到 PullRequest 时，在 PullRequest 中有存在 ProcessQueue 这样一个消息处理的队列，当消费者从 Broker 拉取到消息之后，将消息先放到 ProcessQueue 中等待消费，这样的话，我们可以将 ProcessQueue 理解为在消费者端重现的 ConsumeQueue。



首先看看 ProcessQueue 中比较重要的一些属性：

- msgTreeMap 消息存储器，key 是消息在 ConsumeQueue 中的偏移量，value 是消息实体。
- msgCount ProcessQueue 中的消息总数。
- consumingMsgOrderlyTreeMap 只在顺序消息消费时才有用，是 msgTreeMap 的子集。
- queueOffsetMax 当前 ProcessQueue 中的消息在消息队列中最大的偏移量。
- dropped 当前 ProcessQueue 是否已经被遗弃。
- lastPullTimestamp 最后一次拉取消息的时间戳。
- lastConsumeTimestamp 最后一次消费消息时间戳。



## 拉取消息

消息拉取的入口在 `DefaultMQPushConsumerImpl#pullMessage(final PullMessage pullMessage)` 方法中。



1. 首先从 PullRequest 中获取 ProcessQueue 并验证该 ProcessQueue 是否已经被遗弃，如果没被遗弃就更新最后一次拉取消息的时间戳，然后确认当前状态是否为运行中（RUNNING），最后如果消费者服务当前被挂起，就将本次拉取消息的任务放入线程池，延迟 1s 再执行，本次拉取流程到此结束。

```Java
        final ProcessQueue processQueue = pullRequest.getProcessQueue();
        if (processQueue.isDropped()) {
            log.info("the pull request[{}] is dropped.", pullRequest.toString());
            return;
        }
        // 设置最后一次拉取消息时间戳
        pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());

        try {
            // 确认服务状态是否为运行中
            this.makeSureStateOK();
        } catch (MQClientException e) {
            // 如果服务被挂起, 将拉取消息的任务放入放入线程池延迟 1s 后执行
            log.warn("pullMessage exception, consumer state not ok", e);
            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);
            return;
        }

        if (this.isPause()) {
            // 如果服务被挂起, 将拉取消息的任务放入放入线程池延迟 1s 后执行
            log.warn("consumer was paused, execute pull request later. instanceName={}, group={}", this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup());
            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);
            return;
        }
```



1. 流量控制，消费者端主要通过消息数量和本地缓存消息大小来进行流量控制。

- - 通过消息数量进行流量控制

先获取 ProcessQueue 中消息总条数，如果大于消费者配置的 pullThresholdForQueue（默认 1000）就延迟 50ms 再放入请求队列，每触发流量控制 1000 次，会记录一次流量监控日志。

```Java
long cachedMessageCount = processQueue.getMsgCount().get();
if (cachedMessageCount > this.defaultMQPushConsumer.getPullThresholdForQueue()) {
    this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);
    if ((queueFlowControlTimes++ % 1000) == 0) {
        log.warn(
            "the cached message count exceeds the threshold {}, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}",
            this.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);
    }
    return;
}
```

- - 通过缓存消息大小进行流量控制

先获取 ProcessQueue 中消息大小，默认是以字节为单位，这里转换为以 M 为单位，然后判断是否大于 pullThresholdSizeForQueue（默认 100M），如果超过这个阈值，就延迟 50ms 再将 PullRequest 放入请求队列，每触发流量控制 1000 次，会记录一次流量监控日志。

```Java
long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024);
if (cachedMessageSizeInMiB > this.defaultMQPushConsumer.getPullThresholdSizeForQueue()) {
    this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);
    if ((queueFlowControlTimes++ % 1000) == 0) {
        log.warn(
            "the cached message size exceeds the threshold {} MiB, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}",
            this.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);
    }
    return;
}
```



1. 如果不是顺序消息消费，判断 ProcessQueeu 中消息的最大最小偏移量跨度是否超过consumeConcurrentlyMaxSpan（默认 2000），如果超过，就进行流量控制，延迟 50ms 再将本次拉取任务放到队列中，每触发流量控制 1000 次，会记录一次流量监控日志。

```Java
        if (!this.consumeOrderly) {
            // 如果不是顺序消息, 消息队列中最大偏移量和最小偏移量只差大于并发消费最大偏移量跨度, 进行流量控制,
            // 本次消息拉取延迟 50s 执行, 并记录流量监控日志
            if (processQueue.getMaxSpan() > this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) {
                this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);
                if ((queueMaxSpanFlowControlTimes++ % 1000) == 0) {
                    log.warn(
                        "the queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, pullRequest={}, flowControlTimes={}",
                        processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),
                        pullRequest, queueMaxSpanFlowControlTimes);
                }
                return;
            }
        }
```



1. 获取消费者订阅信息，如果为空，延迟 1s 再将本次拉取任务放到队列中等待执行。

```Java
        final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());
        if (null == subscriptionData) {
            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);
            log.warn("find the consumer's subscription failed, {}", pullRequest);
            return;
        }
```



1. 构建请求的 sysFlag

PullSysFlag 主要有四种：

- FLAG_COMMIT_OFFSET 从内存中读取消费进度大于 0
- FLAG_SUSPEND 消息拉取支持挂起
- FLAG_SUBSCRIPTION 消息过滤机制为表达式
- FLAG_CLASS_FILTER 消息过滤机制为类过滤



1. 调用 `PullAPIWrapper#pullKernelImpl()` 发送请求

pullKernelImpl 参数列表：

- mq 拉取消息的目标消息队列
- subExpression 消息过滤表达式
- expressionType 消息表达式类型，分为 TAG 和 SQL92。
- offset 消息拉取偏移量
- maxNums 本次拉取消息最大条数，默认 32 条。
- sysFlag 拉取系统标记
- commitOffset 当前 ConsumeQueue 消费进度
- brokerSuspendMaxTimeMillis 消息拉取允许挂起最大时间，默认 15s。
- timeoutMillis 消息拉取超时时间。
- communicationMode 消息拉取模式，默认为异步拉取。
- pullCallback 从 broker 拉取消息后的回调方法。



1. 根据 brokerName、brokerId 获取 Broker 地址信息。如果获取到的结果为空，就通过 topic 从 NameServer 更新缓存中的 Broker 信息，然后再重新获取 Broker 地址信息。

```Java
        FindBrokerResult findBrokerResult =
            this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),
                this.recalculatePullFromWhichNode(mq), false);
        if (null == findBrokerResult) {
            this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());
            findBrokerResult =
                this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),
                    this.recalculatePullFromWhichNode(mq), false);
        }
```



1. 如果消息过滤类型为类过滤，就需要从 FilterServer 上拉取消息。然后发送请求，拉取消息。

```Java
String brokerAddr = findBrokerResult.getBrokerAddr();
// 如果为类过滤, 就获取 FilterServer 地址, 从 FilterServer 拉取消息
if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) {
    brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);
}
```

## Broker 处理拉取消息的请求

先找找 Broker 处理拉取消息请求的 Service。拉取消息的请求代码是 `RequestCode.PULL_MESSAGE`，这在发送拉取消息的具体实现代码 `MQClientAPIImpl#pullMessage` 中能找到。Broker 针对携带这个请求代码的请求处理线程，也是在 BrokerController 初始化的时候就在 `BrokerController#registerProcessor` 方法中已经注册了。

```Java
        /**
         * PullMessageProcessor
         */
        this.remotingServer.registerProcessor(RequestCode.PULL_MESSAGE, this.pullMessageProcessor, this.pullMessageExecutor);
        this.pullMessageProcessor.registerConsumeMessageHook(consumeMessageHookList);
```

在 Broker 端处理拉取消息请求的核心，在于构建消息过滤器和从 MessageStore 中查询消息，消息过滤器的构建后面再讲，这里主要关注在 MessageStore 中查询消息的逻辑。

```Java
final GetMessageResult getMessageResult = this.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),
    requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), messageFilter);
```

getMessage 方法的入参如下：

- group 消费者组
- topic 主题
- queueId 队列ID
- offset 拉取消息初始偏移量
- maxMsgNums 拉取消息最大条数
- messageFilter 消息过滤器



1. 首先根据 topic 和 queueId 找到目标消费队列

```
GetMessageResult getResult = new GetMessageResult();
final long maxOffsetPy = this.commitLog.getMaxOffset();
ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);
```

1. 校验 offset 参数，是否在查询出来的消费队列中，如果不在，就获取下次拉取消息时正确的偏移量。

```Java
      minOffset = consumeQueue.getMinOffsetInQueue();
      maxOffset = consumeQueue.getMaxOffsetInQueue();

      if (maxOffset == 0) {
        status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;
        nextBeginOffset = nextOffsetCorrection(offset, 0);
      } else if (offset < minOffset) {
        status = GetMessageStatus.OFFSET_TOO_SMALL;
        nextBeginOffset = nextOffsetCorrection(offset, minOffset);
      } else if (offset == maxOffset) {
        status = GetMessageStatus.OFFSET_OVERFLOW_ONE;
        nextBeginOffset = nextOffsetCorrection(offset, offset);
      } else if (offset > maxOffset) {
        status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;
        if (0 == minOffset) {
          nextBeginOffset = nextOffsetCorrection(offset, minOffset);
        } else {
          nextBeginOffset = nextOffsetCorrection(offset, maxOffset);
        }
      }
```

- maxOffset = 0，说明当前消费队列没有消息，消息拉取结果为 NO_MESSAGE_IN_QUEUE，如果当前 broker 节点是 master 节点或者节点的 offsetCheckInSlave 属性为 true，下次拉取消息的偏移量为 0，其他情况下次拉取消息偏移量还是原始偏移量。
- offset < minOffset，拉取消息的偏移量比消费队列的最小偏移量小，拉取结果为 OFFSET_TOO_SMALL，如果当前 broker 节点是 master 节点或者节点的 offsetCheckInSlave 属性为 true，下次拉取消息的偏移量为 minOffset，其他情况下次拉取消息偏移量还是原始偏移量。
- offset = maxOffset，拉取偏移量等于最大偏移量，拉取结果为 OFFSET_OVERFLOW_ONE，下次拉取消息偏移量为原始偏移量。
- offset > maxOffset，拉取消息偏移量大于消费队列最大偏移量，拉取结果为 OFFSET_OVERFLOW_BADLY，如果最小偏移量为 0，当前 broker 节点是 master 节点或者节点的 offsetCheckInSlave 属性为 true，下次拉取消息偏移量为 minOffset，如果 minOffset 不为 0，且当前 broker 节点是 master 节点或者节点的 offsetCheckInSlave 属性为 true，则下次拉取消息偏移量为 maxOffset，其他情况，下次拉取消息初始偏移量为原始偏移量。



1. 如果拉取消息的偏移量落在 minOffset 和 maxOffset 之间（minOffset < offset < maxOffset），尝试通过 ConsumeQueue 从 CommitLog 中拉取 32（默认） 条消息，这段逻辑在之前消息存储的时候已经讲过。最后返回 GetMessageResult。
2. 在拿到 GetMessageResult 之后，根据下次拉取的偏移量是否被当前 broker 包含，设置下次拉取消息的 brokerId，如果下次拉取消息的偏移量不在当前 broker 所存储的消息内，就设置 brokerId 为 master 的 id，然后判断当前 broker 是否为从节点，如果是 broker 的配置为从节点不可读（slaveReadEnable = false），则设置 brokerId 为 master 的 brokerId。
3. 如果是 master 节点，更新消息消费进度信息。



服务端处理拉取消息的返回代码主要有 SUCCESS、PULL_NOT_FOUND、PULL_RETRY_IMMEDIATELY、PULL_OFFSET_MOVED。



## 消费者处理拉取到的消息

在前面讲到消费端发送拉取消息的请求的时候，有提到 `PullAPIWrapper#pullKernelImpl` 的参数中有传入 pullCallback 回调，而拉渠道消息之后的处理就在这里了。



这里重点关注一下成功拉取到消息的处理。



1. 重新设置 PullRequest 的 nextOffset。

```Java
pullRequest.setNextOffset(pullResult.getNextBeginOffset());
```

1. 如果拉取到的消息列表为空，就立刻将 pullRequest 放到 pullRequestQueue 中立即再次拉取消息，这里之所以拉取成功还会出现消息列表为，是因为早 broker 过滤消息只是根绝 Tag 的 hashCode 过滤，到了消费者端还过滤了一次，就可能出现两次过滤结果不同了。

```Java
if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) {
    DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);
}
```

1. 如果拉取道德消息不为空，将消息放入 processQueue 中，通知消费线程消费。