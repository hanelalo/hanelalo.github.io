---
title: 快速排序和计数排序
date: 2020-11-08 16:52:15
tags: 排序算法
categories: 算法
cover: https://hanelalo.github.io/images/202111061338231.png
---

# 快速排序

快速排序主要是用的是分治思想，从待排序的数组中选取一个数 target 作为参考，比 target 大的放右边，比 target 小的放左边，然后在左右两边的分区再重复做前面的事，最终使得数组变得有序。

```java
/**
 * 快速排序
 */
public class QuickSort {

  public static void main(String[] args) {
    int[] arr = {3, 5, 2, 6, 8, 1, 4, 9, 7};
    quickSort(arr, 0, arr.length - 1);
    System.out.println(Arrays.toString(arr));
  }

  private static void quickSort(int[] arr, int p, int r) {
    if (p >= r) {
      return;
    }
    int q = partition(arr, p, r);
    quickSort(arr, 0, q - 1);
    quickSort(arr, q + 1, r);
  }

  private static int partition(int[] arr, int p, int r) {
    // 默认以分区的最后一个元素为参考，对分区左右拆分。
    int middle = arr[r];
    int i = p;
    for (int j = p; j < r; j++) {
      if (arr[j] < middle) {
        if (i == j) {
          ++i;
        } else {
          int tmp = arr[i];
          arr[i++] = arr[j];
          arr[j] = tmp;
        }
      }
    }
    arr[r] = arr[i];
    arr[i] = middle;
    return i;
  }
}

```

这里默认直接以当前分区的最后一个元素为参考进行分区划分。极端情况下这样可能会导致快速排序变成冒泡排序。

# 计数排序

计数排序适合用来处理数据范围在确定区间内的情况。比如成绩排名，一个市 50 万考生，要对这 50 万名考生的成绩做排名，如果总分是 750 分，那么可以将这 50 万份成绩放到一个大小为 751 的数组里面，数组每个元素记录当前下标分数的人数，比如数组下标为 450 的值为 100，那就说明 450 分的人数为 100 人。

那此时某个 450 分的考生要查询自己的排名，就只需要将数组中从 0 到 450 的值加起来就可以了。

那么如果是要排序呢？比如要对`{2, 5, 3, 0, 2, 3, 0, 3}` 这样一个数组使用计数排序。

可以直到最小值是 0，最大值是 5，那么可以将每个值出现的次数放进一个长度为 6 的**计数数组**中：

```
数组: {2 0 2 3 0 1}
下标:  0 1 2 3 4 5
```

那么接下来要如何排序呢？

举个例子，排序的最终结果，3 应该在哪里？

```
0 0 2 2 3 3 3 5
```

3 在下标为 4 5 6 的这三个位置，那么其实是不是找到最后一个 3 的位置，在直到有几个 3 的情况下，剩下的 3 也能找到正确的位置。

那么如何找最后一个 3 的位置，其实直接将计数数组中下标 0 到 3 的值加起来，就是最后一个 3 的位置，把 3 换成其他数字，也可以这样计算，那么现在计数数组就变成了：

```
数组: {2 2 4 7 7 8}
下标:  0 1 2 3 4 5
```

那么第一个最后一个 3 应该在下标为 7 的位置。

代码实现：

```java
/**
 * 计数排序
 */
public class CountingSort {

  public static void main(String[] args) {
    int[] arr = {2, 5, 3, 0, 2, 3, 0, 3};
    countingSort(arr);
  }

  private static void countingSort(int[] arr) {
    if(arr.length <= 1){
      return;
    }
    // 获取最大值
    int max = getMax(arr);
    // 初始化计数器数组
    int[] counter = initCounter(max);
    count(arr, counter);
    System.out.println(Arrays.toString(sort(arr, counter)));
  }

  private static int[] sort(int[] arr, int[] counter) {
    int[] result = new int[arr.length];
    /**
     * 这里如果从索引为 0 的元素开始遍历，会导致该排序算法变成不稳定的算法。
     */
    for (int i = arr.length-1; i >= 0; i--) {
      int j = arr[i];
      result[counter[j] - 1] = j;
      counter[j]--;
    }
    return result;
  }

  private static void count(int[] arr, int[] counter) {
    for (int i : arr) {
      counter[i]++;
    }
    for (int i = 1; i < counter.length; i++) {
      counter[i] += counter[i - 1];
    }
  }

  private static int[] initCounter(int max) {
    int[] result = new int[max + 1];
    for (int i = 0; i < max; i++) {
      result[i] = 0;
    }
    return result;
  }

  private static int getMax(int[] arr) {
    int max = arr[0];
    for (int j : arr) {
      if (j > max) {
        max = j;
      }
    }
    return max;
  }
}
```

