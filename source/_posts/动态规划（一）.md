---
title: 动态规划（一）
date: 2021-01-18 23:32:04
tags: 动态规划
categories: 算法
cover: https://hanelalo.github.io/images/202111061038677.jpg
---

# 动态规划（一）

动态规划问题，一般都有两种解法，一种是递归解法，一种是 dp 表解法，不管是哪一种解法，都需要找到问题的状态转移公式。

解动态规划，首先需要找到问题的 **base case**，也就是最基本的问题的解，比如下面的斐波那契数列的 base case 就是当 n = 1或者2时，返回的就是 1。有了 base case，接下来就需要**做选择**，当做出一个选择时，比如下面的凑零钱问题，每次都会选择一种面额的纸币。最后就是找到**状态转移方程**，状态会在做选择时发生改变，依然时凑零钱问题，要凑的面额 m 就是状态，每做出一次选择，m 都会改变。

## 斐波那契数列问题

斐波那契数列数列满足 f(n)=f(n-1)+f(n-2)，比如: [1,1,2,3,5,8,13....]，现在需要计算出数列中第 n 个元素的值。

首先，问题的 base case 是，当 n = 1,2 时，f(n) = 1。

选择，这个问题比较简单，没什么选择，单纯的暴力递归就行了。

状态转移方程，f(1)=f(2)=1; f(n) = f(n-1)+f(n-2), n>2。

所以，暴力递归就可以这样写：

```java
public int solution(int n){
    if(n == 0){
        return 0;
    }
    if(n==1 || n == 2){
        return 1;
    }
    return solution(n-1) + solution(n-2);
}
```

但是，再仔细想想，这个递归里面起始做了很多的重复计算，当 n 越大，重复计算也就越多，像这种的重复计算，可以利用缓存的思想，遇见已经计算过的，就返回以前的结果，这种叫做备忘录。

```java
private Map<Integer, Integer> map = new HashMap<>();
public int solution(int n){
	if(map.containsKey(n)){
        return map.get(n);
    }
    if(n == 0){
        return 0;
    }
    if(n==1 || n == 2){
        return 1;
    }
    int result = solution(n-1) + solution(n-2);
    map.put(n, result);
    return result;
}
```

除了备忘录，还有一种基于普通数组的实现，也就是 dp 表：

```java
public int solution(int n){
    if(n == 0){
        return 0;
    }
    if(n == 1 || n == 2){
        return 1;
    }
    int[] dp = new int[n + 1];
    dp[1] = dp[2] = 1;
    for(int i = 3;i <= n; i++){
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
```

最后，会发现 f(n) 只跟 f(n-1) 和 f(n-2) 有关系，所以这里起始也没必要定义一个数组了。

```java
public int solution(int n){
        if(n == 0){
        return 0;
    }
    if(n == 1 || n == 2){
        return 1;
    }
    int result;
    int p = 1;
    int pp = 1;
	for(int i = 3;i <= n;i++){
        result = p + pp;
        pp = p;
        p = result;
    }
    return result;
}
```

## 凑零钱问题

举个例子，给定[1,5,10]三种面额的零钱，每种面额不限量，要凑足 20 元，最少的纸币数量时多少？那肯定是两张 10 元直接解决问题。

这同样是一个动态规划问题，不过比斐波那契数列要复杂。

首先，base case 就是当要凑 0 元时，纸币数为 0，凑 1 元时，纸币数为 1。

选择，纸币不限量，每次选择一张，都有[1,5,10]三种选择。

状态转移方程，f(n) = min(f(n-x))+1，x 属于 [1,5,10]。

所以按照递归的写法如下：	

```java
public int coinsAmount(int[] coins, int amount){
    if(amount = 0) {
        return 0;
    }
    if(amount == -1) {
        return -1;
    }
    int result = Integer.MAX_VALUE;
    for(int coin : coins) {
        int subResult = coinsAmount(coins, amount - coin);
        if(subResult == -1) {
            continue;
        }
        result = Math.min(result, subResult + 1);
    }
    return result;
}
```

同样，这里面还有很多重叠子问题存在，所以也可按照解决斐波那契数列一样，建立一个备忘录：

```java
private Map<Integer, Integer> map = new HashMap<>();
public int coinsAmount(int[] coins, int amount){
    if(map.containsKey(amount)){
        return map.get(amount);
    }
    if(amount = 0) {
        return 0;
    }
    if(amount == -1) {
        return -1;
    }
    int result = Integer.MAX_VALUE;
    for(int coin : coins) {
        int subResult = coinsAmount(coins, amount - coin);
        if(subResult == -1) {
            continue;
        }
        result = Math.min(result, subResult + 1);
    }
    map.put(amount, result);
    return result;
}
```

同样，观察状态转移方程会发现，f(n) 也只跟 f(n-x) 有关系，所以也可以尝试一下状态压缩：

```java
public int coinsAmount(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount+1);
    dp[0] = 0;
    if(amount == 0){
        return dp[0];
    }
    if(amount < 0){
        return -1;
    }
    for(int i = 0;i< dp.length;i++){
        for(int coin : coins){
            if(i - coin < 0){
                continue;
            }
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
        }
    }
    return dp[amount];
}
```

## 最长公共子串

题目：给定两个字符串，找出最长的公共子串，比如 "abcdfdfde" 和 "acdsfdse" 的最长公共子串为 "acdfde"，所以输出为 6。

首先，确定 dp 表，这种两个字符串的问题，一般 dp 表都是一个二维数组，别问为什么，记住就行，反正就认为是前人总结的经验就行，假设两个字符串 a,b，那么这个 dp 表就是 `int[][] dp = new int[a.length+1][b.length+1];`

然后，确定 base case，base case 起始就是那种不需要计算的常识性问题，这里就是 `dp[0...][0] = dp[0][0...]=dp[0][0]=0`。

紧接着，找到状态转移方程。

这里会有 2 种情况：

* `a[i] = b[j]，dp[i][j] = dp[i-1][j-1] + 1`
* `a[i] != b[j],dp[i][j] = max(dp[i-1][j], dp[i][j-1])`

到这里，思路也就清晰了：

```java
public int solution(String[] str1, String[] str2){
    // 定义 dp 数组
    int[][] dp = new int[str1.length+1][str2.length+1];
    for(int i = 0;i <= str1.length; i++) {
        for(int j = 0; j <= str2.length; j++) {
            // `a[i] = b[j]，dp[i][j] = dp[i-1][j-1] + 1`
            if(str1[i].equals(str2[j])){
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                // `a[i] != b[j],dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
                dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
            }
        }
    }
    return dp[str1.length][str2.length];
}
```