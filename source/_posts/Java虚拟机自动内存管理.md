---
title: Java虚拟机自动内存管理
date: 2022-01-18 22:19:02
tags: 
    - JVM
    - 读书笔记
    - 深入理解Java虚拟机
categories: Java虚拟机
cover: http://image.hanelalo.cn/images/202201182236555.jpg
---

> 本文是 《深入理解 Java 虚拟机》第 3 版的读书笔记。

## JVM 内存模型

### 程序计数器

- 可理解为当前线程所执行的字节码行号指示器。

- 从 JVM 的概念模型上看，是通过改变程序计数器选取下一条要执行的指令。

- JVM 的多线程是通过线程轮流切换、分批处理器时间的方式来实现，所以需要每个线程都维护一个自己的程序计数器，方便线程切换后能恢复到正常的执行位置，因此，程序计数器是线程私有的，各线程的程序计数器单独存储，互不影响。

- 如果当前在执行一个 Java 方法，程序计数器记录的是当前正在执行的虚拟机字节码指令的地址。

- 如果当前在执行的是 native 本地方法，则程序计数器为空。

- 程序计数器是 JVM 运行时唯一没有规定任何 OutOfMemoryError 错误的内存区域中。

### 虚拟机栈

- 描述 Java 方法执行时的线程内存模型：每个方法执行时，会创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息。

- 每一个方法执行到执行完毕，都是一个栈帧从入栈到出栈的过程。

- 局部变量表存放的是编译期可知的 Java 基本数据类型、对象引用、returnAddress 类型，这些类型在局部变量表中存储空间以以变量槽的方式表示，局部变量表的大小在编译时就已经进行了分配，方法运行时，栈帧中要分配多大的局部变量表是确定了的，方法运行期间不会改变局部变量表的大小，这里的大小值得是槽的数量，至于每个槽占用的内存大小，不同虚拟机有不同的实现。

  - Java 基本数据类型。boolean、byte、char、short、int、float、long、double，其中 long、double 两种数据类型占用两个变量槽，，其余数据类型占用一个变量槽。

  - 对象引用。reference 类型，它不是对象本身，而是一个指向对象初始地址的引用指针，或者代表对象的句柄。

  - returnAddress 类型。方法的返回值地址，指向一条字节码指令地址。

  - 虚拟机栈也是线程私有的内存区域。

  - 栈深度超出虚拟机允许的最大深度时，会抛出 StackOverflowError 错误。

  - 现在的虚拟机栈基本不支持扩展内存大小，所以当申请虚拟机栈的内存失败时，会抛出 OutOfMemoryError 错误。

### 本地方法栈

- 和虚拟机栈类似，虚拟机栈服务与 Java 方法，本地方法栈服务于虚拟机调用的 native 本地方法。

- 和虚拟机栈一样，本地方法栈也会抛出 StackOverflowError 和 OutOfMemoryError 错误。

### Java 堆

- 所有对象实例和数组都在堆上分配内存。

- 主流 Java 虚拟机的堆都是以可扩展的方式实现，通过 -Xmx 和 -Xms 来配置。

- 如果堆中内存不足以完成新实例的分配，且无法再扩展时，会抛出 OutOfMemoryError。

- 堆内存在逻辑上是连续内存，在物理上可以是不连续的内存。

### 方法区

- 线程共享的内存区域。

- 存储类型信息、常量、静态变量、即时编译后的代码缓存。

- 和堆一样，不强制要求必须是连续的物理内存。

- 可扩展，甚至可以不实现垃圾回收。

- 无法满足新的内存需求时，会抛出 OutOfMemoryError。

### 运行时常量池

- 方法区的一部分。

- 用于存放类加载后的生成的各种字面量和符号引用。

- 无法在申请到内存时，抛出 OutOfMemoryError。

### 直接内存

- 并不在虚拟机运行时的内存区域中。

- JDK 1.4 之后引入了 NIO，可以通过 native 方法直接分配堆外的内存，通过 DirectByteBuffer 引用这块内存。

- 这样避免了在 Java 堆和 Native 堆之间来回复制数据，提高了性能。

- 堆外内存主要收操作系统的内存限制，当内存不足时，依然会抛出 OutOfMemoryError。

## 对象创建

- 类加载

- 连接

  - 验证

  - 准备

  - 解析

- 初始化

> 应该会有单独的笔记。

## 对象内存布局

### 对象头

- Mark Word

  存储对象运行时数据：哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳。

- 类型指针

  对象指向它的类型元数据指针。

### 实例数据

- 对象真正存储的有效信息，即代码中定义的各种类型字段的内容。

### 对齐填充

- 非必要部分。

- HotSpot 虚拟机自动内存管理要求对象起始地址大小必须是 8 的倍数，对象头设计成了 8 的倍数，但是实例数据部分，可能并不是 8 的倍数，为了对齐成 8 的倍数，会通过对齐填充来补全。

## 对象访问定位

创建对象后，通过栈上的 reference 数据来操作堆上的具体的对象，reference 类型是一个引用类型，主要实现方式有两种。

- 通过句柄访问。

  - 需要在堆中划分一块内存来作为句柄池。reference 中存的是句柄池中的句柄地址，句柄中存的是堆中的对象实例数据和方法区中的类型数据的地址信息。

  - 好处在于如果对象实例地址变更（比如垃圾回收算法移动了对象实例），只需要变更句柄中的数据，而不用变更 reference 数据。

- 通过直接指针访问。

  - reference 中存的就是堆中的对象实例的地址，对象实例数据中有指向方法区中的类型数据的指针。

  - 好处在于速度快，因为是直接引用了对象实例地址。

HotSpot 虚拟机主要使用的是通过直接指针访问。

## 垃圾收集

### 判断对象是否存活？

- 引用计数算法

  - 对象中添加一个引用计数器，有一个地方引用它，计数器加一，引用失效后，计数器减一。

  - 无法解决对象 A、B 相互引用无法回收的情况。

- 可达性分析
  - 通过一些列 GC Roots 对象作为起始节点集，根据这些节点的引用关系开始搜索，如果某个对象跟任何一个 GC Roots 节点都没有任何引用链，认为该对象不可达

### 对象引用

- 强引用

  日常代码中的类似 Object obj = new Object() 的引用关系，只要这种关系还在，垃圾收集器就不会回收被引用的对象。

- 软引用

  描述有用但不是必要的对象，使用 SofeReference 类实现。只被软引用关联的对象，在内存即将溢出时会被回收，如果回收的软引用的对象之后内存还是不够，才会抛出内存溢出的异常。

- 弱引用

  也是有用但非必要的对象，使用 WeakReference 实现，但是比软引用的强度低，弱引用的对象只能生存到下一次垃圾回收。

- 虚引用

  最弱的引用关系，使用 PhantomReference 实现，设置虚引用的对象没实际的意义，只是为了能在它被回收时收到一个系统通知。

### 对象的自救

- 当一个对象被判断为不可达之后，如果该类没实现 finalize() 方法，或者 finalize() 方法是否已经被虚拟机调用过了，如果是，那么对象将被回收，无法自救。

- 如果对象实现了 finalize() 方法且还未被虚拟机调用，那么该对象将进入 F-Queue ，会有另一个线程去执行它的 finalize() 方法，这是被判定为不可达之后唯一的“自救”机会，只要重新与引用链上任何一个对象建立关联即可。为了防止 finalize() 方法有问题，比如死循环导致阻塞以至于整个队列其他元素阻塞，虚拟机将不会等待 finalize() 方法执行完毕。

### 分代收集理论

#### 分代假说

1. 弱分代假说：绝大多数对象都是朝生夕死。

2. 强分代假说：熬过垃圾收集次数越多的对象，越不容易消亡。

3.  跨代引用假说：跨代引用相对于同代引用，仅占极少数。

对于假说 1、2，有些对象朝生夕死，有些对象熬过的垃圾收集次数越多，越不容易消亡。对于朝生夕死的对象，放到一起，每次垃圾收集时只关心那些少量的要存活的对象，如果剩余的都是些难以消亡的对象，将他们放在一起，这个区域的垃圾收集频率适当降低，这样垃圾收集的时间效率和内存的有效利用即可兼顾；这样就将对象分成了新生代和老年代；相应的有了 Minor GC、Major GC、Full GC 三种回收类型；针对不同分代区域的对象特征，又发展出了标记-复制算法、标记-清除算法、标记-整理算法。

对于假说 3，是指新生代的对象和老年代的对象有引用关系，导致进行 Minor GC 时，因为这个跨代引用还需要扫描老年代的 GC Roots，耗费性能。其实这个问题，长远来看，因为跨代引用，新生代中的对象也会随着时间推移进入老年代，那么跨代引用其实真就像假说 3 一样只是少数，所以没必要扫描所有的老年代的 GC Roots，只需要将老年代划分为多块，新生代只需要标记哪一块有跨代引用，发生 Minor GC 时，对于跨代引用的处理只需要扫描一小块的老年代对象。

#### 垃圾收集类型

- Minor GC / Young GC

  目标是新生代的垃圾收集。

- Major GC / Old GC

  老年代垃圾收集行为。目前只有 CMS 收集器有单独的老年代收集行为。

- Mixed GC

  目标是新生代和部分老年代的收集行为。目前只有 G1 收集器有这种收集行为。

- Full GC

  收集整个 Java 堆和方法区。

### 垃圾收集算法

#### 标记-清除算法

- 执行步骤

  首先标记处所有需要清除的对象，标记完成后，统一回收标记的对象。

- 缺点

  1. 执行效率不稳定。Java 堆中大部分对象都是需要被回收的，有大量的对象需要标记和回收，导致随着 Java 堆中的对象数量上涨，垃圾回收的效率也降低。

  2. 内存空间碎片化。标记-清除后，会产生大量不连续的内存碎片，导致如果需要申请大对象时，如果没有连续的大内存空间，会触发下一次垃圾回收动作。

#### 标记-复制算法

- 执行步骤

  将内存分为两块，每次只使用其中一块，这一块内存用完之后，将存活的对象复制到另一块内存上面，然后将已使用的那一块内存空间直接清除掉。

- 优点

  实现简单，运行高效。如果内存中多数对象都会存活，那么对象复制的开销比较大，但是对于多数对象都可回收的情况，算法复制的对象就只是少数了，而且每次回收都只是部分内存。

- 缺点

  可用的内存缩小为实际内存的一半。

> Appel 式回收：

- Appel 式回收，是标记-复制算法的一个改良版本。

- 标记-复制算法浪费了一半内存，Appel 式回收将内存划分为一块大的 Eden 区和两块小的 Survivor 区，每次使用 Eden 区和一块小的 Survivor 区，每次回收时，将存活的对象复制到另一个小的 Survivor 区上。

- HotSpot 虚拟机的 Serial、ParNew 等新生代收集器就是使用这种算法设计新生代的内存布局，默认的 Eden 和 Survivor 内存占比为 8:1，也就是只会浪费 10% 的内存。

- 如果 GC 的时候一个小的 Survivor 区内存不足以装下所有存活的对象，就需要依赖其他内存区域进行分配担保，一半是将无法装下的对象分配进入老年代。

#### 标记-整理算法

* 执行步骤

  1. 先标记要回收的对象；

  2. 然后将存活的对象移动到内存的一端；

  3. 最后清理掉边界以外的内存空间；

> 和标记-清除算法的主要区别在于，是否移动对象？

1. 如果移动，在 GC 时移动对象会影响用户线程，因为这会导致 Stop The World，这会为用户线程带来更高的延迟。

2. 如果不移动，就会出现内存碎片，此时也可以通过更复杂的内存分配器（比如空闲列表）来解决问题，虽然也有 Stop The World，但通常时间很短，所以对用户线程造成的延迟较小。

3. 标记-整理算法对程序吞吐量更加友好，标记-清除算法对延迟敏感的应用更加友好。CMS 收集器主要使用标记-清除算法实现，但是当遇见内存碎片比较严重的情况时，又改用标记-整理算法来进行 GC。

### 垃圾收集器

#### Serial 收集器

- Serial 收集器是新生代收集器，采用标记-复制算法，单线程执行，所以会停掉所有的用户线程。

- 它是所有收集器中，额外占用内存最小的。

- 适用于用户桌面环境和一些微服务环境的应用，因为它们占用的内存一般不大，几十到几百兆，Serial 的 Stop The World 可以控制在十几毫秒或者几十毫秒，只要不频繁发生 GC，就不会有什么影响。

#### ParNew

- 新生代垃圾收集器，Serial 的多线程版本，Serial 的 GC 线程是单线程运行标记-复制算法，而  ParNew 采用多个 GC 线程并行执行而已，依然会有 Stop The World。

- 是除了 Serial 之外，唯一能和 CMS 收集器搭配的新生代收集器，JDK 9 开始，也只有 ParNew 能和 CMS 收集器搭配了。

- 在单核环境下，因为有线程切换的开销，所以性能其实比不上 Serial 收集器。

- 多处理器核心环境下，可以通过 -XX:ParallelGCThreads 参数来限制 GC 线程数。

#### Parallel Scavenge 收集器

- 新生代收集器。

- 使用标记-复制算法，多个 GC 线程并行执行。

- 和 ParNew 的区别在于，ParNew 更关注 Stop The World 的时间，Parallel Scavenge 更关注应用的吞吐量。
  吞吐量 = 运行用户代码时间 / (用户代码运行时间 + 运行垃圾收集时间)

- 适用于后胎运行而不需要太多交互的任务。

- Parallel Scavenge 收集器还提供了 -XX:+UseAdaptiveSizePolicy 配置是否启用自适应调节策略，如果开启该功能，就不用设置新生代大小 -Xmn 、Eden 和 Survivor 区的比例 -XX:SurvivorRatio、晋升老年代的对象大小 -XX:PretenureSizeThreshold 等参数，Parallel Scavenge 收集器会根据虚拟机当前的运行状况调节这些参数。

- 通过 -XX:MaxGCPauseMillis 设置最大停顿时间，是一个大于 0 的毫秒数，GC 线程会尽量在配置的时间内完成收集任务。
  并不是这个值设置得越小，垃圾收集就越快这么简单，垃圾收集越快，会导致触发触发 GC 的频率上升，相应的吞吐量肯定也会逐渐下降。

- 通过 -XX:GCTimeRatio 设置吞吐量大小，该配置为一个整数，如果设置为 N，表示 GC 时间不超过程序运行时间的 1 / (1 + N)，该配置默认为 99，即 GC 时间不超过运行时间的 1%。

- 和 Parallel Scavenge 收集搭配的老年代收集器是 PS MarkSweep 收集器，这个收集器和 Serial Old 收集器一样的实现原理。

#### Serial Old 收集器

- Serila 的老年代收集器版本，采用标记-整理算法，单线程运行。

- 多是客户端模式下 HotSpot 虚拟机采用的老年代收集器。

- 如果在服务端使用该收集器，要么是在 JDK 5 及之前的版本搭配 Parallel Scavenge 收集使用，要么就是作为 CMS 收集器失败时的备选方案。

#### Parallel Old 收集器

- Parallel Scavenge 收集器的老年代版本，多 GC 线程并行执行，使用标记-整理算法。

- 和 Parallel Scavenge 收集器组合，适用于比较注重吞吐量或者处理器资源比较稀缺的场景。

- 在这个收集器出现之前，Parallel Scavenge 收集器的老年代搭配只有 Serial Old（其实是 PS MarkSweep） 收集器，但是因为 Parallel Scavenge 收集器注重吞吐量，而 Serial Old 收集器是单线程的，不能更好利用处理器资源，所以 Paralle Scavenge 收集器用的不多。

#### CMS 收集器

- Concurrent Mark Sweep，老年代收集器，采用标记-清除算法，以获取最短收集停顿时间为目标的收集器，它的收集过程分为 4 步。

  - 初始标记
    初始标记只是标记 GC Roots 直接关联上的对象，这个过程因为不会深度遍历，所以比较快。

  - 并发标记
    并发标记是多个 GC 线程通过前一步标记的 GC Roots 直接关联的对象遍历对象图，这个过程虽然耗时比较长，但是不需要 Stop The World。

  - 重新标记
    重新标记是修正并发标记期间产生的用户线程运行导致的标记变动，这个过程比初始标记的过程长，但是远远比不上并发标记，该过程需要 Stop The World。

  - 并发清除
    并发清除是多个 GC 线程并行清除前面标记出的不再存活的对象，由于不需要移动对象，所以不需要 Stop The World。

- 初始标记和重新标记需要 Stop The World。

- 因为 GC 过程中耗时最长的部分都是和用户线程并发执行的，所以 CMS 收集器的停顿时间是比较短的。

- CMS 收集器的 3 个缺点：

  - 因为每次 GC 过程中大部分时间都是和用户线程并发执行，相应的对服务器资源的要求就比较高了，CMS 收集器默认会启动的 GC 线程数为 (处理器核心数 + 1) / 4，对于核心数大于等于 4 的服务器，GC 线程最多占用 25% 的运算资源，但是如果用户线程本就资源紧张的环境，还要分资源给 CMS，这样会降低用户程序的吞吐量，只管感受就是执行速度大幅度降低。

  - CMS 收集不了浮动垃圾，当 CMS 和用户线程在并发运行时，如果用户线程产生了新的对象，便随产生了新的垃圾，这部分就是浮动垃圾，因为这部分垃圾出现在标记结束后，所以只能留待下一次 GC 再清理，因为 GC 线程和用户线程并发运行，所以 GC 过程中还需要留出内存给用户线程， 因此，CMS 收集器不能等到老年代被占满之后再进行 GC，在 JDK 5 的时候，默认是当老年代内存占用的 68% 时就会进行 GC，通过 -XX:CMSInitiatingOccupancyFraction 参数配置，JDK 6 时改配置提升为 92%，参数设置得太高也不行，因为达到 92% 时，CMS 启动 GC 线程会再占用部分内存，此时的内存如果不够申请新的对象，很可能会出现内存不足的情况，此时就会出现一次并发失败（Concurrent Mode Failure），此时虚拟机只能采取备选方案，使用 Serial Old 收集器对老年代进行一次收集。

  - CMS 收集器使用标记-清除算法，这种算法每次运行都会出现内存碎片，此时就会出现老年代还有很多空间，但是就是无法分配足够的内存，不得不触发一次 Full GC，针对这个问题，CMS 收集器提供 -XX:+UseCMSCompactAtFullCollection(JDK 9 已废弃) 来开启在 Full GC 时整理内存碎片，虽然内存碎片的问题解决了，但是因为标记-整理算法在整理内存碎片时需要 Stop The World，导致用户线程停顿时间变长了，针对这个问题，CMS 收集器提供 -XX:CMSFullGCsBeforeCompact(JDK 9 已废弃) 参数来决定几次 Full GC 不整理内存碎片后，下次 Full GC 就必须整理，该参数默认是 0，即每次 Full GC 都整理。

> 另外还有 3 个新的收集器，应该会单独写笔记了，太复杂了。

- G1（Garbage First）收集器

- ZGC 收集器

- Shenandoah 收集器

