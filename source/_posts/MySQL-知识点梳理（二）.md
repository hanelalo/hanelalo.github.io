---
title: MySQL 知识点梳理（二）
date: 2021-12-19 22:42:00
tags: MySQL
cover: https://hanelalo.github.io/images/202112192246399.jpeg
---

## InnoDB Buffer Pool

* InnoDB 为了提高读写性能，会申请一部分内存，划分为很多数据页，这部分内存的大小由 innodb_buffer_pool_size 参数决定，部分 MySQL 的数据文件内容会映射到这些数据页中。

- 如果要读取的数据不在 Buffer Pool 中，就会触发磁盘 IO 将相应的数据加载到一个新的数据页中。

- 对于有修改的数据页，有一个专门的线程会定时刷新一部分有改动的数据页到磁盘。

- 因为 Buffer Pool 有大小限制，所以当这部分内存用完之后，如果需要加载新的数据到数据页中，此时就需要通过一些缓存淘汰算法来决定替换哪些数据页来读取新的数据。

## 日志系统

### binlog

MySQL 的 Server 层的日志。在使用 InnoDB 存储引擎的表中，会先写 Redo Log，再写 binlog。

binlog 有三种模式

- ROW（基于行复制）

  - 记录数据被如何修改，主从同步时，只需要在从节点进行一样的修改即可。

  - 优点
    - 清楚记录每一条数据的修改细节，不会出现因主从差异导致的数据差异，比如 rand() 等函数。

  - 缺点
    - 每一行数据的变化都会在 binlog 中有单独记录，导致 binlog 文件比较大，导致主从复制时的 IO 压力增大。

- STATEMENT（基于语句复制）

  - 记录会修改数据的 SQL，以及上下文信息。

  - 优点
    - 相对 ROW 模式，日志文件更小，因为不用记录每一行数据的变化。

  - 缺点
    - 容易出现因主从差异导致的数据不一致，比如 sql 中使用了 rand() 函数的情况，两台 MySQL 服务器调用 rand() 函数的结果是可能不一样的。

- MIXED（混合模式）

  - 根据执行语句的具体情况记录 STATEMENT 或者 ROW 形式的日志。。

  - 优点
    - 结合了前面两种模式的优点。

### Redo Log

- 什么是 WAL 技术？
  - Write-Ahead Logging，写前日志，即先写日志，再写数据。

- 为什么有了 binlog 还要 Redo log？

  - Redo log 是 InnoDB 存储引擎内部维护的日志，binlog 是 MySQL 的 Server 层日志，不管使用什么存储引擎都会有。

  - Redo log 提供了 crash safe 的保障。 

- Redo Log 缓冲区: log buffer

  - 对数据的每一次变动，都会有相应的一条或多条 redo Log，redo Log 和 binlog 类似，也有写缓存，InnoDB 中通过 innodb_log_buffer_size 来配置 redo log 的写入缓存大小，MySQL 5.7 默认大小是 16MB。

  - redo log 写入缓冲区大小固定，缓冲区满了之后会从头开始写。

- 落盘时机

  - log buffer 满了。log buffer 有固定的容量限制，当 log buffer 写满之后，会从头开始写，在这之前，为了避免 redo log 数据丢失，会做一次 log buffer 数据落盘，其实 MySQL 在当前 log buffer 占用 50% 容量时就会落盘。

  - 事务提交。执行 sql 的过程中，修改数据其实是修改的 Buffer Pool 中的某一个数据页，被修改的数据页并不会立即落盘，这个过程中会产生 redo Log，因为需要 redo Log 保证 crash safe，所以在事务提交时，哪怕修改的 Buffer Pool 数据页还没有落盘，事务产生的 redo log 也必须要落盘，不然 commit 之后如果宕机了，这部分日志丢失，也就没法正确恢复数据。

  - 服务器正常关闭。和事务提交时落盘是一样的原因。

  - checkpoint。redo log 落盘后的磁盘文件大小也是有限制的，虽然 redo log 磁盘文件可以有多个，这些文件写满了之后，再写入数据就会从第一个文件开始覆盖，覆盖也就意味着 redo log 的数据丢失，所以，在覆盖的时候，必须保证要覆盖的 redo log 对应的 Buffer Pool 数据页已经落盘了；极端情况下，可能会出现要覆盖的 redo log 对应的 Buffer Pool 数据页还没有落盘，此时只能阻塞住，等后台线程将数据页刷盘之后才能继续写入 redo log，也就能解释 MySQL 偶尔执行速度慢的现象。

## 事务

- MySQL 事务并发引发的一致性问题

  - 脏写

    事务修改了其他事务修改但未提交的数据吗，其实这个已经限制死了不会发生。

  - 脏读

    事务读取了其他事务修改但未提交的数据。

  - 不可重复读

    一个事务内，读取同一条数据两次得到的结果不一样，一般是数据被其他事务 update 过。

  - 幻读

    一个事务内，根据某些搜索条件查询两次，得到的结果不一样，一般是有其他事务 insert 或者 delete 了符合条件的数据。我的理解是，不可重复读是针对同一条数据发生了变动，更关注前后两次查询的单一数据的不一致，幻读更关注前后两次查询出的数据条数不一致。

- 事务隔离级别

  - 读未提交

    当前事务可以读取到其他事务未提交的改动。存在脏读、不可重复读、幻读问题。

    实现原理：直接读取最新数据即可。

  - 读已提交

    当前事务只能读取到其他事务已经提交的改动。存在不可重复读、幻读问题。

    实现原理：在执行每一条 SQL 时创建视图，所以能读到已提交的数据。

  - 可重复读

    在事务开始后，其他事务提交了对数据的 update，当前事务也读取不到这部分 update 的数据改动。存在幻读问题。

    实现原理：在开启事务时，创建一个视图，整个事务执行过程中不变，所以无法读取其他事务已提交的数据。

  - 串行化

    所有事务，只能一个接一个串行执行。不存在前面讲的任何一个问题，但是性能较低。

    实现原理：直接加锁。

  **MySQL 默认隔离级别为可重复读，Oracle 默认隔离级别为读已提交。**

- 事务启动方式

  - BEGIN

  - START TRANSACTION，和 BEGIN 的区别是，该指令后面还可以跟参数。

    参数：

    - READ ONLY，开启一个只读事务，只能读数据，不能修改数据。

    - READ WRITE，开启一个读写事务，读写数据都可以。

    - WITH CONSISTENT SNAPSHOT，启动一致性读。

    START TRANSACTION 后面可以跟多个参数，用逗号分隔，但是 READ ONLY 和 READ WRITE 是设置事务读写状态的，不能放一起，都可以和 WITH CONSISTENT SNAPSHOT 组合。 

- 提交事务

  COMMIT

- 回滚事务

  ROLLBACK

- 索引

  参考 [https://hanelalo.cn/2021/03/14/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9-1/](https://hanelalo.cn/2021/03/14/MySQL知识点-1/)

  关于唯一性索引（包括主键索引）和普通索引，在执行 DML 时时有不同的性能的。

  - 如果表中有唯一性索引，执行 DML 需要先校验数据是否已经存在，此时如果要读取的数据没有加载到 Buffer Pool，还必须加载数据到数据页中。

  - 如果是普通索引，因为没有唯一性约束，此时如果数据不在内存中，也不会加载数据到内存页，而是将改动缓存到 change buffer 中，MySQL 有单独的线程将 change buffer 的改动真正应用到数据中，这个过程叫 merge，除了这个线程之外，在后续有请求要访问修改的数据时，也会先做 merge，然后再执行。

  ## 锁

  ### 全局锁

  - mysqldump

    - 启动一个事务，拿到一致性视图，不影响其他事务执行 DML。

    - 因为需要一致性视图，所以必须使用支持事务得存储引擎。

  - FTWRL

    - 一般是为了数据库备份，执行 Flush table with read lock 指令，整个数据库将处于只读状态，其他 DDL 和 DML 得执行线程都会阻塞。

    - 如果在主库上执行，在备份期间，不能更新数据，业务停摆。

    - 如果在从库执行，备份期间无法通过 binlog 进行主从同步，造成主从延迟。

    - 有了 mysqldump 之后还有 FTWRL 是因为 mysqldump 要求必须使用支持事务的存储引擎。

    - 如果是为了备份，为什么不通过 set global readonly=true 的方式将数据库设置为只读之后，再进行备份？

      - 有些系统会读取 readonly 参数来做一些逻辑，导致这种方式影响太大。

      - FTWRL 在连接异常断开后，会释放全局锁，但是 readonly 参数却不会在异常断开后恢复设置。

  ### 表锁

  #### 表锁

  - 针对表加读锁或写锁，读锁不互斥，写锁互斥，同一个事务持有写锁也可以进行读操作，和 Java 中的读写锁类似。

  - 元数据锁（MDL，Meta Data Lock）

    主要是为了保证读写的正确性。不需要显示加锁，访问表的时候就会自动获取，做增删改查时获取读锁，修改表结构时获取写锁。

  ### 行锁

  InnoDB 中行锁在执行 sql 的时候才会获取，直到事务结束才会释放。

  #### 死锁和死锁检测

  - 超时

    超过 innodb_lock_wait_timeout 配置时间就释放资源，这里也指挥回滚当前这一条 sql，而不是整个事务，如果要超时回滚整个事务就使用 innodb_rollback_on_timeout 参数，默认为 off。

  - 死锁回滚

    设置 innodb_deadlock_detect=on，发生死锁时，会根据 innodb_lock_wait_timeout 参数，看发生死锁的哪一个事务先超时，就回滚哪一个事务，但是到底是回滚发生死锁的 SQL 语句还是整个事务，取决于 innodb_rollback_on_timeout 参数。

  - 如何解决死锁回滚造成的大量 CPU 资源消耗？

    确认业务不会出现死锁的情况下，可以关掉死锁检测，但是关掉死锁，意味着可能出现大量死锁造成的超时；控制并发度，其实就是连接数控制，如果做在客户端，一旦客户端数量增加，还是会造成大量 CPU 资源消耗吗，所以需要作为服务端，或者中间件。
