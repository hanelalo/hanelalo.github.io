---
title: MySQL知识点-1
date: 2021-03-14 18:40:07
tags: MySQL
categories: 数据库
cover: https://hanelalo.github.io/images/202111061351625.png
---

# MySQL 知识点梳理（一）

## MySQL 架构

MySQL 主要分为客户端、Server 端和存储引擎。

![MySQL 架构](/img/post/MySQL架构.png)

* 客户端

  客户端一般都是指一些应用，比如常见的一些可以连接到数据库的可视化软件，也可以理解为客户端，如果写一段代码通过 JDBC 连接到 MySQL，运行这段代码的程序也是客户端，一般客户端和 Server 端都是靠 TCP 做网络通讯。

* Server 端

  用来处理连接请求和各种增啥改查的请求。

  1. 连接管理

     MySQL 内部维护了一个连接线程池，并不是每个连接过来都是新建一个线程，连接断开后又销毁，这样太浪费资源。

  2. 查询缓存

     顾名思义，就是如果同样的查询语句执行两次，两次都真正的去查询了，查出来的结果还是一样的，那就造成了浪费，完全可以把第一次的查询结果缓存下来，第二次查询的时候识别到是同样的查询语句，就可以将缓存直接返回而不用真的再次查询。

     既然用到了缓存，那么肯定还涉及到缓存的维护，当两次查询中间多了一次修改数据的操作，那缓存相应的也应该失效。维护缓存也是需要一些资源消耗的，但是其实现在大部分的架构中，MySQL 正常情况下并不会真的承担很大的流量冲击，所以这个缓存也不是很有必要，在 MySQL8.0 的时候直接删除了。

  3. 语法解析

     就是解析要执行的 SQL，毕竟 SQL 只是一个字符串，得解析成结构化的数据才知道一条 SQL 到底是做什么操作，像 SQL 中的一些语法错误就是在这个时候发现的。

  4. 查询优化

     SQL 都是人写的，很多时候可能写的不是很优雅，明明能用索引却没用到等等，这种的一般都会影响 SQL 的执行效率，所以 Server 端为了效率考虑，在不影响 SQL 最终执行结果的情况下，对 SQL 做出一些优化。优化之后最终会生成执行计划，可以通过 `explain <sql>` 的形式查看。 

* 存储引擎

  MySQL 作为最受欢迎的开源数据库之一，发展到现在已经积累的很多种存储引擎，之所以能支持这么多的存储引擎，主要还是因为存储引擎对 MySQL 来说是以插件的方式集成的，所以才能灵活的支持多种不同的存储引擎。目前主要使用的存储引擎主要是 Innodb，其次是可能还会用到 MyISAM 引擎。

  这两者主要的的异同点如下：

  1. 两种都是使用 B+ 树作为索引的数据结构。
  2. Innodb 使用的是聚簇索引，而 MyISAM 使用的是非聚簇索引。
  3. Innodb 支持事务，而 MyISAM 不支持。
  4. Innodb 支持行级锁、外键，而 MyISAM 不支持。

  除了上面的几个还有很多，其实记住也没用，反正会忘。

  MySQL 在 5.5.5 版本开始，默认使用 Innodb 作为存储引擎，在这之前一直是默认使用 MyISAM 引擎。

## 文件预读缓存

众所周知，在数据库四大特性中由持久性，最终数据都会被落盘。而当处理查询数据的请求时，最终页是要读取磁盘上存储的内容来进行查询，但是总不能一条一条的数据读取，当数据量大的时候，这样太慢了，性能大部分耗费在了磁盘 IO 上。针对这种情况，Innodb 对数据进行了分页，每一页默认 16 kb 大小，每次都不是只读取一条数据，而是读取一页数据。

> 这就像看书一样，虽然看是一行一行的看，但是每次进入你眼睛的肯定是一页，总不可能一页书那么多内容，眼睛就只能看见一行吧，这不科学。

这里一页数据的大小由 `innodb_page_size`  设置，这项配置是在初始化 MySQL 的时候就得决定好，后续是无法更改的，因为这还涉及到建索引的一些细节。从配置的名字也能看出，这是 Innodb 存储引擎专有的配置。

## B 树和 B+ 树

MySQL 的 InnodDB 引擎索引是使用的 B+ Tree。

B 树和 B+ 树最大的区别在于，B 树的所有节点都存储了数据，而 B+ 树的数据都在叶子节点上，所有父节点只是方便查询，而不会真正存储数据，所有叶子节点之间还维护了双向链表的数据结构。

因为索引也是需要持久化到磁盘文件，所以不得不考虑索引的存储空间的问题。B 树因为不管是不是叶子节点都存储了数据，所以当数据量逐渐上升时，树的高度就会逐渐上升。

下面主要通过[数据结构可视化的工具](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)对比一下 B 树和 B+ 树。

* B 树

  ![B Tree](/img/post/B-Tree.png)

* B+ 树

  ![B+ 树](/img/post/B+Tree.png)

首先解释一下 `Degree`，翻译过来叫做**度**，主要是用来限制每个节点的大小，观察上面两两张图，发现有些节点里有两条数据，这个 Degree 就可以理解为对 B 树或者 B+ 树中每个节点的数据个数的限制。

接下来再来看看这两个数到底有什么区别，为什么 MySQL 要使用 B+ 树作为索引？

观察上面两张图，同样都是存储 10 条数据，发现似乎 B 树的节点更少，而 B+ 树的节点更多，甚至还有重复的节点。当我单独查找 1 这个数据的时候， B 树似乎还比 B+ 树要快点的样子。要知道 B+ 树其实算是针对特殊业务的 B 树的改良版，其实单独要查找一条数据的时候，确实 B 树要比 B+ 树快，因为 B 树可能还没到叶子节点就返回了，但是 B+ 树必须一路查找到叶子节点才算完。**但是，MySQL 的 B+ 树一般也就 3 层的样子，性能差距基本体现不出来，这个在最后会讲。**

思考一个问题：

**如果现在要做范围查询，谁快？**

MySQL 并不可能只考虑单独查询一条数据的情况，更多的业务场景可能是范围查询。

当要做范围查询的时候，虽然两种树都算是有序的，但是 B 树在找到一个节点后，可能还得回到父节点，甚至可能还得回到爷爷辈的节点才能继续往下找到其他的目标节点，这是一种资源消耗；再看 B+ 树，发现所有的数据都在叶子节点上，而且所有叶子节点组成了有序链表， MySQL 中使用的还是双向链表，这样的设计，在做范围查询的时候，找到了第一个节点之后，跟着链表继续往后查询数据就行了，也就不用再考虑指针回到父节点这种事了，效率也就瞬间上去了。

现在知道为什么要用 B+ 树了。**那么 B+ 树到底是怎么存储数据的？**

我们看到 B+ 树的数据结构图中，很多叶子节点在父结点中也存在，这样不会造成数据冗余吗？

其实这就是数据结构和实际运用的问题了。不管是什么数据库，索引都是针对某些字段建立的，比如主键索引，那 B+ 树中的非叶子节点村的其实不是某个主键值的行数据，而只是存了主键字段的值，方便查询的时候对比，而完整的行数据只是存在最终指向的叶子节点中，因为比较的时候并不需要完整的行数据，所以，不存在所谓的数据冗余。就像下图这样，这个图画的并不准确，只是为了表示行数据都存在了叶子节点而已。

![B+Tree-Index](/img/post/B+Tree-Index.png)

## 聚簇索引和非聚簇索引

在前面讲到 Innodb 和 MyISAM 存储引擎的区别时，讲到 Innodb 使用的是聚簇索引，MyISAM 使用的是非聚簇索引。

聚簇索引和非聚簇索引的区别在于数据和索引是否放在一起，这里的在一起，也不是狭隘的指在同一个文件就行，我认为i在同一个文件是前提而已。

MySQL 的 Innodb 存储引擎，数据和索引放在一起，每个表都会有一个聚簇索引，聚簇索引主要是针对主键建立的，所以每一条数据的插入都必须插入主键对应的字段，如果表中没有主键，那就以唯一性字段作为聚簇索引，如果主键和唯一性字段都没有，就会以 MySQL 为每条数据默认生成的 rowId 建立聚簇索引，这个 row_id 对用户不可见，长度为 6 个字节，也就比 Java 中的 `int` 多 2 字节，比 Java 中的 `long` 少 2 字节，其实已经是一个很大的数了。

考虑到 MySQL 的索引使用的是 B+ Tree，所有数据都存在叶子节点上面，换个角度就是，聚簇索引的叶子节点已经包含和表中所有数据的内容，如果其他字段也单独建立索引，肯定也是基于 B+Tree，那么这个字段索引的叶子节点存储的将不是数据内容，而是数据主键，因为如果像主键索引一样存储数据内容，就造成和主键索引数据重复，没必要浪费这部分空间。

综上所述，Innodb 存储引擎的表中，只有一个且必须有一个聚簇索引，这个聚簇索引一般都是表的主键或者某个唯一性标识的字段或者 row_id，其他字段则是非聚簇索引。

MyISAM 使用的也是 B+Tree，不过使用的是非聚簇索引，也就是说，Myisam 引擎的数据文件和索引文件是分开存储的，索引树的叶子节点最终存储的不是行数据内容，而是数据的地址。

可以粗略对比一下 MyISAM 和 Innodb 的文件存储就知道了。

先创建两张表：

```sql
create table tab_inno(id int primary key,name varchar(10)); -- 当前版本 5.7，默认Innodb
create table tab_myisam(id int primary key,name varchar(10)) engine=MyISAM; -- 设置存储引擎为 MyISAM
```

可以通过下面的语句看看两张表的存储引擎是否和预想一样：

```sql
show create table tab_inno;
show create table tab_myisam;
```

然后去到 MySQL 的数据目录下面查看这两张表的数据文件。

通过 `show variables like 'datadir'` 可以查看数据目录的路径：

```sql
mysql> show variables like 'datadir';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| datadir       | /var/lib/mysql/ |
+---------------+-----------------+
1 row in set (0.00 sec)
```

到了数据目录之后，里面每个数据库都分了自己的文件夹，找到目标数据库的文件夹。

```bash
root@c3195fbafff8:/var/lib/mysql/study# ls -l
total 268
-rw-r----- 1 mysql mysql     65 Mar 14 04:15 db.opt
-rw-r----- 1 mysql mysql   8586 Mar 14 09:30 tab_inno.frm
-rw-r----- 1 mysql mysql  98304 Mar 14 09:30 tab_inno.ibd
-rw-r----- 1 mysql mysql      0 Mar 14 09:31 tab_myisam.MYD
-rw-r----- 1 mysql mysql   1024 Mar 14 09:31 tab_myisam.MYI
-rw-r----- 1 mysql mysql   8586 Mar 14 09:31 tab_myisam.frm
-rw-r----- 1 mysql mysql   8648 Mar 14 04:46 tb_user.frm
-rw-r----- 1 mysql mysql 131072 Mar 14 04:46 tb_user.ibd
root@c3195fbafff8:/var/lib/mysql/study#
```

可以看见 tab_inno 表对应的数据文件有两个，以 `.frm` 结尾的是表结构文件，`.idb` 结尾的文件表示是 `Innodb` 的数据文件。

而 tab_myisam 表的文件则有三个，一个 `.frm` 的表结构文件，一个 `.MYD` 结尾的数据文件，一个 `.MYI` 结尾的所以索引文件。

所以， 使用 MyISAM 存储引擎的表还真的不是聚簇索引。

## 回表

上面讲到了到两种索引，一个是主键 id 或者唯一性字段或这 row_id 建立索引，一般都是聚簇索引，这种的字段暂且统称为 key，还有一些字段，或许根本就不具备唯一性，但是我们为了方便查询，也建立了索引，比如 name，方便描述，先假设 key 的索引叫做 mainIndex，name 的索引叫做 nameIndex。

当我执行下面的查询语句时：

```sql
select id,name,age from tb_user where name='zhangsan';
```

此时，会先根据 `name='zhangsan'` 在 nameIndex 这个索引中查找，但最终找到的只有目标数据的 id，因为 nameIndex 是叶子节点中村的不是数据，而是数据的 key，在这个查询结果中，不只是要 key(这里指 id 这个字段)，还需要 age，而通过 nameIndex 这个索引，只拿到了 name 和 id，所以还需要通过查找到的 key 再到 mainIndex 中查找一次，才能找到目标数据的 age。

这种先查找到主键 key，然后通过主键 key 再次查询的操作就叫做回表。

## 索引覆盖

和回表一样的背景，只不过查询语句改为：

```sql
select id,name from tb_user where name='zhangsan';
```

之所以要回表是因为要查询 age 这个字段的值，因为查询结果要返回这个字段，但是上面这条语句，不返回 age 字段了，只需要 id 和 name，这两个字段的值，在 nameIndex 这个索引中是可以找到的，直接就满足了要返回的数据要求，所以就不需要再查询 mainIndex，直接返回，这种情况叫做索引覆盖。

对比了索引覆盖和回表操作之后，也就能够理解为什么再写查询语句的时候要避免使用 `select *` 而要求只写需要的字段，就是为了避免不必要的回表操作，导致不必要的 B+ Tree 查询。

## 最左匹配

最左匹配主要是针对联合索引。

比如建立如下的索引：

```sql
alter table tb_user add index name_gender (name,gender);
```

这里是针对 name 和 gender 两个字段建立的联合索引。

紧接着执行如下的语句：

```sql
select name, gender from tb_user where name=? and gender=?;
select name, gender from tb_user where name=?;
select name, gender from tb_user where gender=?;
select name, gender from tb_user where gender=? and name=?;
```

第一条 sql 因为建立的索引就是 name 和 gender，所以肯定使用到了索引。

第二条 sql，也使用到了 name_gender 这个索引。

第三条 sql 没有使用索引。

第四条 sql 因为 MySQL 的 sql 优化，所以使用到了索引。

之所以第三条没使用到索引，就是因为联合索引的最左匹配原则，建立索引时，前面的字段在查询时优先匹配，如果没匹配上，就不会使用这个索引。

可以理解为，第三条语句在尝试使用 name_gender 这个索引的时候，首先检查了当前的查询条件中是否使用了 name 这个字段，发现并没有，所以就直接不是用 name_gender 这个字段了，之所以要首先要检查是否使用了 name 这个字段，是因为在定义所以的时候， name 字段写在前面，所以说，定义联合索引时，字段也是又优先级的区别的。

## 索引下推

在文章最开始的时候就讲过，MySQL 架构分为客户端、服务端和存储引擎，在没有索引下推这种机制的时候，执行以下 SQL:

```sql
select * from tb_user where name='Stom' and age=12;
```

此时存储引擎会根据 `name='Stom'` 这个条件查询出结果，然后返回给服务端，然后由服务端来做 `age=12` 这部分的筛选。

这样做的坏处在于，可能在 `name='Stom'` 阶段返回了几十上百条数据，但是最终 `age=12` 过滤后只剩下几条数据，这对于存储引擎和服务端之间的通讯来说，造成了极大的资源浪费。

所以索引下推就是将 `age=12` 这一步也放到了存储引擎里面去做，减少了存储引擎和服务端之间的资源浪费。

## 问题

1. **范围查询有回表时，到底是一条一条回表还是集中回表？**

这个问题就涉及到 Server 层和存储引擎的交互了，其实不管怎样，这两者的交互一般都是以记录为单位的，所以一般都是找到一条记录，紧接着就去回表，然后返回给 Server 层，然后 Server 层会向存储引擎拿下一条数据。

2. **既然是一条一条的记录交互，那范围查询怎么使用到的 B+ 树叶子节点的链表结构的？**（其实是我自己突然想到了这个问题）

   每条记录返回时还带了链表中下一条记录的地址。

3. **索引的 B+ 树有几层？**

   这个问题，解释起来就比较麻烦。

   首先，Innodb 有页缓存，默认 16 k，换句话说，每次从磁盘读取数据都是 16 k 的读，然后看看下面的图：

   ![B+Tree_index2.png](/img/post/B+Tree_index2.png)

最上面一层其实是一个节点，4、6、8 之间有颜色的部分指向具体的数据页的地址，数据然后将数据页加载出来，再在内存中查，最终才能找到行数据，而每一页只能读取到 16 kb 的数据。

在最开始讲到 B+ 树的时候涉及到一个 Degree 的概念，而 Degree 直接影响到了 B+ 树在同样数据量下的深度，Degree 越小，可能层数越大，反之层数越小，层数越小，查询提条数据所要做的 IO 次数就越少，这是个性能问题。

而 Degree 要怎么决定？

这个不是配置的，它的值和 `innodb_page_size` 和索引列的数据类型都有关，比如索引列的类型为 int，4 个字节，16 k = 4096 * 4 byte，也就是说一个索引节点能装 4096 条 int 类型索引列的值。那如果时是 long，8 个字节，那就只有 2048 了，相应的同样的数据量下，long 类型字段的索引树的层数可能就比 int 类型高了，MySQL 一般都只有三层的样子，3 层听起来不多，但是想想 B+ 树的结构，不管是 int 类型还是 long 类型，三层就基本上是三次方的索引数据量，这已经是一个很大的数字了。以 int 举例，大概是 4096 * 4096 * 4096 = 68719476736，数据条数都到了这个数量级了，早分库分表了，所以 3 次的 IO 基本上和 B 树也没多大的性能差别了。

所以从这一波分析也得出一个答非所问的结论：**索引字段的类型占用空间越小越好。**

