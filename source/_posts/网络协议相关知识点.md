---
title: 网络协议相关知识点
date: 2022-02-27 10:45:39
tags: 网络协议
categories: 计算机网络
cover: https://hanelalo.github.io/images/202202271047191.png 
---

# 网络协议相关知识点

## TCP 三次握手

1. 客户端发送 SYN 信号，并且还带了一个序列号，进入 SYN_SENT 状态，这是第一次握手。

2. 服务端收到 SYN 信号，返回 ACK 信号，同时也会有一个 SYN 信号从服务端发向客户端，同样也带了一个序列号客户端变成 SYN_RCVD 状态，这是第二次握手。

3. 客户端收到服务端的 SYN 信号后，返回给服务端一个 ACK 信号，服务端进入 Established 状态，这是第三次握手。

## 为什么 TCP 需要三次握手，而不是两次？

因为要确定连接建立成功，所以发送 SYN 信号后还需要等待服务端返回一个 ACK 信号，这里有两次握手。TCP 每次传输的数据包都带了一个序列号，以避免重复传输或者漏传数据包，这个序列号是递增的，初始的序列号则是伴随 SYN 信号发出，TCP 是全双工协议，允许在两个方向上同时传输数据，如果服务端要向客户端发送数据，那也需要一个初始的序列号，所以在发送 ACK 信号给客户端时，还发送了一个 SYN 信号将初始序列号给了客户端，而客户端接收到 SYN 信号后，必须回复一个 ACK 信号给服务端，服务端才知道连接建立成功了。

所以，两次握手只能建立单向的连接，而 TCP 是全双工协议，需要建立双向连接，所以需要三次握手。

## TCP 四次挥手

1. 客户端发送带 FIN 标识的信号到服务端表示要断开连接，自己进入 FIN_WAIT_1 状态。

2. 服务端返回一个 ACK 消息，序列号是收到的序列号加 1，客户端收到 ACK 消息后进入 FIN_WAIT_2 状态，服务端进入 CLOSE_WAIT 状态。

3. 服务端发送 FIN 标识的信号到客户端表示要断开连接，然后进入 LAST_ACK 状态。

4. 客户端收到 FIN 消息，回复一个 ACK 消息，序列号是收到的序列号加 1，进入 TIME_WAIT 状态，服务端收到 ACK 报文后进入 CLOSE 状态，完全关闭。

## TCP 为什么需要四次挥手？

为了确保服务端和客户端的数据传输能顺利完成。

最开始发起 TCP 断开连接动作的，其实可以是客户端，也可以是服务端，只有最开始发起的一端最后会进入 TIME_WAIT 状态，等待还未接收完的数据。

CLOSE_WAIT 状态，是一个半关闭状态。TCP 是一个全双工协议，数据可以双向传输，客户端发起断开连接的请求后，只是表明服务端不再接收客户端的数据，但是它仍然可以向客户端发送数据。

和三次握手的主要区别在于，三次握手时，服务端将回复的 ACK 和 SYN 信号放在了一个报文里面，而四次挥手时，服务端回复 ACK 和发起断开连接的 FIN 信号分成了两个报文发送，所以变成了四次挥手而不是三次挥手。

而四次挥手时服务端将 ACK 和 FIN 分成两个报文发送，是因为 ACK 是内核态决定的，而 FIN 信号是用户态在数据处理完以后才发送的，所以并不能保证两者能同时发送，也就多了一次握手。

## TCP 粘包问题

**问题：**发送方发送的若干数据包到接收方粘成了 1 个包。

**原因：**

1. TCP 协议为了减少网络中的报文数量，收集多个数据包，再一起发送，导致粘包。
2. 接收方将接收到的数据放在缓存里面，如果接收数据到缓存的速度大于应用从缓存取数据的速度，也会导致粘包问题。

**解决方案：**

参考 Netty 对于 TCP 粘包、半包的处理，有 3 中方式。

1. 数据定长，比如约定请求报文的长度为 100，那么每次读取完整的信息就是读取 100 个字节，但是这并不灵活，万一有些请求数据本身大于 100 就不行了。
2. 特殊字符作为结尾标识，比如读取到`\r\n` 就认为本次请求的数据读取完成，这样也不够灵活。
3. 包头专门的字段记录请求数据的长度，现在的很多扩展性比较高的二进制协议都采用这种方式。

## OSI 七层模型

物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。

## TCP/IP 五层模型

物理层，数据链路层，网络层，传输层，应用层。

> TCP 协议是传输层协议，IP 协议是网络层协议。

## Http 协议

现在 Http 协议有 1.0、1.1、2.0 一共 3 个版本。

Http 1.0 真正做到了无状态，每次建立连接，请求完成后都会断开连接；

Http 1.1 协议增加了保持长连接的 Keep-Alived 标识支持长连接，通过 Content-Length 判断数据是否接收完毕；

Http 2.0 协议是二进制协议，不再是文本协议，引入数据帧和流的概念，因为帧的存在，数据有了序列，服务器支持并行传输数据。

### Http 1.0 和 1.1 的区别

1. 1.1 引入 Keep-Alived 支持长连接，避免频繁建立和销毁 TCP 连接，浪费资源。
2. 1.1 引入更多的缓存控制策略。
3. 支持 Host 头处理。

### Http 2.0 和 1.1 的区别

1. 2.0 支持多路复用，多个请求可以使用同一个连接，每个请求都有自己的 ID，通过 ID 对应请求和响应。
2. 2.0 是二进制协议，不是文本协议，传输效率更高。

## Https 协议

### Https 和 Http 的区别

1. Http 默认使用 80 端口，Https 默认是用 443 端口。
2. Http 铭文传输数据，不安全，Https 传输加密后的数据。
3. Http 协议不需要加密，效率更高，Https 因为需要加密，效率更低，资源消耗更多。

### Https 通信流程

1. 客户端向服务端发送请求。
2. 服务端返回一个 SSL 证书，其中包含一个非对称加密的公钥。
3. 客户端校验公钥是否为真，使用公钥对需要使用的对称加密算法和对称加密的密钥加密并发送给服务端。
4. 服务端收到后，用非对称加密的私钥进行解密，得到对称加密的算法和密钥。
5. 现在客户端可以使用对称加密的算法和密钥对数据加密进行通信。

### 对称加密

是指加密解密使用同一个密钥，加密速度也比较快，比如 AES、DES 算法。

### 非对称加密

是指加密和解密使用不用的密钥，所以非对称加密算法分为公钥和私钥，公钥是可以对外公开的，私钥是不能对外公开的，加解密速度相对比较低，所以在 Https 中，实际的数据传输还是使用对称加密，只不过对称加密的算法和密钥是通过非对称加密的方式传输告知对方的。

