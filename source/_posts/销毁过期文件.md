---
title: 销毁过期文件
date: 2020-10-06 23:24:13
tags: RocketMQ
categories: 消息中间件
cover: http://image.hanelalo.cn/images/202111061345430.png
---

# 销毁过期文件

RocketMQ 作为一个消息中间件, 终究不是专门用来持久化数据的, 所以并不需要将每一条消息都永久保留, 所以, RocketMQ 还提供了一个销毁过期文件的线程. 这个线程也是在启动 Broker 时跟着一起启动的.

我们知道启动 Broker 时, 初始化了消息存储 DefaultMessageStore, 调用了 DefaultMessageStore.start(), 在这个方法里面又调用了 addScheduleTask 方法:

```Java
  private void addScheduleTask() {

    this.scheduledExecutorService.scheduleAtFixedRate(
        DefaultMessageStore.this::cleanFilesPeriodically,
        1000 * 60,
        this.messageStoreConfig.getCleanResourceInterval(),
        TimeUnit.MILLISECONDS);
  // ......
  }
```

scheduleExecutorService 是一个单线程的线程池, 这里将清除过期文件的任务提交到了 scheduleExecutorService , 默认提交后 1 分钟开始执行, 执行周期为 this.messageStoreConfig.getCleanResourceInterval(), 默认是 10s 执行一次.

在 cleanFilesPeriodically 方法里面调用了 commitLog 过期文件的删除逻辑和 cosumeQueue 过期文件的删除逻辑, 因为逻辑都差不多, 而且都是依托于 MappedFile 实现, 所以这里就以 CommitLog 的删除逻辑为例进行学习.

```Java
  private void cleanFilesPeriodically() {
    this.cleanCommitLogService.run();
    this.cleanConsumeQueueService.run();
  }
```

那么主要的逻辑来到了 `DefaultMessageStore.CleanCommitLogService.deleteExpiredFles()` 方法:

```Java
    private void deleteExpiredFiles() {
      int deleteCount = 0;
      // 消息文件保留时间，从最后一次更新时间到现在， 如果超过了这个时间就会被删除， 默认 72 小时
      long fileReservedTime =
          DefaultMessageStore.this.getMessageStoreConfig().getFileReservedTime();
      // 删除文件的时间间隔， 因为每次可能不知删除一个文件， 该值指定两个文件被删除的时间间隔
      int deletePhysicFilesInterval =
          DefaultMessageStore.this.getMessageStoreConfig().getDeleteCommitLogFilesInterval();
      // 如果第一次尝试删除时发现有对该文件的引用存在，针对该文件的删除任务不会执行，
      // 但是会记录当时的时间戳，当第一次被拒绝的时间到当前时间大于 destroyMapedFileIntervalForcibly 这个值时，
      // 会强行将引用次数设置为负数，并将文件删除，
      // 在第一次被拒绝一直到 destroyMapedFileIntervalForcibly 这个时间间隔，只要文件不再有引用，也可以删除
      int destroyMapedFileIntervalForcibly =
          DefaultMessageStore.this.getMessageStoreConfig().getDestroyMapedFileIntervalForcibly();
      // rocketmq 固定每天 4 点(可配置)固定删除一次过期文件
      boolean timeup = this.isTimeToDelete();
      // 磁盘是否已经满了
      boolean spacefull = this.isSpaceToDelete();
      // 是否有触发手动删除
      boolean manualDelete = this.manualDeleteFileSeveralTimes > 0;

      if (timeup || spacefull || manualDelete) {

        if (manualDelete) {
          this.manualDeleteFileSeveralTimes--;
        }
        // 消息存储配置项: 文件有引用时,是否允许延迟删除
        boolean cleanAtOnce =
            DefaultMessageStore.this.getMessageStoreConfig().isCleanFileForciblyEnable()
                && this.cleanImmediately;

        log.info(
            "begin to delete before {} hours file. timeup: {} spacefull: {} manualDeleteFileSeveralTimes: {} cleanAtOnce: {}",
            fileReservedTime,
            timeup,
            spacefull,
            manualDeleteFileSeveralTimes,
            cleanAtOnce);

        fileReservedTime *= 60 * 60 * 1000;
        // 执行删除逻辑
        deleteCount =
            DefaultMessageStore.this.commitLog.deleteExpiredFile(
                fileReservedTime,
                deletePhysicFilesInterval,
                destroyMapedFileIntervalForcibly,
                cleanAtOnce);
        if (deleteCount > 0) {
        } else if (spacefull) {
          log.warn("disk space will be full soon, but delete file failed.");
        }
      }
    }
```

主要的几个点都已经在代码中注明, 删除文件的情况也就只有三种.

-  当前时间是系统定时删除过期文件的时间, 默认配置是凌晨 4 点
- 磁盘空间不足, 这里的逻辑稍微有点复杂, 下面会重点讲.
- 手工触发过期文件删除. 代码看到这里目前还没找见手工触发的入口.

这三种方式, 就第 18 行判断磁盘是否不足的逻辑比较复杂, 所以重点看一下代码.

## 磁盘占用判断

为了看起来代码少点, 我已经把源代码中日志记录的部分删除, 其中比较重要的部分也已经注明.

```Java
    private boolean isSpaceToDelete() {
      // 配置的磁盘最大占用率, 最大 95%, 最小 10%
      double ratio =
          DefaultMessageStore.this.getMessageStoreConfig().getDiskMaxUsedSpaceRatio() / 100.0;
      cleanImmediately = false;
      {
        // 文件存储路径
        String storePathPhysic =
            DefaultMessageStore.this.getMessageStoreConfig().getStorePathCommitLog();
        // 物理文件实际磁盘占用率
        double physicRatio = UtilAll.getDiskPartitionSpaceUsedPercent(storePathPhysic);
        // 如果实际占用率大于 diskSpaceWarningLevelRatio, 将 cleanImmediately 设置为 true,
        // 这会导致不管文件是否过期都可能会加入到要删除的文件队列中,
        // 超过这个阈值时, 建议删除文件, 磁盘设置为不可写, 会拒绝消息写入
        if (physicRatio > diskSpaceWarningLevelRatio) {
          boolean diskok = DefaultMessageStore.this.runningFlags.getAndMakeDiskFull();
          if (diskok) {
          }
          cleanImmediately = true;
        } else if (physicRatio > diskSpaceCleanForciblyRatio) {
          // 超过这个阈值时, 仅仅建议删除, 但是不会拒绝消息写入
          cleanImmediately = true;
        } else {
          // 标志磁盘占用率正常
          boolean diskok = DefaultMessageStore.this.runningFlags.getAndMakeDiskOK();
          if (!diskok) {
          }
        }
        // 磁盘实际占用率小于 0 或者大于配置的最大占用率, 返回 true,
        // 但不会标记磁盘为不可写, 也不会建议立即删除
        if (physicRatio < 0 || physicRatio > ratio) {
          return true;
        }
      }
      {
        // 获取消费者队列文件存储路径, 包括
        String storePathLogics =
            StorePathConfigHelper.getStorePathConsumeQueue(
                DefaultMessageStore.this.getMessageStoreConfig().getStorePathRootDir());
        // 消费者队列物理文件实际磁盘占用率
        double logicsRatio = UtilAll.getDiskPartitionSpaceUsedPercent(storePathLogics);
        if (logicsRatio > diskSpaceWarningLevelRatio) {
          boolean diskok = DefaultMessageStore.this.runningFlags.getAndMakeDiskFull();
          cleanImmediately = true;
        } else if (logicsRatio > diskSpaceCleanForciblyRatio) {
          cleanImmediately = true;
        } else {
          boolean diskok = DefaultMessageStore.this.runningFlags.getAndMakeDiskOK();
          if (!diskok) {
          }
        }

        if (logicsRatio < 0 || logicsRatio > ratio) {
          return true;
        }
      }

      return false;
    }
```

这里不仅仅判断 commitLog 文件的磁盘占用, 还判断了消费队列文件的磁盘占用, 逻辑基本都是差不多的, 解释一下几个主要的配置就能明白判断逻辑了.

- diskMaxUsedSpaceRatio 消息存储配置, 磁盘最大占用率, 这个占用率, 最大 95%, 最小 10%.
- diskSpaceWarningLevelRatio 通过系统参数 `rocketm.broker.diskSpaceWarningLevelRatio` 配置, 默认是 0.9, 当磁盘占用超过这个配置值时, 会建议立即删除文件, 而且会将磁盘标记为不可写, 也会间接的使得 broker 拒绝写入新的消息数据.
- diskSpaceCleanForciblyRatio 通过系统参数 `rocketmq.broker.diskSpaceCleanForciblyRatio` 进行配置, 默认 0.85, 磁盘占用超过这个阈值时, 也会建议立即删除文件, 但是不会标记磁盘不可写, 也就不会拒绝写入新消息.

判断磁盘占用的逻辑就到这里, 接下来看看删除调用 commitLog 删除过期文件的逻辑.

## 删除过期文件

```Java
// cleanFileForciblyEnable 消息存储配置项: 文件有引用时,是否强制删除
boolean cleanAtOnce =
    DefaultMessageStore.this.getMessageStoreConfig().isCleanFileForciblyEnable()
        && this.cleanImmediately;
fileReservedTime *= 60 * 60 * 1000; 
// 执行删除逻辑
deleteCount = DefaultMessageStore.this.commitLog.deleteExpiredFile(
        fileReservedTime,
        deletePhysicFilesInterval,
        destroyMapedFileIntervalForcibly,
        cleanAtOnce);
```

这里又读取了一个配置, cleanFileForciblyEnable, 删除的文件有引用时是否允许强制删除, 如果允许, 并且 cleanImmediately(前面讲磁盘占用的时候设置过) 也为 true, 那就是强制删除了, 记住这个配置, 因为后面判断文件是否要销毁时也用到这个配置.

然后将文件过期时间 fileReservedTime 从小时转化为毫秒, 最后调用 commitLog.deleteExpiredFile() 删除文件.

最后调用到 mappedFileQueue.deleteExpiredFileByTime() 方法.

```Java
    public int deleteExpiredFileByTime(final long expiredTime,
        final int deleteFilesInterval,
        final long intervalForcibly,
        final boolean cleanImmediately) {
    // ....
    }
```

- expiredTime 过期时间, 这里是 72 小时的毫秒数
- deleteFilesInterval 删除文件的时间间隔, 在销毁文件的线程调用时默认 100ms
- intervalForcibly 文件第一次拒绝销毁后最大存活时间, 文件销毁线程中默认是 1000*120, 也就是 2 分钟
- cleanImmediately 是否强制删除文件

```Java
            for (int i = 0; i < mfsLength; i++) {
                MappedFile mappedFile = (MappedFile) mfs[i];
                long liveMaxTimestamp = mappedFile.getLastModifiedTimestamp() + expiredTime;
                if (System.currentTimeMillis() >= liveMaxTimestamp || cleanImmediately) {
                    if (mappedFile.destroy(intervalForcibly)) {
                        files.add(mappedFile);
                        deleteCount++;

                        if (files.size() >= DELETE_FILES_BATCH_MAX) {
                            break;
                        }

                        if (deleteFilesInterval > 0 && (i + 1) < mfsLength) {
                            try {
                                Thread.sleep(deleteFilesInterval);
                            } catch (InterruptedException e) {
                            }
                        }
                    } else {
                        break;
                    }
                } else {
                    //avoid deleting files in the middle
                    break;
                }
            }
```

循环检测从第一个到倒数第二个 MappedFile 是否过期, 如果过期或者 cleanImmediately 为 true, 那就调用 mappedFile.destory() 方法销毁文件, 这个在 https://www.yuque.com/hanelalo/hwzbuc/cizuar#i25h7 也已经讲过了, 每次销毁文件的文件数不得超过 DELETE_FILES_BATCH_MAX, 默认 10.

最后, 维护 MappedFileQueue 中的 mappedFiles 容器, 将前面销毁的 MappedFile 从中删除.

```Java
    void deleteExpiredFile(List<MappedFile> files) {
        if (!files.isEmpty()) {
            Iterator<MappedFile> iterator = files.iterator();
            while (iterator.hasNext()) {
                MappedFile cur = iterator.next();
                if (!this.mappedFiles.contains(cur)) {
                    iterator.remove();
                    log.info("This mappedFile {} is not contained by mappedFiles, so skip it.", cur.getFileName());
                }
            }
            try {
                if (!this.mappedFiles.removeAll(files)) {
                    log.error("deleteExpiredFile remove failed.");
                }
            } catch (Exception e) {
                log.error("deleteExpiredFile has exception.", e);
            }
        }
    }
```