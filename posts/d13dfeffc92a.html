<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/img/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/avatar.jpg">
  <link rel="mask-icon" href="/img/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hanelalo.cn","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="详解 BeanDefinition 中的作用及解析过程。">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring源码解析：BeanDefinition">
<meta property="og:url" content="http://hanelalo.cn/posts/d13dfeffc92a">
<meta property="og:site_name" content="假隐士">
<meta property="og:description" content="详解 BeanDefinition 中的作用及解析过程。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-26T22:11:37.000Z">
<meta property="article:modified_time" content="2023-11-19T13:53:28.588Z">
<meta property="article:author" content="假隐士">
<meta property="article:tag" content="Spring源码解析">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://hanelalo.cn/posts/d13dfeffc92a.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://hanelalo.cn/posts/d13dfeffc92a","path":"posts/d13dfeffc92a.html","title":"Spring源码解析：BeanDefinition"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring源码解析：BeanDefinition | 假隐士</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="假隐士" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="假隐士" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">假隐士</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-关于我"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-闲书杂记"><a href="/blog/" rel="section"><i class="fa fa-book fa-fw"></i>闲书杂记</a></li><li class="menu-item menu-item-菜谱"><a href="/cookbook/" rel="section"><i class="fa fa-link fa-fw"></i>菜谱</a></li><li class="menu-item menu-item-常用网站"><a href="/normal-website" rel="section"><i class="fas fa-atlas fa-fw"></i>常用网站</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#loadBeanDefinitions"><span class="nav-number">1.</span> <span class="nav-text">loadBeanDefinitions()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#parseBeanDefinitions"><span class="nav-number">2.</span> <span class="nav-text">parseBeanDefinitions()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#import-%E6%A0%87%E7%AD%BE"><span class="nav-number">2.1.</span> <span class="nav-text">import 标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alias-%E6%A0%87%E7%AD%BE"><span class="nav-number">2.2.</span> <span class="nav-text">alias 标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#beans-%E6%A0%87%E7%AD%BE%E8%A7%A3%E6%9E%90"><span class="nav-number">2.3.</span> <span class="nav-text">beans 标签解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bean-%E6%A0%87%E7%AD%BE%E8%A7%A3%E6%9E%90"><span class="nav-number">2.4.</span> <span class="nav-text">bean 标签解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-BeanDefinition"><span class="nav-number">2.4.1.</span> <span class="nav-text">创建 BeanDefinition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-bean-%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7"><span class="nav-number">2.4.2.</span> <span class="nav-text">解析 bean 标签属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-description-%E6%A0%87%E7%AD%BE"><span class="nav-number">2.4.3.</span> <span class="nav-text">解析 description 标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-meta-%E6%A0%87%E7%AD%BE"><span class="nav-number">2.4.4.</span> <span class="nav-text">解析 meta 标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-lookup-method-%E6%A0%87%E7%AD%BE"><span class="nav-number">2.4.5.</span> <span class="nav-text">解析 lookup-method 标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-replaced-method-%E6%A0%87%E7%AD%BE"><span class="nav-number">2.4.6.</span> <span class="nav-text">解析 replaced-method 标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-constructor-arg-%E6%A0%87%E7%AD%BE"><span class="nav-number">2.4.7.</span> <span class="nav-text">解析 constructor-arg 标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-property-%E6%A0%87%E7%AD%BE"><span class="nav-number">2.4.8.</span> <span class="nav-text">解析 property 标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-qualifier-%E6%A0%87%E7%AD%BE"><span class="nav-number">2.4.9.</span> <span class="nav-text">解析 qualifier 标签</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="假隐士"
      src="/img/avatar.jpg">
  <p class="site-author-name" itemprop="name">假隐士</p>
  <div class="site-description" itemprop="description">做该做的事，然后接受它的事与愿违。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hanelalo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hanelalo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/hanelalo" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hanelalo.cn/posts/d13dfeffc92a">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/avatar.jpg">
      <meta itemprop="name" content="假隐士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="假隐士">
      <meta itemprop="description" content="做该做的事，然后接受它的事与愿违。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Spring源码解析：BeanDefinition | 假隐士">
      <meta itemprop="description" content="详解 BeanDefinition 中的作用及解析过程。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring源码解析：BeanDefinition
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-26 22:11:37" itemprop="dateCreated datePublished" datetime="2022-10-26T22:11:37+00:00">2022-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-19 13:53:28" itemprop="dateModified" datetime="2023-11-19T13:53:28+00:00">2023-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>41k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>37 分钟</span>
    </span>
</div>

            <div class="post-description">详解 BeanDefinition 中的作用及解析过程。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>在上一讲中，已经知道了如何加载资源文件，但是事实上加载资源的时候更多的只是拿到资源文件的引用，并没做进一步的内容解析，所以还需要对资源文件进行解析。</p>
<p>以 ClassPathXmlApplicationContext 为例，从名称上就能知道，它加载的资源文件其实是 xml 配置文件。</p>
<p>那么具体是如何解析？解析完成之后得到的又是什么呢？</p>
<p>这就是本文的主题：BeanDefinition。</p>
<p>总体来讲，其实就是这样一个过程：</p>
<pre><code class="highlight mermaid">%% graph TD; comment
graph LR
xml_file([Xml文件])
xml_resource([Xml Resource])
xml_document([Xml Document])
bean_definition([BeanDefinition])
xml_file--&gt;|ResourceLoader|xml_resource--&gt;|DocumentLoader|xml_document--&gt;|BeanDefinitionReader|bean_definition</code></pre>

<p>其中 ResourceLoader 将 xml 文件加载成为 xml resource 这一步，我们已经讲过。本章将关注 DocumentLoader 将 xml resource 转换为 xml document，以及 BeanDefinitionReader 再将 xml document 转换为 BeanDefinition。</p>
<p>BeanDefinition 包含了创建一个 bean 所需要的数据，它不是 bean，而是定义一个 bean 所需的数据就在其中。</p>
<h2 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions()"></a>loadBeanDefinitions()</h2><p>在 AbstractXmlApplicationContext 中，有 loadBeanDefinitions(XmlBeanDefinitionReader reader) 方法，接收一个 XmlBeanDefinitionReader 参数，用来获取 BeanDefinition。</p>
<blockquote>
<p>需要知道的是，AbstractXmlApplicationContext 是持有一个 BeanFactory 对象的，初始化时，需要先初始化一个 BeanFactory 的对象，然后才开始解析 BeanDefinition。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">	<span class="comment">// 这里其实是最开始穿配置文件的资源对象</span></span><br><span class="line">	<span class="comment">// 这里会判断当前是否拿到了配置资源对象，</span></span><br><span class="line">	Resource[] configResources = getConfigResources();</span><br><span class="line">	<span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果有，就直接通过资源对象解析 BeanDefinition</span></span><br><span class="line">		reader.loadBeanDefinitions(configResources); <span class="comment">// 1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断是否有配置文件的路径信息</span></span><br><span class="line">	String[] configLocations = getConfigLocations();</span><br><span class="line">	<span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果有，解析 Xml 为 BeanDefinition，这里最终依然会拿到配置文件的配置资源对象，</span></span><br><span class="line">		<span class="comment">// 然后调用上面的 loadBeanDefinitions</span></span><br><span class="line">		<span class="comment">// 注意这里有两个 loadBeanDefinitions() 方法，但是入参一个是 Resource 对象，</span></span><br><span class="line">		<span class="comment">// 一个是配置文件的路径，后者最终依然会调到入参是 Resource 对象的 loadBeanDefinitions()</span></span><br><span class="line">		reader.loadBeanDefinitions(configLocations); <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会发现有两个地方调用了 reader.loadBeanDefinitions() 方法，只不过入参类型不一样：</p>
<ol>
<li><p>XmlBeanDefinitionReader#loadBeanDefinitions(Resource… resources)</p>
<p>直接传入 Resource 对象进行解析。</p>
</li>
<li><p>XmlBeanDefinitionReader#loadBeanDefinitions(String… locations)</p>
<p>传入的是资源的地址，深入查看会发现其实还是会加载成 Resource 对象后调用第一个方法。</p>
</li>
</ol>
<blockquote>
<p>当拿到 Resource 对象后，并不是直接就开始解析，而是还使用 EncodedResource 做了一层封装，看名称就知道是为了指定资源的字符编码的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从线程上下文中获取已经开始加载的 EncodingResource 对象</span></span><br><span class="line">	Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尝试将 encodingResource 添加进线程上下文持有的 HashSet 中，如果添加失败，说明存在循环加载，就会直接报错。</span></span><br><span class="line">	<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">				<span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取 Resource 对象的 InputStream 输入流，这里需要注意，Resource 接口是继承了 InputStream 接口</span></span><br><span class="line">	<span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line">		<span class="comment">// 转换为 InputSource</span></span><br><span class="line">		<span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">		<span class="comment">// 设置编码集</span></span><br><span class="line">		<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">			inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 真的加载 BeanDefinition</span></span><br><span class="line">		<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">				<span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 从线程上下文中的 encodingResources 的 HashSet 中移除 </span></span><br><span class="line">		currentResources.remove(encodedResource);</span><br><span class="line">		<span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">			<span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先会从线程上下文中获取一个用于记录已经开始加载的 EncodedResouce 对象的 HashSet，用于判断是否有循环加载。</li>
<li>然后获取资源的 InputStream，Resource 接口是继承了 InputStream 接口的，所以这里能直接调用 getInputStream() 方法获取 InputStream。</li>
<li>然后就是为 xml 的解析做准备，这里采用的是 sax 解析，所以首先将 InputStream 对象转换成了 sax 库的 InputSource 对象，并设置了字符编码集。</li>
<li>执行 doLoadBeanDefinition() 方法，做进一步处理。这里就是要开始解析 xml 文件，并将得到的 BeanDefnition 进行注册了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 解析 xml 为 Document 对象</span></span><br><span class="line">		<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">		<span class="comment">// 注册 BeanDefinition</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// catch...异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 doLoadBeanDefinition() 方法中会先解析 InputSource，得到一个 Document 文档对象，再通过文档对象进行 BeanDefinition 的注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="comment">// 创建 BeanDefinitionDocumentReader</span></span><br><span class="line">	<span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="comment">// 获取当前已注册的 BeanDefinition 数量</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">	<span class="comment">// 解析并注册 BeanDefinition</span></span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了一个 BeanDefinitionDocumentReader，用于从 Document 对象中读取 BeanDefinition。</p>
<p>最终会执行到 <code>DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions(Element root)</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">	<span class="comment">// 创建解析器的委托类，具体的解析操作由 BeanDefinitionParserDelegate 完成</span></span><br><span class="line">	<span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">	<span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">	<span class="comment">// 命名空间是否是默认命名空间：空或者 http://www.springframework.org/schema/beans</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		<span class="comment">// 获取配置的 profile 属性</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">			<span class="comment">// 如果有指定 profile, 对 profile 的字符串进行拆解，多个 profile 以英文逗号或分号分隔</span></span><br><span class="line">			String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">					profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">			<span class="comment">// 检查是否有指定的 profile 被激活</span></span><br><span class="line">			<span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">							<span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 预留的 xml 处理前置逻辑，默认是不做任何操作</span></span><br><span class="line">	preProcessXml(root);</span><br><span class="line">	<span class="comment">// 解析 BeanDefinition</span></span><br><span class="line">	parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">	<span class="comment">// 预留的 xml 处理后置逻辑，默认不做任何操作</span></span><br><span class="line">	postProcessXml(root);</span><br><span class="line">	<span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将解析 xml 的逻辑又委托到了 BeanDefinitionParserDelegate 类中，并且考虑到 <code>&lt;beans&gt;</code> 嵌套的情况，所以初始化 BeanDefinitionParserDelegate 时，还传入了父 BeanDefinitionParserDelegate。</p>
<p>对于多 profile 的支持，也是在上面获取 beans 标签的 profile 属性部分的逻辑进行支持的。</p>
<p>然后，再进一步看看 parseBeanDefinitions() 方法的逻辑。</p>
<h2 id="parseBeanDefinitions"><a href="#parseBeanDefinitions" class="headerlink" title="parseBeanDefinitions()"></a>parseBeanDefinitions()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">	<span class="comment">// 是否是 spring 默认的命名空间</span></span><br><span class="line">	<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		<span class="comment">// 获取子节点列表</span></span><br><span class="line">		<span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">			<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">				<span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">				<span class="comment">// 子节点是否是默认命名空间中的标签</span></span><br><span class="line">				<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">					<span class="comment">// 解析默认标签节点</span></span><br><span class="line">					parseDefaultElement(ele, delegate);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 自定义标签解析</span></span><br><span class="line">					delegate.parseCustomElement(ele);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 解析自定义标签</span></span><br><span class="line">		delegate.parseCustomElement(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断是否是默认的命名空间，如果是，就调用 spring 的解析逻辑，如果不是，那就证明是第三方集成的组件，需要走到 else 的逻辑，调用第三方自定义的标签解析逻辑。</p>
<p>而如果是 spring 的默认命名空间，但是子节点的所属命名空间又不在 spring 的命名空间中，依然会走自定义的解析逻辑。</p>
<p>这里我们首先就需要举个例子了解一下 xml 这个命名空间里命名空间。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-2.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">				http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop-2.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">				http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context-2.5.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.scheduling.annotation.AsyncAnnotationAdvisor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的 xml 中， 引入的命名空间都在 beans 标签的 xmlns 系列的属性中，除了第一个是默认的，其余的比如 aop、context 命名空间，在使用时，一般都会在标签名前加上所属的命名空间。</p>
<blockquote>
<p>这里会发现 spring 有单独的 aop、context 命名空间，也体现了 spring 设计上的解耦。</p>
</blockquote>
<p>这样，就能理解前面的关于命名空间的判断逻辑了。</p>
<p>那么，我们接下来需要看看以下两个方法：</p>
<ul>
<li>默认命名空间的标签解析：<code>DefaultBeanDefinitionDocumentReader#parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate)</code></li>
<li>自定义命名空间的标签解析：<code>BeanDefinitionParserDelegate#parseCustomElement(Element ele)</code></li>
</ul>
<p>这里暂时只看默认命名空间的标签解析，自定义标签的解析将在下一篇文章中讲解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">	<span class="comment">// 解析&lt;import&gt;标签</span></span><br><span class="line">	<span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// 解析&lt;alias&gt;标签</span></span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// 解析&lt;bean&gt;标签</span></span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// beans 中嵌套了 beans 标签，这里需要递归调用 doRegisterBeanDefinitions 方法</span></span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里引入了 4 种标签的解析：</p>
<ul>
<li><p>import</p>
<p>导入其他的资源文件。</p>
</li>
<li><p>alias</p>
<p>别名。</p>
</li>
<li><p>bean</p>
<p>bean 标签，可解析成一个 BeanDefinition 对象。</p>
</li>
<li><p>beans</p>
<p>相当于在 beans 标签中嵌套了 beans 标签。</p>
</li>
</ul>
<h3 id="import-标签"><a href="#import-标签" class="headerlink" title="import 标签"></a>import 标签</h3><p>Import 标签使用的形式一般如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beanConfigurerTests-beans.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>resource 属性用来指定要导入的资源的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">importBeanDefinitionResource</span><span class="params">(Element ele)</span> &#123;</span><br><span class="line">	<span class="comment">// 获取  resource 属性</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasText(location)) &#123;</span><br><span class="line">		<span class="comment">// resource 属性为空，记录错误，返回</span></span><br><span class="line">		getReaderContext().error(<span class="string">&quot;Resource location must not be empty&quot;</span>, ele);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 处理 resource 属性值中类似 $&#123;user.dir&#125; 这样的变量占位</span></span><br><span class="line">	location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);</span><br><span class="line"></span><br><span class="line">	Set&lt;Resource&gt; actualResources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Discover whether the location is an absolute or relative URI</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">absoluteLocation</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 判断 resource 配置的是绝对位置还是相对位置</span></span><br><span class="line">		absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line">		<span class="comment">// cannot convert to an URI, considering the location relative</span></span><br><span class="line">		<span class="comment">// unless it is the well-known Spring prefix &quot;classpath*:&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Absolute or relative?</span></span><br><span class="line">	<span class="keyword">if</span> (absoluteLocation) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 如果是绝对位置，又回到最初的入参为资源的 location 的 loadBeanDefinitions 方法进行 BeanDefinition 的加载注册</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">importCount</span> <span class="operator">=</span> getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Imported &quot;</span> + importCount + <span class="string">&quot; bean definitions from URL location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(</span><br><span class="line">					<span class="string">&quot;Failed to import bean definitions from URL location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// No URL -&gt; considering resource location as relative to the current file.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 尝试当成相对位置处理</span></span><br><span class="line">			<span class="type">int</span> importCount;</span><br><span class="line">			<span class="comment">// 通过相对位置加载 Resource，这是 Resource 接口提供的能力，用于创建当前 Resource 相对路径下某资源的 Resource 对象</span></span><br><span class="line">			<span class="type">Resource</span> <span class="variable">relativeResource</span> <span class="operator">=</span> getReaderContext().getResource().createRelative(location);</span><br><span class="line">			<span class="keyword">if</span> (relativeResource.exists()) &#123;</span><br><span class="line">				<span class="comment">// 如果资源对应文件是存在的，就开始加载资源中的 BeanDefinition</span></span><br><span class="line">				importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">				actualResources.add(relativeResource);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 如果不存在，则直接将资源的绝对路径传到 loadBeanDefinition 方法中，由其内部逻辑进行加载。</span></span><br><span class="line">				<span class="type">String</span> <span class="variable">baseLocation</span> <span class="operator">=</span> getReaderContext().getResource().getURL().toString();</span><br><span class="line">				importCount = getReaderContext().getReader().loadBeanDefinitions(</span><br><span class="line">						StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Imported &quot;</span> + importCount + <span class="string">&quot; bean definitions from relative location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			getReaderContext().error(<span class="string">&quot;Failed to resolve current resource location&quot;</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(</span><br><span class="line">					<span class="string">&quot;Failed to import bean definitions from relative location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Resource[] actResArray = actualResources.toArray(<span class="keyword">new</span> <span class="title class_">Resource</span>[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">// 发布触发导入处理事件</span></span><br><span class="line">	getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>对 import 标签的解析首先判断了标签的 resource 属性是否有值，如果没有值，会记录错误并解析结束。</li>
<li>对于 resource 属性的值存在 <code>$&#123;user.dir&#125;</code> 这种情况，需要提前进行处理。</li>
<li>定义了一个叫做 actualResources 的 Set，用于记录当前这个 import 标签导入的 Resource 对象。</li>
<li>需要判断 resource 的地址是相对路径还是绝对路径。</li>
<li>如果是绝对路径，直接调用参数为资源路径字符串的 loadBeanDefinitions 方法进行加载，其实就回到了最开始通过一个资源文件位置来加载 BeanDefinition 的时候了。</li>
<li>如果不是绝对路径，就当成是相对路径处理，先根据相对路径创建一个 Resource 对象，然后使用 Resource 接口提供的 exists() 方法判断资源文件是否存在，如果存在，则调用 loadBeanDefinitions() 方法，通过 Resource 对象加载 BeanDefinition，如果资源文件不存在，那就是可能是 Resource 类型不对，那就拼接处完整的绝对路径，调用 loadBeanDefinitions() 方法，通过资源文件路径加载 BeanDefinition。</li>
</ol>
<p>综上所述，其实最终都还是加载了 resource 对应的 Resource 对象，然后再解析出 BeanDefinition。</p>
<h3 id="alias-标签"><a href="#alias-标签" class="headerlink" title="alias 标签"></a>alias 标签</h3><p>Alias 标签使用一般如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;testBean&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;testBeanAlias1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>name 属性为要起别名的 bean 的名字，alias 为别名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processAliasRegistration</span><span class="params">(Element ele)</span> &#123;</span><br><span class="line">	<span class="comment">// 获取 name 属性</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">	<span class="comment">// 获取 alias 属性</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">alias</span> <span class="operator">=</span> ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 检查 name 是否有效</span></span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasText(name)) &#123;</span><br><span class="line">		getReaderContext().error(<span class="string">&quot;Name must not be empty&quot;</span>, ele);</span><br><span class="line">		valid = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 检查 alias 是否有效</span></span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasText(alias)) &#123;</span><br><span class="line">		getReaderContext().error(<span class="string">&quot;Alias must not be empty&quot;</span>, ele);</span><br><span class="line">		valid = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (valid) &#123;</span><br><span class="line">		<span class="comment">// name、alias 都有效</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 注册别名到 BeanFactory 中</span></span><br><span class="line">			getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			getReaderContext().error(<span class="string">&quot;Failed to register alias &#x27;&quot;</span> + alias +</span><br><span class="line">					<span class="string">&quot;&#x27; for bean with name &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 发布 alias 标签处理事件</span></span><br><span class="line">		getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先获取 <code>&lt;alias&gt;</code> 标签的 name、alias 属性，然后检查是否为空，只要其中有一个为空，解析就结束了。</li>
<li>name、alias 属性都不为空，则将别名注册到 BeanFactory 中，这里只需要知道在 BeanFactory 中哟一个 Map 专门用来记录每个 bean 的别名，其 key 为别名，value 为真正 bean 的名称。</li>
<li>发布 alias 标签处理事件。</li>
</ol>
<h3 id="beans-标签解析"><a href="#beans-标签解析" class="headerlink" title="beans 标签解析"></a>beans 标签解析</h3><p>其实就是递归调用了 doRegisterBeanDefinitions() 方法而已。</p>
<h3 id="bean-标签解析"><a href="#bean-标签解析" class="headerlink" title="bean 标签解析"></a>bean 标签解析</h3><p>bean 标签是相当常用的标签了，一般用法示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderedBeforeTransaction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.autoproxy.OrderedTxCheckAdvisor&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>9<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;requireTransactionContext&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>解析 bean 标签的逻辑位于 <code>DefaultBeanDefinitionDocumentReader#processBeanDefinition(...) </code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">	<span class="comment">// BeanDefinitionHolder 中保存了 BeanDefinition 和 bean 名称以及别名</span></span><br><span class="line">	<span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	<span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 解析 xml 中的自定义命名空间（如果有的话）</span></span><br><span class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Register the final decorated instance.</span></span><br><span class="line">			<span class="comment">// 将 BeanDefinition 注册到 BeanFactory 的 beanDefinitionMap</span></span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">					bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Send registration event. 发送 BeanDefinition 注册完成事件</span></span><br><span class="line">		getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 BeanDefinitionParserDelegate#parseBeandDefinition(Element ele) 方法解析标签，得到 BeanDefinitionHolder。</li>
<li>自定义标签装饰逻辑。</li>
<li>调用 BeanDefinitionReaderUtils 注册 BeanDefinition，总体来讲就是建立 beanName 和 BeanDefinition 的映射关系，以及 alias 和 beanName 的映射关系。</li>
</ol>
<p>会发现这里将解析 BeandDefinition 的逻辑又放到了 <code>BeanDefinitionParserDelegate#parseBeandDefinition(Element ele)</code> 方法中，而且返回的也不是 BeanDefinition，而是 BeanDefinitionHolder 对象，BeanDefinitionHoldern 对象持有一个 BeanDefinition 对象，bean 名称，以及 bean 的别名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinitionHolder</span> <span class="keyword">implements</span> <span class="title class_">BeanMetadataElement</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String[] aliases;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是针对标签属性的命名空间的自定义解析逻辑，这部分对于自定义命名空间的使用，后文单独讲解。</p>
<p>这里我们先深入看看 <code>BeanDefinitionParserDelegate#parseBeandDefinition(Element ele)</code> 是如何拿到 BeanDefinitionHolder 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * containingBean 其实是父 bean 的 BeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 id 属性值</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 name 属性值，解析成 bean 的别名，多个别名用英文逗号分割</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">	List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">		<span class="comment">// 将多个别名按英文逗号或分号分割</span></span><br><span class="line">		String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">		aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 id 为空，则取 name 属性中的第一个别名作为默认的 beanName</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">		beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">					<span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">		checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析一个 AbstractBeanDefinition 对象，其实是一个 GenericBeanDefinition 对象</span></span><br><span class="line">	<span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">	<span class="comment">// 生成默认的 beanName</span></span><br><span class="line">	<span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">					beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">							beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">					<span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">					<span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">					<span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">					<span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line">					<span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">							beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">							!<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">						aliases.add(beanClassName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">							<span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				error(ex.getMessage(), ele);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先获取了 bean 标签的 id、name 属性，对于 name 属性存在多个名字的情况，以英文逗号或者分号进行分割。</li>
<li>默认 beanName 为 id 属性的值，如果 id 属性未配置，则以 name 属性解析出的第一个名称为 beanName，并从 alias 别名列表中移除。</li>
<li>检查别名和 beanName 是否已经被注册过了，如果是，就会抛出 beanName 冲突异常。</li>
<li>调用 <code>parseBeanDefinitionElement(...)</code> 方法解析得到 BeanDefinition 对象。</li>
<li>如果 beanName 为空，则由 BeanFactory 生成一个 beanName。</li>
<li>最后生成一个 BeanDefinitionHolder 对象并返回。</li>
</ol>
<p>然后看看 <code>parseBeanDefinitionElement(...)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractBeanDefinition <span class="title function_">parseBeanDefinitionElement</span><span class="params">(</span></span><br><span class="line"><span class="params">		Element ele, String beanName, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">BeanEntry</span>(beanName));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 class 属性</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">		className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解析 parent 属性</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">		parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 创建 AbstractBeanDefinition 的子类 GenericBeanDefinition</span></span><br><span class="line">		<span class="type">AbstractBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> createBeanDefinition(className, parent);</span><br><span class="line">		<span class="comment">// 解析 bean 标签属性</span></span><br><span class="line">		parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">		<span class="comment">// 设置 description，通过 &lt;description&gt; 子标签获取</span></span><br><span class="line">		bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">		<span class="comment">// 解析元数据</span></span><br><span class="line">		parseMetaElements(ele, bd);</span><br><span class="line">		<span class="comment">// 解析 lookup-method 子标签</span></span><br><span class="line">		parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">		<span class="comment">// 解析 replaced-method 子标签</span></span><br><span class="line">		parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">		<span class="comment">// 解析 constructor-arg 子标签</span></span><br><span class="line">		parseConstructorArgElements(ele, bd);</span><br><span class="line">		<span class="comment">// 解析 property 子标签</span></span><br><span class="line">		parsePropertyElements(ele, bd);</span><br><span class="line">		<span class="comment">// 解析 Qualifier 子节点</span></span><br><span class="line">		parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">		bd.setResource(<span class="built_in">this</span>.readerContext.getResource());</span><br><span class="line">		bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> bd;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">		error(<span class="string">&quot;Bean class [&quot;</span> + className + <span class="string">&quot;] not found&quot;</span>, ele, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">		error(<span class="string">&quot;Class that bean class [&quot;</span> + className + <span class="string">&quot;] depends on not found&quot;</span>, ele, err);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		error(<span class="string">&quot;Unexpected failure during bean definition parsing&quot;</span>, ele, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先就拿到了 class 属性和 parent 属性的值，然后创建了一个 BeanDefinition。</p>
</li>
<li><p>解析 bean 标签的属性。</p>
</li>
<li><p>bean 标签的一系列子标签的解析，包括：</p>
<ol>
<li>description</li>
<li>meta</li>
<li>lookup-method</li>
<li>replaced-method</li>
<li>constructor-arg</li>
<li>property</li>
<li>qualifier</li>
</ol>
</li>
</ol>
<p>接下来，会逐步进行分析。</p>
<h4 id="创建-BeanDefinition"><a href="#创建-BeanDefinition" class="headerlink" title="创建 BeanDefinition"></a>创建 BeanDefinition</h4><p>对应 createBeanDefinition() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title function_">createBeanDefinition</span><span class="params">(<span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> String parentName)</span></span><br><span class="line">		<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">			parentName, className, <span class="built_in">this</span>.readerContext.getBeanClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>委托给了 BeanDefinitionReaderUtils 进行创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title function_">createBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="meta">@Nullable</span> String parentName, <span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">GenericBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">	bd.setParentName(parentName);</span><br><span class="line">	<span class="keyword">if</span> (className != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">			bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			bd.setBeanClassName(className);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时可以得到结论，那就是一开始创建的 BeanDefinition 都是 GenericBeanDefinition。</p>
<p>这里将 bean 对应的 Class 或者 ClassName 设置了进去。</p>
<h4 id="解析-bean-标签属性"><a href="#解析-bean-标签属性" class="headerlink" title="解析 bean 标签属性"></a>解析 bean 标签属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractBeanDefinition <span class="title function_">parseBeanDefinitionAttributes</span><span class="params">(Element ele, String beanName,</span></span><br><span class="line"><span class="params">		<span class="meta">@Nullable</span> BeanDefinition containingBean, AbstractBeanDefinition bd)</span> &#123;</span><br><span class="line">	<span class="comment">// singleton 属性已经过时，需要使用 scope 属性</span></span><br><span class="line">	<span class="keyword">if</span> (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123;</span><br><span class="line">		error(<span class="string">&quot;Old 1.x &#x27;singleton&#x27; attribute in use - upgrade to &#x27;scope&#x27; declaration&quot;</span>, ele);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123;</span><br><span class="line">		<span class="comment">// 如果有 scope 属性，就设置 scope</span></span><br><span class="line">		bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果没有 scope 属性，但是有父 bean，则使用父 bean 的 scope 值。</span></span><br><span class="line">		<span class="comment">// Take default from containing bean in case of an inner bean definition.</span></span><br><span class="line">		bd.setScope(containingBean.getScope());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123;</span><br><span class="line">		<span class="comment">// 设置是否为抽象，即不会实例化，而只是作为其他 bean 的父类，默认为 false</span></span><br><span class="line">		bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">lazyInit</span> <span class="operator">=</span> ele.getAttribute(LAZY_INIT_ATTRIBUTE);</span><br><span class="line">	<span class="keyword">if</span> (isDefaultValue(lazyInit)) &#123;</span><br><span class="line">		<span class="comment">// 是否懒加载，如果设置为 true，则 bean 将会在第一次使用到时由工厂初始化，默认为 false</span></span><br><span class="line">		lazyInit = <span class="built_in">this</span>.defaults.getLazyInit();</span><br><span class="line">	&#125;</span><br><span class="line">	bd.setLazyInit(TRUE_VALUE.equals(lazyInit));</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">autowire</span> <span class="operator">=</span> ele.getAttribute(AUTOWIRE_ATTRIBUTE);</span><br><span class="line">	<span class="comment">// 设置自动注入模式</span></span><br><span class="line">	bd.setAutowireMode(getAutowireMode(autowire));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置依赖的 bean 名称</span></span><br><span class="line">	<span class="keyword">if</span> (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">dependsOn</span> <span class="operator">=</span> ele.getAttribute(DEPENDS_ON_ATTRIBUTE);</span><br><span class="line">		bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">autowireCandidate</span> <span class="operator">=</span> ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);</span><br><span class="line">	<span class="keyword">if</span> (isDefaultValue(autowireCandidate)) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">candidatePattern</span> <span class="operator">=</span> <span class="built_in">this</span>.defaults.getAutowireCandidates();</span><br><span class="line">		<span class="keyword">if</span> (candidatePattern != <span class="literal">null</span>) &#123;</span><br><span class="line">			String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);</span><br><span class="line">			bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置 primary</span></span><br><span class="line">	<span class="keyword">if</span> (ele.hasAttribute(PRIMARY_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置初始化方法名</span></span><br><span class="line">	<span class="keyword">if</span> (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">initMethodName</span> <span class="operator">=</span> ele.getAttribute(INIT_METHOD_ATTRIBUTE);</span><br><span class="line">		bd.setInitMethodName(initMethodName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.defaults.getInitMethod() != <span class="literal">null</span>) &#123;</span><br><span class="line">		bd.setInitMethodName(<span class="built_in">this</span>.defaults.getInitMethod());</span><br><span class="line">		bd.setEnforceInitMethod(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置销毁 bean 的方法名</span></span><br><span class="line">	<span class="keyword">if</span> (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">destroyMethodName</span> <span class="operator">=</span> ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);</span><br><span class="line">		bd.setDestroyMethodName(destroyMethodName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.defaults.getDestroyMethod() != <span class="literal">null</span>) &#123;</span><br><span class="line">		bd.setDestroyMethodName(<span class="built_in">this</span>.defaults.getDestroyMethod());</span><br><span class="line">		bd.setEnforceDestroyMethod(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置工厂方法名称</span></span><br><span class="line">	<span class="keyword">if</span> (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置工厂 bean</span></span><br><span class="line">	<span class="keyword">if</span> (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段是对 <code>&lt;bean&gt;</code> 的各项属性进行解析，并放进 BeanDefinition 中，比较简单，不细说。</p>
<h4 id="解析-description-标签"><a href="#解析-description-标签" class="headerlink" title="解析 description 标签"></a>解析 description 标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getChildElementValueByTagName</span><span class="params">(Element ele, String childEleName)</span> &#123;</span><br><span class="line">	<span class="type">Element</span> <span class="variable">child</span> <span class="operator">=</span> getChildElementByTagName(ele, childEleName);</span><br><span class="line">	<span class="keyword">return</span> (child != <span class="literal">null</span> ? getTextValue(child) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title function_">getChildElementByTagName</span><span class="params">(Element ele, String childEleName)</span> &#123;</span><br><span class="line">	Assert.notNull(ele, <span class="string">&quot;Element must not be null&quot;</span>);</span><br><span class="line">	Assert.notNull(childEleName, <span class="string">&quot;Element name must not be null&quot;</span>);</span><br><span class="line">	<span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> ele.getChildNodes();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">		<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; nodeNameMatch(node, childEleName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> (Element) node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是找了一个 bean 标签下名为 <code>description</code> 的子标签，然后拿了标签中的值设置到了 BeanDefinition 中。</p>
<h4 id="解析-meta-标签"><a href="#解析-meta-标签" class="headerlink" title="解析 meta 标签"></a>解析 meta 标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMetaElements</span><span class="params">(Element ele, BeanMetadataAttributeAccessor attributeAccessor)</span> &#123;</span><br><span class="line">   <span class="comment">// ele 是 meta 的父标签</span></span><br><span class="line">	<span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> ele.getChildNodes();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">		<span class="comment">// 是 Spring 默认标签体系中的标签，且为 &lt;meta&gt; 标签</span></span><br><span class="line">		<span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">			<span class="type">Element</span> <span class="variable">metaElement</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">			<span class="comment">// 获取 key 属性</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> metaElement.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line">			<span class="comment">// 获取 value 属性</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> metaElement.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">			<span class="type">BeanMetadataAttribute</span> <span class="variable">attribute</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanMetadataAttribute</span>(key, value);</span><br><span class="line">			attribute.setSource(extractSource(metaElement));</span><br><span class="line">			attributeAccessor.addMetadataAttribute(attribute);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>meta 标签使用一般如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">&quot;priority&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后再对照上面的代码。</p>
<ol>
<li>ele 是 meta 的父标签，首先获取了 ele 的子标签的列表；</li>
<li>然后再进行遍历，遍历时，判断了是否是 meta 标签；</li>
<li>如果是 meta 标签，则获取 meta 标签的 key、value 属性，并构建一个 BeanMetadataAttribute，放到 BeanDefinition 中。</li>
</ol>
<p>需要注意的是，第 3 步说的是放到 BeanDefinition 中，但实际又是调用的 BeanMetadataAttributeAccessor 实例的方法，其实是因为前面构建的 GenericBeanDefinition 继承自 AbstractBeanDefinition，而 AbstractBeanDefinition 又实现了 BeanMetadataAttributeAccessor 接口。</p>
<pre><code class="highlight mermaid">classDiagram
direction BT
class AbstractBeanDefinition
class AttributeAccessorSupport
class BeanDefinition &#123;
&lt;&lt;Interface&gt;&gt;

&#125;
class BeanMetadataAttributeAccessor
class GenericBeanDefinition
class Serializable &#123;
&lt;&lt;Interface&gt;&gt;

&#125;

AbstractBeanDefinition  ..&gt;  BeanDefinition 
AbstractBeanDefinition  --&gt;  BeanMetadataAttributeAccessor 
AttributeAccessorSupport  ..&gt;  Serializable 
BeanMetadataAttributeAccessor  --&gt;  AttributeAccessorSupport 
GenericBeanDefinition  --&gt;  AbstractBeanDefinition 
</code></pre>

<p>BeanMetadataAttributeAccessor 提供的是访问 bean 元数据的能力，而最终实现时，其实就是将各种元数据记录了下来，就如同上面讲 meta 标签的 key、value 封装成一个 BeanMetadataAttribute 对象，然后放到了 BeanMetadataAttributeAccessor 中，换言之，对元数据的访问能力不是 BeanDefinition 接口提供的，而是 BeanMetadataAttributeAccessor 提供的。</p>
<h4 id="解析-lookup-method-标签"><a href="#解析-lookup-method-标签" class="headerlink" title="解析 lookup-method 标签"></a>解析 lookup-method 标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseLookupOverrideSubElements</span><span class="params">(Element beanEle, MethodOverrides overrides)</span> &#123;</span><br><span class="line">	<span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> beanEle.getChildNodes();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">		<span class="comment">// lookup-method 标签解析</span></span><br><span class="line">		<span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) &#123;</span><br><span class="line">			<span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">			<span class="comment">// lookup 的方法名</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">			<span class="comment">// lookup 返回的 bean</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">beanRef</span> <span class="operator">=</span> ele.getAttribute(BEAN_ELEMENT);</span><br><span class="line">			<span class="type">LookupOverride</span> <span class="variable">override</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LookupOverride</span>(methodName, beanRef);</span><br><span class="line">			override.setSource(extractSource(ele));</span><br><span class="line">			overrides.addOverride(override);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>lookup-method 平时用的比较少，也是查了资料才知道是干嘛的。</p>
</blockquote>
<p>lookup-mthod 一般用法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;overrideInheritedMethod&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.xml.OverrideOneMethodSubclass&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">&quot;getPrototypeDependency&quot;</span> <span class="attr">bean</span>=<span class="string">&quot;jenny&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面这样用，其实就是使得 overrideInheritedMethod 这个 bean 的 getPrototypeDependency 方法最终返回 jenny 这个 bean，意思是，哪怕 getPrototypeDependency 方法的实现逻辑上是构建了一个和 jenny 这个 bean 同类型的对象返回，但调用 overrideInheritedMethod 的 getPrototypeDependency 方法最终还是会返回 jenny 这个实例 bean。</p>
<blockquote>
<p>就有点强行修改 bean 方法的返回对象的意思。</p>
</blockquote>
<p>和解析 meta 标签类似，这里也是将 lookup-method 的key、value 封装之后，又放到了一个 BeaDefinition 的对象中，只不过依然不是调用的 BeanDefinition 接口的能力，而是 MethodOverrides 接口的能力，这个接口用来记录 bean 中的方法覆盖。</p>
<p>注意 lookup-method 对应的方法覆盖的记录使用的是 LookupOverride 对象。</p>
<pre><code class="highlight mermaid">classDiagram
direction BT
class BeanMetadataElement &#123;
&lt;&lt;Interface&gt;&gt;

&#125;
class LookupOverride
class MethodOverride
class ReplaceOverride

LookupOverride  --&gt;  MethodOverride 
MethodOverride  ..&gt;  BeanMetadataElement 
ReplaceOverride  --&gt;  MethodOverride 
</code></pre>

<p>然后就会发现它实现的是 MethodOverride 接口，而这个接口只有 LookupOverride、ReplaceOverride 两个实现类，接下里的 replaced-method 标签就和 ReplaceOverride 有关。</p>
<h4 id="解析-replaced-method-标签"><a href="#解析-replaced-method-标签" class="headerlink" title="解析 replaced-method 标签"></a>解析 replaced-method 标签</h4><p>replaced-method 标签和 lookup-method 标签类似，不过 replaced-method 标签的切入更加彻底。</p>
<p>一般使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;overrideOneMethodByAttribute&quot;</span> class=<span class="string">&quot;org.springframework.beans.factory.xml.OverrideOneMethod&quot;</span>&gt;</span><br><span class="line">	&lt;replaced-method name=<span class="string">&quot;replaceMe&quot;</span> replacer=<span class="string">&quot;reverseReplacer&quot;</span>&gt;&lt;/replaced-method&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;overrideOneMethodByElement&quot;</span> class=<span class="string">&quot;org.springframework.beans.factory.xml.OverrideOneMethod&quot;</span>&gt;</span><br><span class="line">	&lt;replaced-method name=<span class="string">&quot;replaceMe&quot;</span> replacer=<span class="string">&quot;reverseReplacer&quot;</span>&gt;</span><br><span class="line">		&lt;arg-type&gt;String&lt;/arg-type&gt;</span><br><span class="line">	&lt;/replaced-method&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>第一个 bean 中的 replaced-method 表示将 overrideOneMethodByAttribute 这个 bean 的 replaceMe 方法的实现直接替换成 reverseReplacer 中的方法，而对于 reverseReplacer 方法的要求是，必须实现 MethodReplacer 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodReplacer</span> &#123;</span><br><span class="line">	Object <span class="title function_">reimplement</span><span class="params">(Object obj, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解析-constructor-arg-标签"><a href="#解析-constructor-arg-标签" class="headerlink" title="解析 constructor-arg 标签"></a>解析 constructor-arg 标签</h4><p>constructor-arg 见名知意，这个标签是用来配置 bean 初始化时的构造函数参数的。</p>
<p>需要知道 constructor-arg 标签的用法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;parentWithMapInConstructor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.testfixture.beans.TestBean&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span> <span class="attr">...</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;Rob&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Sall&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;Juergen&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Eva&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;b&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>主要分两种方式，一种是直接指定 index 属性，以表明是配置的构造函数的第几个参数，另一种则是不指定 index，而制定参数名称、值等。</p>
<p>Spring 在解析时，也是分成了这两种情况进行解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseConstructorArgElement</span><span class="params">(Element ele, BeanDefinition bd)</span> &#123;</span><br><span class="line">	<span class="comment">// 参数索引下标</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">indexAttr</span> <span class="operator">=</span> ele.getAttribute(INDEX_ATTRIBUTE);</span><br><span class="line">	<span class="comment">// 参数类型</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">typeAttr</span> <span class="operator">=</span> ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">	<span class="comment">// 参数名</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">	<span class="comment">// 如果指定了 index</span></span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasLength(indexAttr)) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.parseInt(indexAttr);</span><br><span class="line">			<span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				error(<span class="string">&quot;&#x27;index&#x27; cannot be lower than 0&quot;</span>, ele);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">ConstructorArgumentEntry</span>(index));</span><br><span class="line">					<span class="comment">// 解析属性值对象</span></span><br><span class="line">					<span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> parsePropertyValue(ele, bd, <span class="literal">null</span>);</span><br><span class="line">					ConstructorArgumentValues.<span class="type">ValueHolder</span> <span class="variable">valueHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstructorArgumentValues</span>.ValueHolder(value);</span><br><span class="line">					<span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">						valueHolder.setType(typeAttr);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">						valueHolder.setName(nameAttr);</span><br><span class="line">					&#125;</span><br><span class="line">					valueHolder.setSource(extractSource(ele));</span><br><span class="line">					<span class="keyword">if</span> (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) &#123;</span><br><span class="line">						error(<span class="string">&quot;Ambiguous constructor-arg entries for index &quot;</span> + index, ele);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 将值记录到 BeanDefinition 的构造函数参数列表中</span></span><br><span class="line">						bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					<span class="built_in">this</span>.parseState.pop();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">			error(<span class="string">&quot;Attribute &#x27;index&#x27; of tag &#x27;constructor-arg&#x27; must be an integer&quot;</span>, ele);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 对于标签没有指定 index 的情况</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">ConstructorArgumentEntry</span>());</span><br><span class="line">			<span class="comment">// 解析标签中的值</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> parsePropertyValue(ele, bd, <span class="literal">null</span>);</span><br><span class="line">			ConstructorArgumentValues.<span class="type">ValueHolder</span> <span class="variable">valueHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstructorArgumentValues</span>.ValueHolder(value);</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">				valueHolder.setType(typeAttr);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">				valueHolder.setName(nameAttr);</span><br><span class="line">			&#125;</span><br><span class="line">			valueHolder.setSource(extractSource(ele));</span><br><span class="line">			bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.parseState.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先获取了标签的 index、type、name 三个属性，对于有 index 和没有 index 属性两种情况分开处理，可以看见有没有 index 属性，其实解析逻辑差别不大，只不过有 index 时，记录了 index 和参数值的对应关系。</p>
<p>不管有没有 index，都会调用 parsePropertyValue 方法解析出值，然后使用 ConstructorArgumentValues.ValueHolder 进行封装。</p>
<p>然后看看具体的参数值的解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">parsePropertyValue</span><span class="params">(Element ele, BeanDefinition bd, <span class="meta">@Nullable</span> String propertyName)</span> &#123;</span><br><span class="line">	<span class="comment">// 如果是解析 constructor-arg 标签，则不会传入 propertyName 参数，如果传了表示是解析的 property 标签</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">elementName</span> <span class="operator">=</span> (propertyName != <span class="literal">null</span> ?</span><br><span class="line">			<span class="string">&quot;&lt;property&gt; element for property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span> :</span><br><span class="line">			<span class="string">&quot;&lt;constructor-arg&gt; element&quot;</span>);</span><br><span class="line">	<span class="comment">// 获取子标签</span></span><br><span class="line">	<span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> ele.getChildNodes();</span><br><span class="line">	<span class="type">Element</span> <span class="variable">subElement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">		<span class="comment">// 除了 description、meta 子标签，其他子标签总数不能超过一个</span></span><br><span class="line">		<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;</span><br><span class="line">				!nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">			<span class="comment">// Child element is what we&#x27;re looking for.</span></span><br><span class="line">			<span class="keyword">if</span> (subElement != <span class="literal">null</span>) &#123;</span><br><span class="line">				error(elementName + <span class="string">&quot; must not contain more than one sub-element&quot;</span>, ele);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				subElement = (Element) node;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 是否有 ref 属性</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">hasRefAttribute</span> <span class="operator">=</span> ele.hasAttribute(REF_ATTRIBUTE);</span><br><span class="line">	<span class="comment">// 是否有 value 属性</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">hasValueAttribute</span> <span class="operator">=</span> ele.hasAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">	<span class="comment">// 不能同时有 ref 和 value 两个属性，这两个属性只有其中一个时不能有子节点</span></span><br><span class="line">	<span class="keyword">if</span> ((hasRefAttribute &amp;&amp; hasValueAttribute) ||</span><br><span class="line">			((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != <span class="literal">null</span>)) &#123;</span><br><span class="line">		error(elementName +</span><br><span class="line">				<span class="string">&quot; is only allowed to contain either &#x27;ref&#x27; attribute OR &#x27;value&#x27; attribute OR sub-element&quot;</span>, ele);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hasRefAttribute) &#123;</span><br><span class="line">		<span class="comment">// 获取 ref 属性值。有 ref 属性，一般是指向其他的 bean</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">refName</span> <span class="operator">=</span> ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">			error(elementName + <span class="string">&quot; contains empty &#x27;ref&#x27; attribute&quot;</span>, ele);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 先将这个 bean 的引用记录起来</span></span><br><span class="line">		<span class="type">RuntimeBeanReference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(refName);</span><br><span class="line">		ref.setSource(extractSource(ele));</span><br><span class="line">		<span class="keyword">return</span> ref;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (hasValueAttribute) &#123;</span><br><span class="line">		<span class="comment">// 创建一个 String 值</span></span><br><span class="line">		<span class="type">TypedStringValue</span> <span class="variable">valueHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypedStringValue</span>(ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">		valueHolder.setSource(extractSource(ele));</span><br><span class="line">		<span class="keyword">return</span> valueHolder;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (subElement != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 当 constructor-arg 标签没有 value、ref 属性时，又会有子标签</span></span><br><span class="line">		<span class="comment">// 开始解析子标签</span></span><br><span class="line">		<span class="keyword">return</span> parsePropertySubElement(subElement, bd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found.</span></span><br><span class="line">		error(elementName + <span class="string">&quot; must specify a ref or value&quot;</span>, ele);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先判断了 peopertyName 参数是否是 null，如果是 null 说明是解析的 constructor-arg 参数，不然就是 property 参数。</li>
</ol>
<blockquote>
<p>这里是框架的代码，到时情有可原，毕竟每个方法调用都是一次进出栈操作。如果是业务代码的话，个人不是很赞同这种实现方式，直接将 constructor-arg 和 property 标签的解析逻辑分开，公共部分抽一个方法就好了啊。</p>
</blockquote>
<ol start="2">
<li><p>遍历了所有子标签，需要保证 constructor-arg 标签的子标签除了 description 和 meta 标签之外，其他子标签最多只有一个。</p>
</li>
<li><p>解析标签。</p>
<p>如果 constructor-arg 标签有 ref 属性或 value 属性，则进行对应的封装，且 ref、value 属性只能有其中一个。</p>
<p>如果配置了 ref 属性，则封装成 RuntimeBeanReference，如果配置的是 value 属性，则封装成 TypedStringValue。</p>
<p>对于 ref、value 都未配置的情况，需要检查是否有既不是 description，又不是 meta 标签的子标签，如果没有，则报错，如果有，则解析子标签。</p>
</li>
</ol>
<p>解析子标签，和对 ref、value 两个属性的解析目的一致，都是为了得到构造函数的属性值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">parsePropertySubElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition bd, <span class="meta">@Nullable</span> String defaultValueType)</span> &#123;</span><br><span class="line">	<span class="comment">// 如果不是默认的命名空间的标签，则进行自定义标签解析</span></span><br><span class="line">	<span class="keyword">if</span> (!isDefaultNamespace(ele)) &#123;</span><br><span class="line">		<span class="keyword">return</span> parseNestedCustomElement(ele, bd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// 如果是 bean 标签，则递归调用解析 BeanDefinition</span></span><br><span class="line">		<span class="type">BeanDefinitionHolder</span> <span class="variable">nestedBd</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, bd);</span><br><span class="line">		<span class="keyword">if</span> (nestedBd != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 修饰 BeanDefinition</span></span><br><span class="line">			nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nestedBd;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, REF_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// 解析 ref 标签</span></span><br><span class="line">		<span class="comment">// 获取 ref 标签的 bean 属性</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">refName</span> <span class="operator">=</span> ele.getAttribute(BEAN_REF_ATTRIBUTE);</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">toParent</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">			<span class="comment">// A reference to the id of another bean in a parent context.</span></span><br><span class="line">			<span class="comment">// 如果没配置 bean 属性，则尝试从读取 parent 属性，然后从父 context 中获取 bean</span></span><br><span class="line">			refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);</span><br><span class="line">			toParent = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">				<span class="comment">// 如果 bean、parent 两个属性都没配置，报错</span></span><br><span class="line">				error(<span class="string">&quot;&#x27;bean&#x27; or &#x27;parent&#x27; is required for &lt;ref&gt; element&quot;</span>, ele);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 这里我理解是为了检查 bean 或者 parent 的值是空格的情况</span></span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">			error(<span class="string">&quot;&lt;ref&gt; element contains empty target attribute&quot;</span>, ele);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">RuntimeBeanReference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(refName, toParent);</span><br><span class="line">		ref.setSource(extractSource(ele));</span><br><span class="line">		<span class="keyword">return</span> ref;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// 解析 &lt;idref&gt; 标签</span></span><br><span class="line">		<span class="keyword">return</span> parseIdRefElement(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// 解析 value 标签</span></span><br><span class="line">		<span class="keyword">return</span> parseValueElement(ele, defaultValueType);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, NULL_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// It&#x27;s a distinguished null value. Let&#x27;s wrap it in a TypedStringValue</span></span><br><span class="line">		<span class="comment">// object in order to preserve the source location.</span></span><br><span class="line">		<span class="comment">// 用于占位的 null 值</span></span><br><span class="line">		<span class="type">TypedStringValue</span> <span class="variable">nullHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypedStringValue</span>(<span class="literal">null</span>);</span><br><span class="line">		nullHolder.setSource(extractSource(ele));</span><br><span class="line">		<span class="keyword">return</span> nullHolder;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// 解析 array 子标签</span></span><br><span class="line">		<span class="keyword">return</span> parseArrayElement(ele, bd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, LIST_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// 解析 list 标签，和 array 一样</span></span><br><span class="line">		<span class="keyword">return</span> parseListElement(ele, bd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, SET_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// 解析 set 标签</span></span><br><span class="line">		<span class="keyword">return</span> parseSetElement(ele, bd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, MAP_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// 解析 map 标签</span></span><br><span class="line">		<span class="keyword">return</span> parseMapElement(ele, bd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// 解析 props 标签, 这里是对 property 标签的支持</span></span><br><span class="line">		<span class="keyword">return</span> parsePropsElement(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		error(<span class="string">&quot;Unknown property sub-element: [&quot;</span> + ele.getNodeName() + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从解析子标签的逻辑上看，子标签可以是自定义标签，如果是自定义标签，就会调用自定义标签的解析逻辑。对于 spring 默认支持的标签有：</p>
<ul>
<li>ref</li>
<li>idref</li>
<li>value</li>
<li>null</li>
<li>array</li>
<li>list</li>
<li>set</li>
<li>map</li>
<li>props</li>
</ul>
<p>具体每个标签的解析就不展开了，其实也是比较简单的。</p>
<h4 id="解析-property-标签"><a href="#解析-property-标签" class="headerlink" title="解析 property 标签"></a>解析 property 标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parsePropertyElements</span><span class="params">(Element beanEle, BeanDefinition bd)</span> &#123;</span><br><span class="line">	<span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> beanEle.getChildNodes();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">		<span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;</span><br><span class="line">			parsePropertyElement((Element) node, bd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先遍历了 bean 标签的所有子标签，找到 property 标签，并调用 parsePropertyElement 方法进行解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parsePropertyElement</span><span class="params">(Element ele, BeanDefinition bd)</span> &#123;</span><br><span class="line">	<span class="comment">// 获取 property 的 name 属性</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasLength(propertyName)) &#123;</span><br><span class="line">		error(<span class="string">&quot;Tag &#x27;property&#x27; must have a &#x27;name&#x27; attribute&quot;</span>, ele);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">PropertyEntry</span>(propertyName));</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (bd.getPropertyValues().contains(propertyName)) &#123;</span><br><span class="line">			error(<span class="string">&quot;Multiple &#x27;property&#x27; definitions for property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span>, ele);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 解析属性值</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> parsePropertyValue(ele, bd, propertyName);</span><br><span class="line">		<span class="type">PropertyValue</span> <span class="variable">pv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyValue</span>(propertyName, val);</span><br><span class="line">		parseMetaElements(ele, pv);</span><br><span class="line">		pv.setSource(extractSource(ele));</span><br><span class="line">		bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先获取 property 标签的 name 属性，该属性必须配置且不能为空。</li>
<li>调用 parsePropertyValue 方法解析，这里和解析 constructor-arg 标签时使用的是同一个方法，不同的是这里将 propertyName 传了进去，但也只是用来打了错误日志而已，逻辑上没有区别。</li>
<li>得到 property 的值之后，封装为 PropertyValue 并放到 Beanefinition 中。</li>
</ol>
<h4 id="解析-qualifier-标签"><a href="#解析-qualifier-标签" class="headerlink" title="解析 qualifier 标签"></a>解析 qualifier 标签</h4><p>qualifier 标签和 @Qualifier 注解一样，用于根据 bean 名称指定要注入的 bean。</p>
<p>解析逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseQualifierElement</span><span class="params">(Element ele, AbstractBeanDefinition bd)</span> &#123;</span><br><span class="line">	<span class="comment">// 获取 qualifier 标签的 type 属性</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasLength(typeName)) &#123;</span><br><span class="line">		error(<span class="string">&quot;Tag &#x27;qualifier&#x27; must have a &#x27;type&#x27; attribute&quot;</span>, ele);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">QualifierEntry</span>(typeName));</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">AutowireCandidateQualifier</span> <span class="variable">qualifier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowireCandidateQualifier</span>(typeName);</span><br><span class="line">		qualifier.setSource(extractSource(ele));</span><br><span class="line">		<span class="comment">// 获取 value</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> ele.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasLength(value)) &#123;</span><br><span class="line">			qualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> ele.getChildNodes();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">			<span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) &#123;</span><br><span class="line">				<span class="type">Element</span> <span class="variable">attributeEle</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">				<span class="comment">// 获取 attribute 子标签的 key、value 属性</span></span><br><span class="line">				<span class="type">String</span> <span class="variable">attributeName</span> <span class="operator">=</span> attributeEle.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line">				<span class="type">String</span> <span class="variable">attributeValue</span> <span class="operator">=</span> attributeEle.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">				<span class="keyword">if</span> (StringUtils.hasLength(attributeName) &amp;&amp; StringUtils.hasLength(attributeValue)) &#123;</span><br><span class="line">					<span class="type">BeanMetadataAttribute</span> <span class="variable">attribute</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanMetadataAttribute</span>(attributeName, attributeValue);</span><br><span class="line">					attribute.setSource(extractSource(attributeEle));</span><br><span class="line">					qualifier.addMetadataAttribute(attribute);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					error(<span class="string">&quot;Qualifier &#x27;attribute&#x27; tag must have a &#x27;name&#x27; and &#x27;value&#x27;&quot;</span>, attributeEle);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bd.addQualifier(qualifier);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Qualifier 标签解析后，得到 AutowiredCandidateQualifier 对象，并通过  AbstractBeanDefinition.addQualifier 方法放到 BeanDefinition 中。</p>
<ol>
<li><p>首先检查了 type 属性，该属性必须配置，且不能为空。</p>
</li>
<li><p>获取 value 属性值，如果值不为空，则将 AutowiredCandidateQualifier 的 value 设置为标签的 value 值。</p>
</li>
<li><p>解析 attribute 子标签。</p>
<p>attribute 子标签有 key、value 属性，两个属性都是必填项，解析后封装成 BeanMetadataAttribute 对象，并通过 AutowiredCandidateQualifier 的 addMetadataAttribute 方法放到 AutowiredCandidateQualifier 中。</p>
</li>
</ol>
<p>到这里，BeanDefinition 的解析基本就结束了，下一篇将讲解自定义标签的解析。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag"># Spring源码解析</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/1a1a583d59ee" rel="prev" title="Spring源码解析：资源加载">
                  <i class="fa fa-chevron-left"></i> Spring源码解析：资源加载
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/163184d50150" rel="next" title="Spring源码解析：自定义标签">
                  Spring源码解析：自定义标签 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">渝ICP备2021012299号-1 </a>
      <img src="/img/icp.png" alt=""><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=%E6%B8%9D%E5%85%AC%E7%BD%91%E5%AE%89%E5%A4%87%2050023402000631%E5%8F%B7" rel="noopener" target="_blank">渝公网安备 50023402000631号 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">假隐士</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">450k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:49</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.6/mermaid.min.js","integrity":"sha256-ZfzwelSToHk5YAcr9wbXAmWgyn9Jyq08fSLrLhZE89w="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  





</body>
</html>
