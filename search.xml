<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Flink 入门：Flink 架构</title>
      <link href="posts/41f5515b7292.html"/>
      <url>posts/41f5515b7292.html</url>
      
        <content type="html"><![CDATA[<p>在学习过程中，我一直在寻找一个答案，为什么要使用 Flink？如果没有 Flink，现在的软件系统就构建不起来了吗？</p><h2 id="Flink-简介"><a href="#Flink-简介" class="headerlink" title="Flink 简介"></a>Flink 简介</h2><p>正如官网所说，Flink 是一个支持在有界、无界数据流上进行有状态计算的实时流式处理引擎。</p><ul><li>有界：可以理解为数据流是有尽头的，比如要处理去年一整年的数据，那肯定是有界，是能知道什么时候处理完所有数据的。</li><li>无界：可以理解为数据流是没有尽头的，比如要处理某个线上系统的时时刻刻发生的事件，事件时刻都在发生，所以是不知道什么时候能处理完成的。</li><li>状态：比如 http 协议，我们知道它是一个无状态的协议，所以多个请求之间没法互相关联，每个请求无法知道上一个请求的内容，所以才有了 Cookie、Session 等解决方案。同样，在流处理中，如果我们想要做一些窗口处理的话，相当于是要将多个接收到的消息放到一起处理，就像是 http 中发出的每个请求，而状态，就是 Cookie、Session 了，它能存储多个消息处理后的结果，在后续消息到达时还能被更新。状态对于很多需要做一些聚合操作的场景是非常有用的。</li></ul><p>基于以上的特性，Flink 能够在一些实时告警系统，比如一些反欺诈告警，还可以在一些事件驱动系统中使用，因为其实所谓事件，对 Flink 来说其实就是一个消息而已。</p><h2 id="为什么需要-Flink？"><a href="#为什么需要-Flink？" class="headerlink" title="为什么需要 Flink？"></a>为什么需要 Flink？</h2><p>前面简单介绍了 Flink，好像知道了它能干啥，但是为什么就必须用 Flink 呢？这里我其实是有两个疑问：</p><ol><li>不用这些流处理引擎，我自己按现在的传统的后端系统架构好像也能做这个事，为啥非要用这些流处理引擎呢？</li><li>除了 Flink，就没有其他的工具或者中间件能做这个事？</li></ol><h3 id="为什么需要流式引擎？"><a href="#为什么需要流式引擎？" class="headerlink" title="为什么需要流式引擎？"></a>为什么需要流式引擎？</h3><p>诚然，当我们遇见一个需要进行实时的数据处理的需求时，完全可以新建设一个满足这个需求的系统，但是当这种要求实时处理的需求越来越多时，这个系统将会面临修改，面临性能问题，这也就意味着需要有足够的扩展性，需要有足够的性能，而当你开发出这样一个系统的时候，有没有一种可能，其实你开发出的是一个类似 Flink 的一个系统？那为何不直接用 Flink，偏偏要自己造轮子呢。</p><p>其实我的意思是，如果你只是有那么几个场景，几个需求需要进行像 Flink 这样的计算，那可以考虑不用 Flink，自己简单实现一下就行了，也不用过多考虑什么设计上的扩展性，但是如果这样的需求特别多的话，就需要考虑是否需要一个专业的流式处理引擎来做这件事了。</p><h3 id="为什么选择-Flink？"><a href="#为什么选择-Flink？" class="headerlink" title="为什么选择 Flink？"></a>为什么选择 Flink？</h3><p>首先我们需要知道两个概念：批处理、流处理。</p><p>批处理，其实就是对一个既定的数据集合做处理，比如处理上个月的交易数据，上个月的交易数据肯定是已经稳定不变的了，完全可以一个定时任务就完成所有事。</p><p>流处理，流处理和批处理不一样，批处理其实是完全知道会处理一些什么样的数据的，而且数据都已经准备好了，但是流处理是不知道数据什么时候到达，不知道数据是否已经全部到达的，甚至大部分时候要处理的数据一直在源源不断的产生。</p><p>如果听过了 Flink，那肯定会知道还有一个开源项目叫做 Spark，现在我们从数据处理的历史发展说起，探寻选择 Flink 的原因。</p><p>最开始的大批量数据处理，都是采用 MapReduce 进行处理，而且也只能处理存在 HDFS 上的存量数据，也就是只能进行批处理，不仅如此，MapReduce 的处理每个环节都会将处理后的数据写到 HDFS，而下一个环节又将这些数据读出来，处理完成后，又写入到 HDFS 中，但是实际上，中间过程产生的数据，其实是对业务无用的，一方面占用了磁盘，另一方面还因为数据的 IO 导致拉低了性能。</p><p>后来，又有了新一代的处理引擎 Spark，一方面，每个处理环节不在讲结果写入磁盘，而是放在内存中交给下一个环节进行处理，这弥补了 MapReduce 的缺陷；另一方面，它还通过微批的方式，宣称支持流处理，微批其实也是一种批处理，只不过是将一小部分到达的事件作为一个批次进行处理，所以叫做微批（micro batch），但是对于真正的流处理来说，Spark 的微批因为本质上还是批处理，所以还是存在一定的延迟，且当吞吐量持续上涨时，延迟也会一直增长，这是不能接受的。</p><p>在 Spark 之后，终于又迎来了 Flink 的时代，它和 Spark 一样是一个流批一体的处理引擎，且真正支持了流处理，而不是通过微批支持，所以哪怕吞吐量越来越大，也不会因为吞吐量的增长而影响延迟。</p><p>另外，Flink 作为一个现代的流处理引擎，在生态上，数据输入支持了主流的中间件，可以从 MySQL 等存储中获取数据，还可以直接从 kafka 消费实时数据，而数据输出也是支持了很多主流的存储、中间件，官方基本都有相应的开源工具做支持；在可扩展性上，得益于 Flink 的架构设计，它可以直接进行横向的扩缩容。</p><p>总结一下，选择 Flink 的原因如下：</p><ul><li>活跃的开源社区，完整的生态。</li><li>高可扩展性。</li><li>真正的流批一体。</li></ul><h2 id="Flink-架构"><a href="#Flink-架构" class="headerlink" title="Flink 架构"></a>Flink 架构</h2><p>上文说到，Flink 的架构设计保证了 Flink 能够直接进行扩缩容，可能是因为它和一些传统应用的中间的场景不同，所以架构也是有些别致。</p><p>Flink 的部署架构上，为 Job Manager、Task Manager、Client 3 个组件，所以 Flink 采用的是类似 Master-Slave 的模式。</p><ul><li><p>Client</p><p>因为 Flink 的使用方式一般是将写好的 Flink 程序打包后，上传到 Flink 集群，由 Client 解析成逻辑执行图，将这个应用程序当成一个 Job 提交到 Job Manager。</p></li><li><p>Job Manager</p><p>Job Manager 将逻辑执行图解析成物理执行图，一个 Job 就会变成多个 Task，然后将这些 Task 交给 Task Manager 执行，Job Manager 主要职责是协调 checkpoint、协调 Task Manager 故障转移、Task 调度等。</p><p>Job Manager 实例上还分为 Dispatcher、Job Master、Resource Manager 3 个组件。</p><ul><li><p>Dispatcher</p><p>提供了一系列 REST 接口，用于接收客户端提交的 Job，并启动一个新的 Job Master 给新的 Job，当然还有一些其他的各种查询状态的接口也在这里。</p></li><li><p>Job Master</p><p>用于管理有个 Job，Job Manager 上可以同时运行多个 Job，但是每个 Job 都有自己的 Job Master。</p></li><li><p>Resource Manager</p><p>用于管理、分配 Flink 集群的计算资源。主要就是管理 task slots，这个在 Task Manager 中详细说明。Flink 实现了多个 Resource Manager，使得 Flink 集群可以部署在 Kubernetes、Yarn 上，还可以直接单机部署，但是因为单机部署的话，task slots 其实在启动时就确定了，这种模式下，Resource Manager 是没办法新启动一个 Task Manager 的。</p></li></ul></li><li><p>Task Manager</p><p>Task Manager 主要是执行由 Job Manager 分配的 Task。一个 Flink 集群中至少要有一个 Task Manager。每个 Task Manager 上可以有多个 task slots，task slots 代表着这个 Task Manager 可以并行处理的任务数。如果 task slots 是 3，那代表这个 Task Manager 实例可以同时处理 3 个任务。也代表着每个 task 最多占用 Task Manager 1/3 的内存，同一个 Task Manager 中，task 之间只会隔离内存，而不会隔离 CPU、网络等资源。</p></li></ul><h3 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h3><p>Flink 应用程序会衍生出一个或多个 Job，而 Job 可以在本地环境或者一个远程环境运行，远程环境还可以是一个集群环境。根据任务的生命周期不同，可以选择不同的部署方式。</p><h4 id="session-模式"><a href="#session-模式" class="headerlink" title="session 模式"></a>session 模式</h4><ul><li><p>集群生命周期</p><p>session 模式下的 Flink 集群，是在运行 Job 之前就已经准备好了 Job Manager、Task Manager，当集群上的 Job 运行完成后，集群依然还是保持运行，等待新的 Job 到来。换句话说，集群的生命周期和 Job 的生命周期并不相关。</p></li><li><p>资源隔离</p><p>所有 Job 共享同一个集群，也就意味着会有一些资源竞争，比如网络带宽。同样也是因为共享集群，所以当某个 Task Manager 实例故障时，会影响在上面运行的所有 task；但是如果是集群的 Job Manager 故障，那么将会影响所有在集群上运行的 Job。</p></li></ul><p>基于 session 模式的特性，如果很多任务本身执行的时间是特别短的，甚至相对于集群的启动时长来说都比较短，那么可以考虑一 session 方式部署。</p><p>在这个模式下，还是需要由 Client 执行 main() 方法，解析出执行图，准备好依赖，然后将执行图和依赖上传到 Job Manager，但是如果提交的 Job 比较多的话，首先在 Client 这里就会阻塞住，因为上传依赖是比较耗时的。</p><h4 id="application-模式"><a href="#application-模式" class="headerlink" title="application 模式"></a>application 模式</h4><ul><li><p>集群生命周期</p><p>application 模式的集群是给某个 Flink 应用程序专用的集群，换句话说，每一个提交的 Flink 应用程序，都会单独分配一套完整的 Flink 集群，包括 Job Manager、Task Manager 等。这意味着得将 Flink 部署在类似 k8s 这样的环境下。</p><p>application 模式下的集群的生命周期和 Flink 应用程序关联，当 Flink 应用程序执行完成后，集群资源也将会释放。</p><p>需要知道的是，一个 Flink 应用程序是可以提交多个 Job 的，也就意味着，同一个 Flink 应用程序提交的所有 Job 会共享一个集群。</p><p>另外，application 模式下，main() 方法的调用是在 Job Manager 上执行。</p></li><li><p>资源隔离</p><p>站在 Job 的角度看，集群的资源隔离粒度比 session 模式下更细腻，做到了在每个 Flink 应用级别的资源隔离，其他的区别不大。</p><p>故障也只影响当前这个 Flink 应用所提交的 Job。</p></li></ul><h4 id="per-job-模式"><a href="#per-job-模式" class="headerlink" title="per-job 模式"></a>per-job 模式</h4><p>也叫 job 模式。</p><p>在 Flink 1.15 时，这种模式被置为过时，官方建议以 application 模式代替。</p><ul><li><p>集群生命周期</p><p>在 per-job 模式中，会为每个提交的 job 启动一个集群。首先客户端会请求集群管理器创建 Job Manager，然后将 Job 提交到 Job Manager，Job Manager 再惰性分配运行 Job 需要的计算资源。</p><p>当 Job 运行完之后，集群将被销毁，资源被回收。</p></li><li><p>资源隔离</p><p>因为是为每个 Job 单独启动的集群，所以集群故障也只会影响一个 Job。</p></li></ul><p>因为需要等待分配 Task Manager 资源，所以 per-job 模式更适合运行长时间运行着的任务，即对启动时间并不敏感的任务。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先我们介绍了 Flink 用途，然后解释了为什么需要流式引擎，为什么选择 Flink，最后我们介绍了 Flink 的部署架构。</p><p>这里再下节一下 3 种部署架构的区别：</p><ul><li>per-job 模式的资源隔离是在 Job 维度，而 application 模式的资源隔离则是在 Flink 应用程序级别，session 则是基本算是没有资源隔离，application 模式算是一种另类的 session 模式。</li><li>在 session、per-job 模式下，Client 需要下载 Flink 程序的依赖、执行 main() 方法解析执行图、上传执行图和依赖到集群。</li><li>在 application 模式下，Client 则是直接将 Flink 程序提交到集群中，由 Job Manager 做依赖下载、调用 main()方法解析执行图，因为已经在 Job Manager 上运行，所以不存在上传执行图和依赖这一步。</li><li>相比之下，application 节省了 Client 上传依赖、执行图的带宽，使 Client 变得轻量级。</li><li>application 模式下，因为是在 Job Manager 上下载依赖，所以需要保证依赖所在服务和 Flink 集群的网络是通的。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.macrometa.com/event-stream-processing/spark-vs-flink">Apache Spark Vs Flink</a></li><li><a href="https://flink.apache.org/2020/07/14/application-deployment-in-flink-current-state-and-the-new-application-mode/">Application Deployment in Flink: Current State and the new Application Mode</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust入门:HashMap</title>
      <link href="posts/724cafce7568.html"/>
      <url>posts/724cafce7568.html</url>
      
        <content type="html"><![CDATA[<p>在编程开发时，实在是避免不了要使用 key-value 这种键值对形式的数据结构。本文将简单介绍一下 Rust 中的 HashMap 的使用。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>直接通过 <code>HashMap::new()</code> 方法调用就能创建一个 HashMap，不过使用 HashMap 需要额外通过 <code>use</code> 关键字将 HashMap 引入：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;len=&#123;&#125;,cap=&#123;&#125;,vals:&#123;:?&#125;&quot;</span>, scores.<span class="title function_ invoke__">len</span>(), scores.<span class="title function_ invoke__">capacity</span>(), scores);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Red&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Green&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Black&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;len=&#123;&#125;,cap=&#123;&#125;,vals:&#123;:?&#125;&quot;</span>, scores.<span class="title function_ invoke__">len</span>(), scores.<span class="title function_ invoke__">capacity</span>(), scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len=4,cap=7,vals:&#123;&quot;Red&quot;: 10, &quot;Blue&quot;: 10, &quot;Black&quot;: 10, &quot;Green&quot;: 10&#125;</span><br></pre></td></tr></table></figure><p>如果在创建 HashMap 之前就知道了这个 Map 所需要的容量大小，可以使用 <code>with_capacity()</code> 方法来初始化一个 HashMap 实例。</p><h2 id="访问-HashMap-的数据"><a href="#访问-HashMap-的数据" class="headerlink" title="访问 HashMap 的数据"></a>访问 HashMap 的数据</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Red&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Green&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Black&quot;</span>), <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(<span class="string">&quot;White&quot;</span>).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The black score is &#123;score&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接通过 <code>get()</code> 方法来读取 HashMap 中的数据，方法的参数是一个 map 中 key 的类型的引用，返回的是一个 <code>Option&lt;T&gt;</code>。如果传入的 key 在 map 中存在，则返回一个 <code>Some&lt;T&gt;</code>，如果不存在自然是返回一个 <code>None</code>。</p><p>而后面的 <code>unwrap_or</code> 方法则是在 map 中不存在指定的 key 时，返回一个默认值，这里的默认值设置为 0。</p><p>这里还需要考虑一下当要写入到 HashMap 的 key 已经存在的情况。</p><p>对于 insert 方法，是直接新值覆盖旧值。</p><p>而如果插入的 key 已经存在就保留旧值的话，就使用 entry + or_insert 方法组合实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Green&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Black&quot;</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;White&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的 scorce 的数据像下面这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Green&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;White&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Black&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="修改-HashMap-中的数据"><a href="#修改-HashMap-中的数据" class="headerlink" title="修改 HashMap 中的数据"></a>修改 HashMap 中的数据</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(item).<span class="title function_ invoke__">or_insert</span>(<span class="number">1</span>);</span><br><span class="line">        *count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是统计每个单词出现的次数，统计结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;world&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;wonderful&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hello&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以通过 <code>map.entry(item).or_insert(0)</code>，当 item 对应的数据不存在时，就写入 0，存在则会返回 item 对应的值的引用，所以 <code>*count += 1</code> 也就相当于直接修改了 item 对应的值。</p><h2 id="关于所有权"><a href="#关于所有权" class="headerlink" title="关于所有权"></a>关于所有权</h2><p>需要知道的是，对于实现了 Copy trait 的类型，不管是作为 map 中的 key 还是 value，insert 时都是复制的一份值，所以不存在所有权的转移。</p><p>而如果是 String 或者其他的未实现 Copy trait 的类型，当 insert 之后，所有权便归 map 所有。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Favorite color&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_value</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(field_name, field_value);</span><br><span class="line"><span class="comment">// field_name 和 field_value 在这里已经是无效的变量了</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://doc.rust-lang.org/book/ch08-03-hash-maps.html">https://doc.rust-lang.org/book/ch08-03-hash-maps.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust入门:Vector</title>
      <link href="posts/e38c64135fbb.html"/>
      <url>posts/e38c64135fbb.html</url>
      
        <content type="html"><![CDATA[<p>Vector 只能存储相同数据类型的数据。和数组的区别在于，Vector 有自动扩容机制，对于运行时用来存储一个列表更加友好，因为运行时更多的是不确定一个数据集合的长度的。</p><p>本文将介绍 Vector 常见的用法，并且还会简单讲一下 Vector 的一些原理。</p><h2 id="创建一个-Vector"><a href="#创建一个-Vector" class="headerlink" title="创建一个 Vector"></a>创建一个 Vector</h2><p>通常情况下，创建 Vector 有两种方式：一种是直接调用 Vec 结构体的 <code>new</code> 方法创建一个 Vector 实例；一种是使用 <code>vec!</code> 宏。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(); <span class="comment">// 第一种方式</span></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">// 第二种方式</span></span><br></pre></td></tr></table></figure><p>会发现这里并没有指定 Vector 中的元素数据类型，在这种情况下，Rust 会自动探测它的类型。</p><p>我们查看 Vec 结构体的代码，能发现 Vector 还使用了一种叫作泛型的技术：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Vec</span>&lt;T, <span class="meta">#[unstable(feature = <span class="string">&quot;allocator_api&quot;</span>, issue = <span class="string">&quot;32838&quot;</span>)]</span> A: Allocator = Global&gt; &#123;</span><br><span class="line">    buf: RawVec&lt;T, A&gt;,</span><br><span class="line">    len: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看见 Vec 结构体的定义种有类似 <code>&lt;T&gt;</code> 的字样，说明使用了泛型，这个以后会讲到，这里只是提一下。</p><p>很多时候，可能即使在运行时，我们依然可以提前动态计算出接下来要创建的 Vector 的元素个数，此时我们还可以通过 <code>Vec::with_capacity(capacity: usize)</code> 方法来创建一个指定了 capacity 的 Vector。</p><p>而使用 <code>vec!</code> 宏的话，同样也有 <code>vec![x;n]</code> 这样的语法来创建一个 capacity 为 n 的 Vector，并且会把所有元素都初始化为 x。</p><p>不管那种，这种指定 capacity 的方式创建 Vector 依然还是具体自动扩容（后面原理浅析小节中讨论）的机制，而指定 capacity 只是为了避免不必要的扩容而已，算是一个使用时的小优化。</p><h2 id="向-Vector-中增加元素"><a href="#向-Vector-中增加元素" class="headerlink" title="向 Vector 中增加元素"></a>向 Vector 中增加元素</h2><p>如前面的代码所见，其实一般情况下直接调用 <code>push</code> 方法即可。</p><h2 id="访问-Vector-中的数据"><a href="#访问-Vector-中的数据" class="headerlink" title="访问 Vector 中的数据"></a>访问 Vector 中的数据</h2><p>和其他编程语言一样，在 Vector 中也有 index 概念，同样也是从 0 开始，通过 index 访问 Vector 数据时，有下面两种方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = v.<span class="title function_ invoke__">get</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><code>&amp;v[1]</code> 这种方式，返回的就是 v 中 index 为 1 的数据引用，如果传入的 index 超过了这个 v 的最大 index，就会有一个 panic 结束掉程序运行。</p><blockquote><p> 对照 Java 中也就是数组越界异常。</p></blockquote><p>而 <code>v.get(1)</code> 这种形式则是返回一个 <code>Option&lt;T&gt;</code>，其中 T 是 Vector 中的数据类型，如果传入的 index 过大，这个 Option 返回值就是 None，否则就是 <code>Some&lt;T&gt;</code> 这样就不会直接 panic。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;i&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 for 循环语句中，使用的是 <code>&amp;v</code> 而不是 <code>v</code>，这里的 i 是 v 中元素的<strong>不可变引用</strong>，并未发生所有权转移，如果我们把 <code>&amp;</code> 删掉，会发现循环完之后，v 这个变量就没法访问了。</p><p>如果想在循环的时候修改 v 中元素的值，自然要将 i 变成可变引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 而这里因为 i 是引用，所以需要通过 <code>*</code> 操作符拿到真实的值之后再进行操作。</p><h2 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h2><p>首先，需要知道的是，Vector 的数据结构，只包含了 3 个东西：</p><ul><li>len，当前 Vector 中存储数据个数。</li><li>cap，当前 Vector 的容量 capacity。</li><li>ptr，指向堆上内存的指针。</li></ul><p>ptr 指向堆上内存，意味着 Vector 中的元素是存在堆上的，尽管像 i32 这种类型的长度是固定的，但是在 vector 中依然是在堆上分配一块内存进行存储。</p><p><code>Vec::new()</code> 会创建一个 capacity 和 length 都是 0 的 Vector，这意味着在执行完这个调用之后，其实还没有在堆上分配内存。</p><blockquote><p>这个和 Java 很不一样，Java 种创建一个 ArrayList 都会有默认 capacity，同时会创建一个长度为 capacity 的数组，所以在 new 的时候就会发生内存分配。</p></blockquote><p>官方文档也提到，只有当 <code>capacity * mem::size_if::&lt;T&gt;() &gt; 0</code> 时才会在堆上分配内存。</p><p>在前面提到了在 Vector 中有 len 和 cap 两个属性，这两个是不一定相等的，始终会保证 <code>cap &gt;= len</code>，而扩容的条件就是 push 时发现 <code>cap == len</code>，扩容后，capacity 等于第一个比原来的 capacity 大的 2 的 n 次幂，比如原来 capacity 是 5，那么扩容后变成了 8。 </p><p>因为 Vector 本身是要分配一块连续的内存，所以扩容时，还需要移动现有的元素到新的内存地址，这就以为者，当 vector 有一个引用还存在于当前上下文时，如果调用了 push 这种可能会引发扩容操作的方法，会导致编译失败，不然的话，可能会导致之前的引用指向的内存地址的数据无效。</p><p>更进一步，向 Vector 中不断 push 元素会引发扩容，但是如果将一个很大的 Vector 中的元素一个一个删除，并不会自动缩小容量来释放内存。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://doc.rust-lang.org/book/ch08-01-vectors.html">https://doc.rust-lang.org/book/ch08-01-vectors.html</a></li><li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">https://doc.rust-lang.org/std/vec/struct.Vec.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust入门:Package、Crate、Module</title>
      <link href="posts/20266b4cd80d.html"/>
      <url>posts/20266b4cd80d.html</url>
      
        <content type="html"><![CDATA[<h2 id="crate"><a href="#crate" class="headerlink" title="crate"></a>crate</h2><p>在 Rust 里面，crate 是最小的可编译单元。crate 分为两种，一种是二进制 crate，一种是库 crate。</p><p>二进制 crate 是可以编译得到一个可执行文件的，换句话说，它一定有一个 main 函数。库 crate 则不能编译成一个可执行文件，但是它定义的函数可以暴露给第三方使用。</p><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>package 是由一个或多个 crate 组成，提供一个完整的功能。一个 package 会包含 Cargo.toml 文件，一个 Package 里面可以包含多个库 crate，但是最多只能包含一个二进制 crate，并且，每个 pakcage 必须包含一个 crate。</p><blockquote><p>这里的 package 可以认为就是一个项目了。Rust 中取名字确实和其他语言很不一样。</p></blockquote><p>当通过 <code>cargo new </code> 创建一个 rust 项目之后，项目会有一个 Cargo.toml 文件，说明这是是一个 package，在 <code>src</code> 下面还有一个 <code>main.rs</code>，但是在 Cargo.toml 文件中并没有提到这个文件，这是因为，二进制了 crate 的根，就是 main.rs，而这个 crate 和 package 同名，而库 crate 的根则是 <code>lib.rs</code>。</p><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>Rust 官方文档对模块系统进行了总结：</p><blockquote><ol><li>总是从 crate 跟开始。当编译一个 crate 时，首先会去寻找 crate 的根，如果是二进制 crate，根文件为 src/main.rs，如果是库 crate，根文件为 src/lib.rs。</li><li>在 crate 的根文件里面，你可以定义一个 module，比如你要定义一个 garden module，可以通过 <code>mod garden;</code> 来定义，编译器会尝试在以下位置去寻找 garden 模块的代码：<ol><li>在 <code>mod garden</code> 后面的大括号中寻找代码，此时语句结尾不是分号，而是大括号。</li><li>在 <code>src/garden.rs</code> 文件中寻找。</li><li>在 <code>src/garden/mod.rs</code> 中。</li></ol></li><li>在除了 crate 根的其他文件中，还可以定义子 module。比如在 garden 中中定义一个子 module： <code>mod vegetables;</code>。编译器会尝试在父 module 中的以下位置去寻找 vegetables module 的代码：<ol><li>在 <code>mod vegetables</code> 后的大括号中寻找。</li><li>在 <code>src/garden/vegetables.rs</code> 文件中寻找。</li><li>在 <code>src/garden/vegetables/mod.rs</code> 文件中寻找。</li></ol></li><li>module 的代码路径。在 crate 中的一个 module，只要规则允许，你可以在 crate 的任何地方引用它。比如一个 <code>Asparagus</code> 类型在  garden 的 vegetables 模块中，那么它的路径是：<code>crate::garden::vegetables::Asparagus</code>。</li><li>private 和 public。默认情况下，module 中的代码是私有的，如果要让它公开，则需要通过 <code>pub mod</code> 来定义 module。但是 module 内部的定义依然还是私有的，同样也需要在定义语句前面加上 <code>pub</code> 关键字。</li><li><code>use</code> 关键字。你可以通过 <code>use crate::garden::vegetables::Asparagus</code> 来引入 Asparagus，在使用时，也只需要写 <code>Asparagus</code> 而不用写前面的一长串。</li></ol></blockquote><p>接下来，举个例子来理解一下，一个餐厅一般都有前台、后台，前台是顾客所在，其余的都在后台。接下来我们我们创建一个库 crate 来建立餐厅的模型。</p><h3 id="一个-module-的例子"><a href="#一个-module-的例子" class="headerlink" title="一个 module 的例子"></a>一个 module 的例子</h3><p>首先，通过 cargo 创建一个库类型的项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new restaurant --lib</span><br></pre></td></tr></table></figure><p>这里比之前多了一个 <code>--lib</code> 参数，因为 <code>cargo new</code> 默认创建的是二进制类型 crate，加了 <code>--lib</code> 参数就是告诉 cargo 要创建的是一个库类型的 crate。</p><p>然后就能发现在 restaurant 中没有 main.rs，而是有一个 lib.rs。</p><p>然后，在 lib.rs 中，我们不再写 main 函数，取而代之，我们定义一个 front_of_house 的模块。</p><p>文件名：src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">  <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">mod</span> serving &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">server_order</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回忆一下前面讲到编译器会如何寻找模块相应的实现代码，我们知道：这里定义的一个 front_of_house 模块，内部又有 hosting、serving 两个子模块。</p><p>不过这里寻找每个模块的实现都是直接从 <code>mod &lt;module_name&gt;</code> 后面的大括号中找到的。</p><p>这就像一个文件目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line">front_of_house</span><br><span class="line">hosting</span><br><span class="line">add_to_waitlist</span><br><span class="line">seat_at_table</span><br><span class="line">serving</span><br><span class="line">take_order</span><br><span class="line">server_order</span><br><span class="line">take_payment</span><br></pre></td></tr></table></figure><p>接下来的内容，会以这个示例展开。</p><h3 id="module-引用路径"><a href="#module-引用路径" class="headerlink" title="module 引用路径"></a>module 引用路径</h3><p>在 Rust 中，要调用函数时，首先要知道要调用的函数的路径，在 rust 中，路径有两种形式：</p><ol><li>绝对路径，是从 crate 的根开始。如果是外部的 crate，则是从 crate 的名称开始，如果是内部的 crate，则是从 <code>crate</code> 关键字开始。</li><li>相对路径，是在当前 module 中使用，从 self、super 关键字或者在当前 module 中的名称开始。</li></ol><p>而不管是那种路径，各层级之间都是通过 <code>::</code> 分隔。</p><p>比如现在，在 lib.rs 中调用 add_to_waitlist 函数：</p><p>文件：src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">  <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">mod</span> serving &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">server_order</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">  <span class="comment">// 绝对路径</span></span><br><span class="line">  crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">  <span class="comment">// 相对路径</span></span><br><span class="line">  front_of_hosue::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>选择相对路径还是绝对路径，取决于你的项目是否会将定义 crate 的代码和使用这个 crate 的代码一起移动，如果会一起移动，那么意味着相对路径不会变，那可以考虑使用相对路径，如果不会一起移动，那么也就意味着相对路径会变化，那就建议使用绝对路径，这样能保证在移动 crate 时需要改动的代码更少。</p></blockquote><p>然后，上面的代码，编译一下会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ cargo check                                                              </span><br><span class="line">    Checking restaurant v0.1.0 (/Users/hanelalo/develop/rust-labs/restaurant)</span><br><span class="line">error[E0603]: module `hosting` is private</span><br><span class="line">  --&gt; src/lib.rs:19:28</span><br><span class="line">   |</span><br><span class="line">19 |     crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line">   |                            ^^^^^^^ private module</span><br><span class="line">   |</span><br><span class="line">note: the module `hosting` is defined here</span><br><span class="line">  --&gt; src/lib.rs:2:5</span><br><span class="line">   |</span><br><span class="line">2  |     mod hosting &#123;</span><br><span class="line">   |     ^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">error[E0603]: module `hosting` is private</span><br><span class="line">  --&gt; src/lib.rs:21:21</span><br><span class="line">   |</span><br><span class="line">21 |     front_of_house::hosting::add_to_waitlist();</span><br><span class="line">   |                     ^^^^^^^ private module</span><br><span class="line">   |</span><br><span class="line">note: the module `hosting` is defined here</span><br><span class="line">  --&gt; src/lib.rs:2:5</span><br><span class="line">   |</span><br><span class="line">2  |     mod hosting &#123;</span><br><span class="line">   |     ^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0603`.</span><br></pre></td></tr></table></figure><p>主要的报错信息就是 <code>hosting</code> 模块是私有的。</p><p>现在要把 <code>hosting</code> 暴露出来，需要在定义时，加上 pub 关键字：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;&#125;</span><br></pre></td></tr></table></figure><p>但是在此检查还是会报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ cargo check                                                                   </span><br><span class="line">    Checking restaurant v0.<span class="number">1.0</span> (/Users/hanelalo/develop/rust-labs/restaurant)</span><br><span class="line">error[E0603]: function `add_to_waitlist` is private</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/lib.rs:<span class="number">19</span>:<span class="number">37</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">19</span> |     crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">   |                                     ^^^^^^^^^^^^^^^ private function</span><br><span class="line">   |</span><br><span class="line">note: the function `add_to_waitlist` is defined here</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/lib.rs:<span class="number">3</span>:<span class="number">9</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">3</span>  |         <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">   |         ^^^^^^^^^^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">error[E0603]: function `add_to_waitlist` is private</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/lib.rs:<span class="number">21</span>:<span class="number">30</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">21</span> |     front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">   |                              ^^^^^^^^^^^^^^^ private function</span><br><span class="line">   |</span><br><span class="line">note: the function `add_to_waitlist` is defined here</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/lib.rs:<span class="number">3</span>:<span class="number">9</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">3</span>  |         <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">   |         ^^^^^^^^^^^^^^^^^^^^</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0603`.</span><br></pre></td></tr></table></figure><p>现在是 <code>add_to_waitlist</code> 函数无法访问，因为这个函数依然是私有的，所以需要写加上一个 <code>pub</code> 关键字。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>在此尝试编译就会发现已经没有编译错误了，只是可能有一些告警而已。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>前面提到过一个 package 可以同时包含二进制 crate、库 crate。通常来讲，包含库和可执行二进制模块的包往往在可执行二进制模块中只包含足够的代码来启动一个调用库模块代码的可执行程序。这样也使得其他项目也能使用这个 package 中的一些功能。</p><p>模块树应该在 <code>src/lib.rs</code> 中定义。然后，通过以包的名称作为路径的起始部分，可以在可执行二进制模块中使用任何公开的代码。可执行二进制 crate 成为库 crate 的用户，就像外部 crate 使用库 crate 一样：它只能使用公开的 API。这有助于设计一个良好的 API；你不仅是作者，也是一个客户端！</p><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>简单点解释就是调用父 module 的代码时，需要使用 super 关键字。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;</span><br><span class="line">            super::<span class="title function_ invoke__">in_service</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">server_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">in_service</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要在 hosting 的 add_to_waitlist 函数中调用父 module 中的 in_service 函数，可以直接通过 <code>super::in_service()</code> 的方式调用。</p><h3 id="结构体和枚举类型-public"><a href="#结构体和枚举类型-public" class="headerlink" title="结构体和枚举类型 public"></a>结构体和枚举类型 public</h3><p>主要需要知道的有 3 点：</p><ol><li><p>结构体和枚举在没专门指定时，默认就是 private 的，如果要 public，就得使用 <code>pub</code> 关键字。</p></li><li><p>结构体定义时，就算使用了 <code>pub struct</code>，结构体内部的字段依然是默认 private 的，如果某个字段要 public 出来，在相应的字段前面也要加上 <code>pub</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">  age: <span class="type">u32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在枚举类型中，只要定义枚举类型时加上了 <code>pub</code>，枚举类型的的每一种值都是 public 的。</p></li></ol><h2 id="use-关键字"><a href="#use-关键字" class="headerlink" title="use 关键字"></a>use 关键字</h2><p>在前面介绍了相对路径和绝对路径，但是每次通过 <code>crate::front_of_house::hosting::add_to_waitlist</code> 或者 <code>front_of_house::hosting::add_to_waitlist</code> 这样的方式进行调用，那未免太过麻烦，所以 Rust 提供了 <code>use</code> 关键字，用于将 crate 或者 crate 中的函数等引入到当前的上下文中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">  <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">mod</span> serving &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">server_order</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting::add_to_waitlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">  <span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过 use 关键字将 <code>add_to_waitlist</code> 引入到了当前的上下文，所以使用时，直接以 <code>add_to_waitlist()</code> 的方式调用即可。当然这里使用 use 关键字时，也可以只指定到 <code>use crate::front_of_house:hosting;</code>，然后通过 <code>hosting::add_to_waitlist()</code> 的方式进行调用。</p><p>Rust 官方建议按照 <code>hosting::add_ti_waitlist</code> 的方式进行调用，因为相对来说，后者其实更加的优雅，一方面，这样能够很直观知道这里调用的是哪个 crate 中的函数；另一方面，在使用各种 crate 时，如果某两个 crate 中有同名的结构体，使用这种方式能更好的避免不必要的错误。</p><p>然后，需要注意的是，use 的作用范围只在当前的 module 中，子 module 中依然还是需要通过 use 关键字导入。</p><h2 id="as-关键字"><a href="#as-关键字" class="headerlink" title="as 关键字"></a>as 关键字</h2><p>在讲到 <code>use</code> 关键字时，有提到会存在两个 crate 中出现同名的结构体的情况。这种的通过只导入其所在 module 的方式可以解决：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，Rust 还提供了 as 关键字，可以为某个 use 语句起一个别名，后续使用时就是使用这个别名即可。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重新导出"><a href="#重新导出" class="headerlink" title="重新导出"></a>重新导出</h2><p>在 Rust 中，<code>pub use</code> 是一种用于重新导出（re-export）项的机制。它允许将一个项从一个模块重新导出到另一个模块，并使其对外可见。</p><p>通过使用 <code>pub use</code>，可以在当前模块中创建一个公共的接口，使外部模块可以直接访问和使用被重新导出的项，而无需知道其实际定义的位置。</p><p><code>pub use</code> 的基本语法如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> path::item;</span><br></pre></td></tr></table></figure><p>其中，<code>path</code> 是要重新导出的项的路径，<code>item</code> 是要重新导出的具体项。</p><p>以下是一个示例，展示了如何使用 <code>pub use</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 my_module.rs 模块中重新导出 sub_module 的 greet 函数</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> sub_module::greet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> sub_module &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">greet</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello from sub_module!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>sub_module</code> 模块包含了一个函数 <code>greet</code>。通过 <code>pub use</code>，我们将 <code>sub_module</code> 的 <code>greet</code> 函数重新导出到了当前模块中。这意味着在外部使用 <code>my_module::greet()</code> 时，实际上是调用了 <code>sub_module::greet()</code>。</p><p>这种机制在设计公共接口或库的时候非常有用。它可以隐藏内部实现细节，同时提供清晰的公共接口给用户使用。</p><p>需要注意的是，<code>pub use</code> 并不是简单的重命名，它提供了对重新导出项的访问和使用。同时，通过 <code>pub use</code> 重新导出的项仍然需要满足可见性规则，即原始的 module、函数或者结构体必须是公开的才能被重新导出。</p><h2 id="简化-use-语句"><a href="#简化-use-语句" class="headerlink" title="简化 use 语句"></a>简化 use 语句</h2><p>如果要使用一个 crate 中的很多 api，可能会有多个 use 语句，比如这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting::add_to_waitlist;</span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::serving;</span><br></pre></td></tr></table></figure><p>这里只有 2 个导入其实看起来还好，但如果特别多的时候，看起来就不是很好了，所以 Rust 允许一个 use 语句解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use craet::front_of_house::&#123;hosting::add_to_waitlist, serving&#125;;</span><br></pre></td></tr></table></figure><p> 如果是既导入了 hosting，又导入了它的 add_to_waitlist 函数，可以直接使用 self 代替：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use crate::front_of_house::hosting;</span></span><br><span class="line"><span class="comment">// use crate::front_of_house::hosting::add_to_waitlist;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting::&#123;<span class="keyword">self</span>, add_to_waitlist&#125;;</span><br></pre></td></tr></table></figure><p>或者，你想直接将 hosting 中所有东西都导入，可以直接以 <code>*</code> 代替：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use crate::front_of_house::hosting::*;</span><br></pre></td></tr></table></figure><p>当然，这一些的一切，不管如何导入，都是必须遵循可见性原则。</p><h2 id="分离-module-到多个文件"><a href="#分离-module-到多个文件" class="headerlink" title="分离 module 到多个文件"></a>分离 module 到多个文件</h2><p>还是以前面的 restaurant 为例：</p><p>文件：src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">server_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在真正的项目中，肯定不能将所有 module、所有代码都放到一个文件中，这样并不好维护。</p><p>接下来，展示代码的同时，还会列出当前 src 文件夹下的完整目录结构。</p><p>现在的目录结构是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">lib.rs</span><br></pre></td></tr></table></figure><p>接下来我们尝试将 front_of_house 这个 module 拆分成单独的文件。</p><p>前面讲过编译器会在和 module 同名的文件中或者在和 module 同名的子文件夹中寻找实现的代码。</p><p>所以这里我们首先尝试只单独拆一个 <code>front_of_house.rs</code> 文件出来。</p><p>文件：src/front_of_house.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> serving &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">server_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件：src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 此时，依然能编译通过，文件结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">lib.rs</span><br><span class="line">front_of_house.rs</span><br></pre></td></tr></table></figure><p>此时，在 front_of_house 中还有 hosting、serving 两个子 module，我们尝试将两个子 module 也拆分出来。</p><p>首先，我们尝试将 hosting、serving 两个 module 的代码文件放到和 <code>front_of_house.rs</code> 同级文件夹。 </p><p>文件：src/front_of_house.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> serving;</span><br></pre></td></tr></table></figure><p>文件：src/hosting.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>文件：src/serving.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">server_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>此时执行编译，会报错，反正就是 lib.rs 中调用的 add_to_waitlist 函数找不到在哪里。</p><p>现在的目录结构是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">lib.rs</span><br><span class="line">front_of_house.rs</span><br><span class="line">hosting.rs</span><br><span class="line">serving.rs</span><br></pre></td></tr></table></figure><p>可以知道，<strong>现在这个目录结构是错误的。</strong></p><p>接下里，我们新建一个 <code>front_of_house</code> 文件夹，并将 <code>hosting.rs</code>、<code>serving.rs</code> 两个文件移进去，注意此时没改变任何一个文件的内容，仅仅移动了位置，再编译一下，然后编译通过了，说明这样是没问题的，现在的目录结构是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">lib.rs</span><br><span class="line">front_of_house.rs</span><br><span class="line">front_of_house/</span><br><span class="line">hosting.rs</span><br><span class="line">serving.rs</span><br></pre></td></tr></table></figure><p>这样基本就可以了，但是我们知道编译器还有一种寻找 module 实现代码的方式，那就是通过 <code>xxx/mod.rs</code> 文件。</p><p>我们再试试，直接在 <code>front_of_house</code> 文件夹中新建 <code>mod.rs</code>：</p><p>文件：<code>src/front_of_house/mod.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> serving;</span><br></pre></td></tr></table></figure><p>此时编译，编译失败，依然是找不到 <code>add_to_waitlist</code> 函数，此时的目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">lib.rs</span><br><span class="line">front_of_house.rs</span><br><span class="line">front_of_house/</span><br><span class="line">mod.rs</span><br><span class="line">hosting.rs</span><br><span class="line">serving.rs</span><br></pre></td></tr></table></figure><p>这说明，<strong>当使用两种方式定义同一个 module 时，是会报错的。</strong></p><p>然后我们将 <code>front_of_house.rs</code> 文件删掉再试试，还是能编译通过，此时的目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">lib.rs</span><br><span class="line">front_of_house/</span><br><span class="line">mod.rs</span><br><span class="line">hosting.rs</span><br><span class="line">serving.rs</span><br></pre></td></tr></table></figure><p>这说明，Rust 是兼容了 <code>src/front_of_house.rs</code> 和 <code>src/front_of_house/mod.rs</code> 两种方式的，建议还是使用 <code>src/front_of_house.rs</code> + <code>src/front_of_hosue</code> 文件夹的这种方式，不然项目里面会有很多的 mod.rs 文件。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Managing Growing Projects with Packages, Crates, and Modules</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust入门:枚举和模式匹配</title>
      <link href="posts/1b5efec34595.html"/>
      <url>posts/1b5efec34595.html</url>
      
        <content type="html"><![CDATA[<p>枚举是一种在很多编程语言中都有类型，在 Rust 中，枚举还有相应的一些模式匹配的用法在里面，本文将简单介绍一下枚举的定义，然后再稍微详细地讨论模式匹配。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>和 Java 一样，Rust 中定义枚举也是使用 <code>enum</code> 关键字：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">  V4,</span><br><span class="line">  V6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，直接当成普通的结构体调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ipv4</span> = IpAddrKind::V4;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ipv6</span> = IpAddrKind::V6;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">route</span>(ip_kind: IpAddrKind) &#123;&#125;</span><br></pre></td></tr></table></figure><p>枚举里面同样还可以再包含变量，甚至同一个枚举类型不同的值，包含的变量类型也可以不一样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">  Quit,</span><br><span class="line">  Move&#123;x: <span class="type">i32</span>, y: <span class="type">i32</span>&#125;,</span><br><span class="line">  <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">  <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可能会想到为什么不直接定义 4 个下面这样的结构体：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Quit</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Move</span> &#123;x: <span class="type">i32</span>, y: <span class="type">i32</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Write</span>(content: <span class="type">String</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChangeColor</span>(r: <span class="type">i32</span>, g: <span class="type">i32</span>, b: <span class="type">i32</span>);</span><br></pre></td></tr></table></figure><p>想象有一个函数（或方法）的返回值，可能是返回这 4 中数据类型中的一种，我们没办法让一个函数（或方法）的返回值类型有可能有 4 种，而如果我们使用的是 Message 枚举的话，那么我们的函数（或方法）的返回值类型就可以是 Message，内部实现上就能返回枚举的任意一个类型。</p><p>在结构体里面，我们是可以为结构体定义方法的，同样，也可以为枚举定义方法，甚至语法也是一样的。</p><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>在 rust 中有一种控制结构，用于根据给定的模式对值进行匹配，并执行相关联的代码逻辑，叫作 <code>match</code>。这和 if 结构有些类似，但是不一样的是 if 必须有一个返回 bool 的表达式，而 match 支持字面值、变量名、通配符等很多类型。</p><p>下面是官方文档的一个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们主要观察 match 的语法：</p><ol><li>首先是关键字 match，后面是给定的要进行匹配的值。</li><li>然后就是要 match 的分支，都用大括号括起来。</li><li>每个分支之间用都好分开。</li><li>每个分支有两个部分，一个匹配的模式，比如 <code>Coin::Penny</code>，然后是要执行的代码逻辑，代码逻辑部分如果比较复杂，可以用大括号括起来，如果比较简单，则不需要。这两部分之间通过 <code>=&gt;</code> 连接起来。</li></ol><p>当 match 开始执行时，会比对给定的值和每个分支，看是否匹配，如果匹配就执行相关联的代码，并且，只会执行第一个匹配上的分支代码。</p><p>上面的例子，主要是为了结合枚举使用模式匹配，其实我个人认为还不能理解为什么叫模式匹配，因为前面我们讲到过模式甚至可以是一个通配符。比如下面这例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> number &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One&quot;</span>),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Two&quot;</span>),</span><br><span class="line">        <span class="number">3</span> | <span class="number">4</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Three or Four&quot;</span>),</span><br><span class="line">        <span class="number">5</span>..=<span class="number">10</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Five to Ten&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Other&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分支模式有些甚至不是一个固定的值，可能是一个范围值，这样是不是更能贴切得把它叫作模式了？</p><blockquote><p>站在 java 开发者的角度，match 感觉更像是结合了 if 和 switch 两种结构。</p></blockquote><h3 id="Option-lt-T-gt-的使用"><a href="#Option-lt-T-gt-的使用" class="headerlink" title="Option&lt;T&gt; 的使用"></a><code>Option&lt;T&gt;</code> 的使用</h3><p>接下来，看一个 Rust 中比较常用的模式匹配 <code>Option&lt;T&gt;</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six</span> = <span class="keyword">match</span> <span class="title function_ invoke__">plus_one</span>(five) &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; -<span class="number">1</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; i</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;six is &#123;&#125;&quot;</span>, six);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none</span> = <span class="keyword">match</span> <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>) &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; -<span class="number">1</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; i</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;none is &#123;&#125;&quot;</span>, none);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.00s</span><br><span class="line">     Running `target/debug/match-pattern`</span><br><span class="line">six is 6</span><br><span class="line">none is -1</span><br></pre></td></tr></table></figure><p><code>plus_one</code> 函数接收一个 <code>Option&lt;i32&gt;</code> 类型的参数。Option 是 Rust 中常用的一个枚举，包含 <code>None</code>、<code>Some(T)</code> 两种值，其中 T 是泛型，以后学了再说。如果传入的 <code>Option&lt;i32&gt;</code> 类型变量是 <code>Some</code> 就将其中的 i32 类型的值加一，并用 <code>Some</code> 进行封装，即<code>Some(i+1)</code>，然后返回，如果是 <code>None</code>，就直接也返回一个 <code>None</code>。</p><p>而在 main 函数中也对返回值根据不同情况进行取值，如果是 <code>None</code> 就返回 -1，否则就返回 <code>Some</code> 中的值。</p><h3 id="模式匹配中的默认处理逻辑"><a href="#模式匹配中的默认处理逻辑" class="headerlink" title="模式匹配中的默认处理逻辑"></a>模式匹配中的默认处理逻辑</h3><p>在模式匹配中，如果分支覆盖的范围不全会编译失败，比如下面的代码，我们只匹配了 1 到 10 的数字的情况，其他的没处理：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> number &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One&quot;</span>),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Two&quot;</span>),</span><br><span class="line">        <span class="number">3</span> | <span class="number">4</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Three or Four&quot;</span>),</span><br><span class="line">        <span class="number">5</span>..=<span class="number">10</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Five to Ten&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run                                                                       ok  22:11:25 </span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.00s</span><br><span class="line">     Running `target/debug/match-pattern`</span><br><span class="line">six is 6</span><br><span class="line">none is -1</span><br><span class="line"></span><br><span class="line"> ~/develop/rust-labs/match-pattern  master ?4  cargo run                                                                       ok  22:12:47 </span><br><span class="line">   Compiling match-pattern v0.1.0 (/Users/hanelalo/develop/rust-labs/match-pattern)</span><br><span class="line">error[E0004]: non-exhaustive patterns: `i32::MIN..=0_i32` and `11_i32..=i32::MAX` not covered</span><br><span class="line"> --&gt; src/main.rs:4:11</span><br><span class="line">  |</span><br><span class="line">4 |     match number &#123;</span><br><span class="line">  |           ^^^^^^ patterns `i32::MIN..=0_i32` and `11_i32..=i32::MAX` not covered</span><br><span class="line">  |</span><br><span class="line">  = note: the matched value is of <span class="built_in">type</span> `i32`</span><br><span class="line"><span class="built_in">help</span>: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms</span><br><span class="line">  |</span><br><span class="line">8 ~         5..=10 =&gt; println!(<span class="string">&quot;Five to Ten&quot;</span>),</span><br><span class="line">9 ~         i32::MIN..=0_i32 | 11_i32..=i32::MAX =&gt; todo!(),</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0004`.</span><br></pre></td></tr></table></figure><p>会发现这里会编译失败，因为并没有处理所有的情况，当 number 大于 10 或者小于 1 时要如何处理？</p><p>而要处理剩余的所有情况，模式可以直接写成 <code>_</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> number &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One&quot;</span>),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Two&quot;</span>),</span><br><span class="line">        <span class="number">3</span> | <span class="number">4</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Three or Four&quot;</span>),</span><br><span class="line">        <span class="number">5</span>..=<span class="number">10</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Five to Ten&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Other&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-let-语法"><a href="#if-let-语法" class="headerlink" title="if let 语法"></a>if let 语法</h3><p>在前面讲到 match 会要求你的模式必须包含所有的可能，但有时可能我们并不需要写得如此复杂，所以 rust 提供了一种特殊的 match 语法糖，那就是 <code>if let</code> 模式匹配，基本的语法结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if let pattern = value &#123;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这里的 else 也可以不要。</p><p>实例代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(value) = number &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Matched: &#123;&#125;&quot;</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Not matched&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但我觉得这种写法，太生涩了，虽然代码是简单很多，但是看着不舒服，太过于反常识。</p></blockquote><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://doc.rust-lang.org/book/ch06-00-enums.html#enums-and-pattern-matching">Enums and Pattern Matching</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust入门:结构体</title>
      <link href="posts/da2e2d39b491.html"/>
      <url>posts/da2e2d39b491.html</url>
      
        <content type="html"><![CDATA[<p>Rust 的官方文档讲结构体时，说结构体和 tuple 数据类型比较类似，因为都支持将不同类型的数据集合到一起。但区别在于：访问 tuple 中的数据必须按下标来访问，而结构体并不用；结构体可以为这个多种数据类型的集合命名，而 tuple 不行。</p><p>因为我是一个 Java 开发者，所以按我的理解，其实 Rust 和 Java 中的类比较类似。</p><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p>在 rust 中，定义结构体的关键字是 <code>struct</code>，后面接结构体的名称，然后是一堆大括号，大括号内就是类的字段。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  width: <span class="type">u32</span>,</span><br><span class="line">  height: <span class="type">u32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以通过 struct 的语法将相同的 tuple 数据类型定义成不同的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br></pre></td></tr></table></figure><p>上面的 <code>Color</code> 和 <code>Point</code> 虽然都是由 3 个 <code>i32</code> 类型的数据组成，但是对应结构体的名称却不一样，如果一个函数的入参是 <code>Color</code>，就算 <code>Point</code> 和 <code>Color</code> 内部维护的数据类型一样，但依然不能将 <code>Point</code> 作为参数来传递。</p><p>最后就是，还可以像下面这样定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEquals</span>;</span><br></pre></td></tr></table></figure><p>是的，这个结构体就只剩下一个名字了，这种结构体在 rust 中叫作 Unit-Like，这种定义方式，在后面讲到自定义 trait 时会细说，这里就不关注了。</p><p>还有一点，需要特别注意：常规情况下，结构体中的数据的所有权归结构体的变量所有，所以结构体中的字段类型，不允许是引用类型。</p><p>接下来的内容，我们主要会以第一种常规定义方式定义的结构体 <code>Rectangle</code> 为例进行。</p><h2 id="使用结构体"><a href="#使用结构体" class="headerlink" title="使用结构体"></a>使用结构体</h2><p>结构体，其实就是一种自定义的复杂数据类型。</p><p>如果我们要定义一个 Rectangle 类型的变量，直接以结构体名称开头，后接大括号，大括号内是结构体的字段以 <code>key: value</code> 的形式定义，以及最后，有一个分号，表明这是一个完整的语句。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">rect1</span>  = Rectangle &#123;</span><br><span class="line">width: <span class="number">20</span>,</span><br><span class="line">height: <span class="number">40</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然你写成下面这样也行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">rect1</span>  = Rectangle &#123;</span><br><span class="line">height: <span class="number">40</span>,</span><br><span class="line">  width: <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>换句话说，在定义各个字段值时，不需要按照结构体定义中的字段顺序来。</p><p>这样其实有点麻烦，接下来将介绍几种定义某中结构体的变量时的快捷操作。</p><h3 id="结构体字段名和变量名一致"><a href="#结构体字段名和变量名一致" class="headerlink" title="结构体字段名和变量名一致"></a>结构体字段名和变量名一致</h3><p>当结构体的字段名和变量名一致时，定义解构体是，可以直接省略 <code>key:value</code> 中的 <code>key:</code> 部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let height = 20;</span><br><span class="line">let rect1 = Rectangle &#123;</span><br><span class="line">height,</span><br><span class="line">width: 20</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>当我们已经有了一个变量 rect1，现在需要在此基础上新建一个 rect2，你可能会这样做：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">  width: <span class="number">30</span>,</span><br><span class="line">  height: <span class="number">40</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">rect2</span> = Rectangle &#123;</span><br><span class="line">  width: rect1.width,</span><br><span class="line">  height: rect1.height</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但其实，你可以这样做：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">  width: <span class="number">30</span>,</span><br><span class="line">  height: <span class="number">40</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">rect2</span> = Rectangle &#123;,</span><br><span class="line">  height: <span class="number">50</span>,</span><br><span class="line">  ..rect1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样写的意思是，rect2 的 height 是 50，其余字段取 rect1 的相同字段的值。</p><p>等等，这里我们需要确认一件事，那就是结构体里面的数据的所有权问题。如果字段类型是像 <code>u32</code>、<code>f32</code> 这种基础的标量类型，自然是不用考虑的，因为这种数据是直接赋值，而不是进行所有权的转移或者借用。但如果是一个字符串呢？</p><p>我们来做个实验：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hanelalo&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hanelalo@163.com&quot;</span>),</span><br><span class="line">        age: <span class="number">25</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;user1: &#123;:?&#125;&quot;</span>, user1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;killer&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;user2: &#123;:?&#125;&quot;</span>, user2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;user1.username: &#123;:?&#125;&quot;</span>, user1.username);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;user1.age: &#123;:?&#125;&quot;</span>, user1.age);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;user1.email: &#123;:?&#125;&quot;</span>, user1.email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling structor-test v0.1.0 (/Users/hanelalo/develop/rust-labs/structor-test)</span><br><span class="line">error[E0382]: borrow of moved value: `user1.email`</span><br><span class="line">  --&gt; src/main.rs:22:35</span><br><span class="line">   |</span><br><span class="line">15 |       <span class="built_in">let</span> user2 = User &#123;</span><br><span class="line">   |  _________________-</span><br><span class="line">16 | |         username: String::from(<span class="string">&quot;killer&quot;</span>),</span><br><span class="line">17 | |         ..user1</span><br><span class="line">18 | |     &#125;;</span><br><span class="line">   | |_____- value moved here</span><br><span class="line">...</span><br><span class="line">22 |       println!(<span class="string">&quot;user1.email: &#123;:?&#125;&quot;</span>, user1.email);</span><br><span class="line">   |                                     ^^^^^^^^^^^ value borrowed here after move</span><br><span class="line">   |</span><br><span class="line">   = note: move occurs because `user1.email` has <span class="built_in">type</span> `String`, <span class="built_in">which</span> does not implement the `Copy` trait</span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the macro `<span class="variable">$crate</span>::format_args_nl` <span class="built_in">which</span> comes from the expansion of the macro `println` (<span class="keyword">in</span> Nightly builds, run with -Z macro-backtrace <span class="keyword">for</span> more info)</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `structor-test` (bin <span class="string">&quot;structor-test&quot;</span>) due to previous error</span><br></pre></td></tr></table></figure><p>在创建了 user2 之后，我们再尝试访问 user1 的字段，发现编译时，在最后一行访问 <code>user1.email</code> 是编译不通过的，因为它的值已经  move 走了。</p><p>也就是说，创建 user2 时使用 <code>..user1</code> 这种语法，里面的复杂类型的所有权会发生转移，这里是从 user1 转移到 user2。</p><blockquote><p>同样，这里不管创建 user1 还是 user2，String 类型的字段的值都是调用 <code>String::from</code> 来生成，而不是直接写一个 <code>&quot;hanelalo&quot;</code> 这样的字符串字面值，因为字符串字面值的类型是 &amp;str，其实是一个引用。</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法和函数类似，定义的语法也基本相同，但是不同在于，方法是依托于结构体而存在的。</p><p>还是上面的 <code>Rectangle</code> 结构体，如果我现在有一个 Rectangle，我要计算它的面积，可能你会这样写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">rect</span> = Rectangle &#123;</span><br><span class="line">    width: <span class="number">30</span>,</span><br><span class="line">    height: <span class="number">50</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;The area is &#123;&#125;&quot;</span>, <span class="title function_ invoke__">area</span>(&amp;rect));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(rect: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">  rect.width * rect.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是直觉上，我使用 Rectangle 的时候，我需要它的面积，应该是我我定义的这个 Rectangle 本身有一个 api 能够计算出面积，而不是还需要调用方自己再写一个 area 函数来计算。</p><blockquote><p>其实意思就是，按照 Java 面向对象设计的话，计算面积应该是 Rectangle 对象本身所具有的一个行为。</p></blockquote><p>Rust 也支持了为某个结构体定义方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>impl Rectangle &#123;</code> 表示这里面都是为 Rectangle 这个结构体定义的方法。</p><p>而内部的方法定义的语法倒是和函数定义一致，只不过，可以看见 <code>area</code> 方法的参数是 <code>&amp;self</code>，这里竟然没指定参数类型，这里可以理解为 <code>self: &amp;Self</code>，而 <code>Self</code> 就是当前这个 Rectangle 变量本身。因为有 <code>&amp;</code> 符号，所以这里是借用关系，不会发生所有权转移。</p><p>然后，看看这个方法要如何使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">rect</span> = Rectangle &#123;</span><br><span class="line">    width: <span class="number">30</span>,</span><br><span class="line">    height: <span class="number">50</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;The area is &#123;&#125;&quot;</span>, rect.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果学过 C++ 或者 Golang，看见 <code>&amp;</code> 应该会想起来，在这两种语言中，有写方法只能通过对象引用调用，有些则是通过真正的对象实例调用。而在 Rust 中没这个区别。</p></blockquote><p>在定义结构体的方法时，除了 <code>self: &amp;Self</code> 简写成了 <code>&amp;self</code> 之外，其他的参数还是需要按照正常语法书写。</p><h3 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h3><blockquote><p>在官方文档里面叫作 <a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#associated-functions">Associated Functions</a>。</p></blockquote><p>最明显的区别就是，方法函数里面没有 <code>&amp;self</code>，比如常用的 <code>String::from</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;&amp;<span class="type">str</span>&gt; <span class="keyword">for</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">to_owned</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法调用时是通过结构体名称后跟<code>::</code>，然后再跟上方法名称的方式进行调用。</p><p>比如我们写一个 Rectangle 的构造函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">new</span>(width: <span class="type">u32</span>, height: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">      width,</span><br><span class="line">      height</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html">The Rust Programming Language</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust入门:切片类型</title>
      <link href="posts/7ae6ee2a35b7.html"/>
      <url>posts/7ae6ee2a35b7.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是 Rust 官方文档的翻译，原文：<a href="https://doc.rust-lang.org/book/ch04-03-slices.html">https://doc.rust-lang.org/book/ch04-03-slices.html</a></p></blockquote><h2 id="切片类型"><a href="#切片类型" class="headerlink" title="切片类型"></a>切片类型</h2><blockquote><p>译者注：相信使用过 python 的对这个概念并不陌生，这里切片的原文是 slice。本文中切片和 slice 是等价的。</p></blockquote><p>切片允许你引用一个集合中的连续序列，而不是整个集合。因为切片本就是一种引用，所以它没有所有权。</p><p>这里有一个小问题：写一个函数，将字符串按空格分开，找到并返回它的第一个单词，如果找不到空格，那这个字符串必是一个单词，所以要返回整个字符串。</p><p>让我们先以不使用切片的方式解决这个问题，方便更深入理解切片的意义。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> ?</span><br></pre></td></tr></table></figure><p><code>first_word</code> 函数的参数是 <code>&amp;String</code>，我们并不想要转移所有权，所以这没问题。但是这个函数的返回值类型应该是什么？</p><p>我们目前没办法只去操作字符串的一部分，但是我们可以返回以空格分隔之后的单词的索引。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="title function_ invoke__">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码清单 4-7：first_word 返回一个 String 中的索引值</p><p>因为我们需要逐个便利字符串的每一个字符，确定是不是空格，我们会使用 <code>as_bytes</code> 方法将字符串转换成一个 byte 数组。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br></pre></td></tr></table></figure><p>然后，我们通过 <code>iter</code> 方法为这个数字创建一个迭代器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br></pre></td></tr></table></figure><p>更详细的关于迭代起的讨论在<a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">第十三章</a>。现在我们只需要知道 <code>iter</code> 方法返回集合中的每一个元素，而 <code>enumerate</code> 方法将其返回的元素使用 tuple 进行封装，以 tuple 的方式返回每个元素。tuple 中的第一个元素是在 bytes 中的索引值，tuple 的第二个元素是对于 bytes 中索引值对应的数据的引用。</p><p>因为 <code>enumerate</code> 方法返回一个 tuple，我们可以使用模式来解构这个 tuple。我们会在<a href="https://doc.rust-lang.org/book/ch06-02-match.html#patterns-that-bind-to-values">第六章</a>讨论<em>模式</em>。而在 for 这种循环结构里，我们指定的模式是，<code>i</code> 是 tuple 中的索引，<code>&amp;item</code> 是 tuple 中单个字节。因为我们从 <code>.iter().enumerate()</code> 中获取的是引用，所以这里使用了 <code>&amp;</code>。</p><p>在 for 循环中，我们以二进制的方式搜索空格，如果找到了空格，就返回当前的索引值 <code>i</code>，如果最终没找到，就通过 <code>s.len()</code> 返回字符串的长度。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_ invoke__">len</span>()</span><br></pre></td></tr></table></figure><p>我们现在有办法找到字符串中的第一个单词结尾的索引，但是还有一个问题，我们只是返回了一个 <code>usize</code> 值，但它仅仅只是在 <code>&amp;String</code> 这个上下文中有意义的数字而已。换句话说，因为它是独立于 <code>String</code> 的一个值，并不能保证它未来也有效。所以可以考虑像代码清单 4-8 这样使用代码清单 4-7 中的 <code>first_word</code> 函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s); <span class="comment">// word 的值为 5</span></span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// 这会清空字符串，让它等于 &quot;&quot;</span></span><br><span class="line"><span class="comment">// word 的值一直会是 5，但是没有其他关于字符串的任何东西了</span></span><br><span class="line">  <span class="comment">// 我们可以继续使用这个有意义的 5，但是现在完全不知道这个单词是啥</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码清单 4-8: 保存 <code>first_word</code> 的返回值并清空字符串</p><p>必须考虑 <code>word</code> 中的索引与 <code>s</code> 中的数据不同步的问题，这是是一件复杂且容易出错的事情！如果编写一个 <code>second_word</code> 函数，管理这些索引会变得更加脆弱。其函数签名应该如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">second_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">usize</span>, <span class="type">usize</span>) &#123;</span><br></pre></td></tr></table></figure><p>现在，我们需要跟踪起始索引和结束索引，我们有更多的值是从特定状态的数据计算出来的，但它们与该状态没有任何关联。我们有三个不相关的变量在周围浮动，需要保持同步。</p><p>幸运的是，Rust 对这个问题有一个解决方案：字符串切片（string slices）。</p><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><p>字符串切片是对字符串的一部分的引用，看起来就像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br></pre></td></tr></table></figure><p>这里并不是引用整个字符串，变量 <code>hello</code> 只是引用了字符串的一部分，引用的部分通过 <code>[0..5]</code> 来提取。我们通过<code>[string_index..end_index]</code> 的形式来圈定创建切片的范围，<code>start_index</code> 是切片在字符串中的起始位置，<code>end_index</code> 则是比切片的最后一个位置多一位（译者注：其实就是 start_index、end_index 都是索引，而且是前闭后开的区间）。在切片内部存储着切片的起始位置，以及切片的长度（即 end_index - start_index）。所以在 <code>let world = &amp;s[6..11];</code> 中，<code>world</code> 变量是一个切片，这个切片包含一个指针指向索引为 6 的位置，并且记录长度为 5。</p><p>图 4-6 解释了这种切片结构。</p><p><img src="http://image.hanelalo.cn/image/202306172255528.png" alt="图 4-6：引用部分字符串的字符串切片"></p><p>图 4-6：引用部分字符串的字符串切片</p><p>使用 Rust 中的范围语法 <code>..</code> 时，如果 start_index 想从 0 开始，则可以删除 <code>..</code> 前面的数字。简单点讲，下面这两种切片的写法是一样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>同理，如果你的切片要包含字符串的最后一个字符，你可以将 <code>..</code> 后面的数字删掉，也就是说，下面这两种写法是等价的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = Sring::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..];</span><br></pre></td></tr></table></figure><p>如果将 <code>..</code> 前后的数字都删除，则表示这个切片引用的是整个字符串，所以下面这两种写法是等价的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = Sring::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..];</span><br></pre></td></tr></table></figure><blockquote><p>注意：字符串切片范围必须出现在有效的 utf-8 的字符边界处。如果你想在某个字节中间进行字符串切片操作，程序将因为错误而退出。为了方便介绍字符串切片，本章的仅假设字符串在 ASCII 编码范围内。更多关于 UTF-8 的处理将在<a href="https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">第八章</a>进行讨论。</p></blockquote><p>结合以上所学，我们重新实现 <code>first_word</code> 函数，并让它返回一个 slice，在返回值类型这里，字符串切片类型的写法是 <code>&amp;str</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用和代码清单 4-7 相同的方法得到了第一个单词的默认索引，当我们找到一个空格时，我们返回一个切片，切片引用范围是从 0 到这个空格的索引。现在我们调用 <code>first_word</code>，得到的是一个引用了从字符串的索引 0 开始到第一个空格之间的数据的切片。</p><p>这种返回切片的方式，同样适用于 <code>second_word</code> 函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">second_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure><p>现在我们有一个明确的获取第一个单词的 api，就更加不容易出错了，并且编译器会保证这个切片引用不会是无效引用。还记得代码清单 4-8 中的 bug 吗？它在获取了第一个单词末尾的索引下标后，将字符串清空了，此时我们拿到的索引也就没用了，这是一个 bug 呀，但是依然编译通过了。而使用新版本的 <code>first_word</code> 则会在编译时就报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the first word is: &#123;&#125;&quot;</span>, word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span><br><span class="line">  --&gt; src/main.rs:18:5</span><br><span class="line">   |</span><br><span class="line">16 |     let word = first_word(&amp;s);</span><br><span class="line">   |                           -- immutable borrow occurs here</span><br><span class="line">17 |</span><br><span class="line">18 |     s.clear(); // error!</span><br><span class="line">   |     ^^^^^^^^^ mutable borrow occurs here</span><br><span class="line">19 |</span><br><span class="line">20 |     println!(&quot;the first word is: &#123;&#125;&quot;, word);</span><br><span class="line">   |                                       ---- immutable borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0502`.</span><br><span class="line">error: could not compile `ownership` due to previous error</span><br></pre></td></tr></table></figure><p>回忆借用的规则：同一作用域中，有一个不可变引用之后，就不能在有可变引用。因为 <code>clear</code> 方法会清空字符串，它需要拿到一个可变引用，而 <code>println!</code> 在调用 <code>clear</code> 方法之后还在使用 word 变量，所以 word 在这一刻都依然有效。Rust 不允许 <code>clear</code> 中的可变引用和 <code>word</code> 这个不可变引用同时存在，所以会编译失败。Rust 不仅让 api 更易用，它还在编译时消除了一整类错误。</p><h3 id="字符串字面值的切片"><a href="#字符串字面值的切片" class="headerlink" title="字符串字面值的切片"></a>字符串字面值的切片</h3><p>回忆一下字符串字面值，它是硬编码到了二进制文件中。现在我们学习了切片，我们也可以正确理解字符串字面值的切片了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里的 <code>s</code> 的类型是 <code>&amp;str</code>，它是一个指向二进制文件中特定位置的切片。这也是为什么字符串字面值是不可变的，因为 <code>&amp;str</code> 是一个不可变引用。</p><h3 id="字符串切片作为参数"><a href="#字符串切片作为参数" class="headerlink" title="字符串切片作为参数"></a>字符串切片作为参数</h3><p>在学习了字符串和字符串字面值的切片之后，我们对 <code>first_word</code> 又进行了一次优化，这是它的函数签名：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure><p>很多 Rust 开发者都会将函数签名写成代码清单 4-9 这样，因为这样写，参数能支持 <code>&amp;String</code> 和 <code>&amp;str</code> 两种。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure><p>代码清单 4-9：优化 first_word 函数参数为字符串切片</p><p>如果我们有一个字符串切片，我们能直接作为参数传递，如果有一个 String，则可以直接穿一个 String 或者它的引用。这样的操作利用了一个叫作 <code>deref</code> 的特性，我们将在<a href="https://doc.rust-lang.org/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">第 15 章</a>讨论这个特性。</p><p>定义一个函数来接收字符串切片而不是一个对 <code>String</code> 的引用，可以使我们的 API 更加通用和有用，而不会失去任何功能：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first_word在参数是 String 切片时，能正常工作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[..]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first_word在参数是 String 的引用时，也能正常工作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string_literal</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first_word在参数是字符串字面值切片时，能正常工作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[..]);</span><br><span class="line">    <span class="comment">// 因为字符串字面值本身就是一种切片，所以直接作为参数传递也行</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(my_string_literal);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他类型的切片"><a href="#其他类型的切片" class="headerlink" title="其他类型的切片"></a>其他类型的切片</h2><p>字符串切片，如你所想，是特定于字符串的操作。但是还有一些其他类型的切片，考虑有下面这样一个数组：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>就像我们想要引用字符串的一部分一样，我们可能想要引用一个数组的一部分。我们可以像下面这样做：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>这个切片的类型是 <code>&amp;[i32]</code>。它和字符串切片的工作机制一样，内部存储了切片的开始索引和切片的长度。你可以在各种集合上使用这种切片，我们在第八章讲 Vector 时，会详细讨论这些集合。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所有权、借用和切片这些概念，都是在编译时就能保证程序的内存安全。Rust 可以像其他编程语言那样控制内存的使用，只不过当数据超出范围时，有数据的所有者自动清理这些数据，这意味着你不必额外写代码来控制内存的申请和释放。</p>]]></content>
      
      
      <categories>
          
          <category> 文档翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust入门:引用和借用</title>
      <link href="posts/1814226a1de7.html"/>
      <url>posts/1814226a1de7.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是 Rust 官方文档的翻译，原文：<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html</a></p></blockquote><p>在代码清单 4-5 中，我们调用 <code>calculate_length</code>，该函数返回了一个 String 类型，我们调用完这个函数之后，依然还能使用它返回的 String 类型的变量，这是因为这个 String 变量的所有权发生了转移。我们还能提供一个 String 类型的变量的引用，引用就想一个指向某个内存地址的指针，我们可以通过引用访问到这个内存地址上的数据，而这个内存地址上的数据，有可能是属于其他变量的；和指针不同的是，引用在引用的生命周期内保证指向的一定是有效的数据。</p><p>下面的代码展示了你要如何以传递一个引用作为函数参数的方式调用 <code>calculate_length</code> 函数：</p><p>文件名：src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，注意这里所有的 tuple 相关的代码，包括返回值使用 tuple 的代码，都已经删除。</p><p>然后，需要注意调用 <code>calculate_length</code> 时，传入的参数是 <code>&amp;s1</code>，并且在其函数的定义中，参数类型是 <code>&amp;String</code> 而不是 <code>String</code>，这种写法就是<em>引用</em>，它允许你使用某些值，但并不需要拥有这个值的所有权。图 4-5 描绘了这种概念。</p><p><img src="http://image.hanelalo.cn/image/202306162221740.png" alt="图 4-5：&amp;String s 指向 String s1"></p><p>图 4-5：<code>&amp;String s</code> 指向 <code>String s1</code></p><blockquote><p>注意：与引用相反的是取消引用，通过 <code>*</code> 操作符就能实现取消引用，我们会在第 8 章看见一些对 <code>*</code> 的使用，会在第 15 章详细讨论取消引用。</p></blockquote><p>让我们仔细看看这段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br></pre></td></tr></table></figure><p><code>&amp;s1</code> 这种写法，会创建一个引用，指向 s1 的值，但是并不会发生所有权的变化。因为这里没有发生所有权的变化，所以当这个这个引用超出作用域时，并不会调用 drop，也不会释放内存。</p><p>同样，使用 <code>&amp;</code> 这个标识符号，标识这里的变量类型是某个数据类型的引用类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;<span class="comment">// s 是一个 String 的引用</span></span><br><span class="line">  s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;<span class="comment">// s 超出作用域，但是因为 s 是引用类型，没有相应数据的所有权，所以不会释放内存</span></span><br></pre></td></tr></table></figure><p>s 的作用域与函数的任何参数的有效作用域范围一样，只不过当 s 不再使用时，它指向的值不会被清除，因为 s 没有数据的所有权。当函数的参数是变量的引用，而不是变量真正的值时，我们不需要在函数中返回变量的值来归还所有权，因为从来没拥有过变量值的所有权。</p><p>我们把这种创建一个引用的操作叫作借用（原文：borowwing）。在真实生活中，一个人有某中东西，你可以找他接，用完后你还得还回去，但你从来没有拥有过这个东西。</p><p>所以，如果我们对借用的数据进行修改会怎样？试试代码清单 4-6，其实它会报错。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;,world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码清单 4-6：尝试修改借用的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference</span><br><span class="line"> --&gt; src/main.rs:8:5</span><br><span class="line">  |</span><br><span class="line">7 | fn change(some_string: &amp;String) &#123;</span><br><span class="line">  |                        ------- <span class="built_in">help</span>: consider changing this to be a mutable reference: `&amp;mut String`</span><br><span class="line">8 |     some_string.push_str(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0596`.</span><br><span class="line">error: could not compile `ownership` due to previous error</span><br></pre></td></tr></table></figure><p>和变量默认就是不可变的，引用也是一样默认不可变的。我们并不允许修改引用的数据。</p><h2 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h2><p>我们可以修改代码清单 4-6，通过使用可变引用，就能修改借用的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;,world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，修改变量 s 为可变的。然后，我们通过 <code>&amp;mut s</code> 创建一个可变引用，并作为调用 <code>change</code> 函数的参数。修改 <code>change</code> 函数的参数裂变，接受一个可变引用 <code>some_string: &amp;mut String</code>。这很明确的表示，函数 <code>change</code> 很可能使其借用的值发生变化。</p><p>可变引用有一个很重要的强制限制：如果一个变量已经有一个可变引用，那它将不能再有任何其他引用。下面的代码尝试为变量 <code>s</code>  创建两个可变的引用，这明显会编译失败：</p><p>文件名：src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0499]: cannot borrow `s` as mutable more than once at a time</span><br><span class="line"> --&gt; src/main.rs:5:14</span><br><span class="line">  |</span><br><span class="line">4 |     let r1 = &amp;mut s;</span><br><span class="line">  |              ------ first mutable borrow occurs here</span><br><span class="line">5 |     let r2 = &amp;mut s;</span><br><span class="line">  |              ^^^^^^ second mutable borrow occurs here</span><br><span class="line">6 |</span><br><span class="line">7 |     println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br><span class="line">  |                        -- first borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0499`.</span><br><span class="line">error: could not compile `ownership` due to previous error</span><br></pre></td></tr></table></figure><p>这里报错就是因为我们在一个作用域中不能对 s 有两个可变引用。</p><p>s 的第一个可变引用 r1 知道最后调用 println 都依然有效，但是在创建这个引用到使用这个引用之间，有定义了一个 s 的可变引用 r2。</p><p>总之，Rust 允许你对引用的数据作出更改，但是增加了限制，以保证这种改变是可控的。这是大多数 Rust 开发者难以理解的问题，因为大多数语言都允许你随意改变。有这个限制的好处在于，Rust 能在编译时就就发现数据竞争问题。当出现以下三种情况时就会发生数据竞争：</p><ol><li>两个或以上的指针在同一时间访问同一数据。</li><li>至少一个指针在写这些数据。</li><li>没有任何用于同步访问数据的机制。</li></ol><p>数据竞争会导致发生一些无法预测的事，而在运行时去发现并修复这个问题，也是比较困难的。而 Rust 解决这个问题的方案则是在编译时如果发现了这种问题，就编译失败。</p><p>同样，我还可以通过大括号 <code>&#123;</code> 创建一个新的作用域，来实现对变量的多个可变引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125; <span class="comment">// r1 在这里超出了作用域，所有在此之后，我们可以再创建一个新的可变引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure><p>Rust 还有一个关于同事使用可变引用和不可变引用的强制规则，且先看看下面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// BIG PROBLEM</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br></pre></td></tr></table></figure><p>这里的报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span><br><span class="line"> --&gt; src/main.rs:6:14</span><br><span class="line">  |</span><br><span class="line">4 |     let r1 = &amp;s; // no problem</span><br><span class="line">  |              -- immutable borrow occurs here</span><br><span class="line">5 |     let r2 = &amp;s; // no problem</span><br><span class="line">6 |     let r3 = &amp;mut s; // BIG PROBLEM</span><br><span class="line">  |              ^^^^^^ mutable borrow occurs here</span><br><span class="line">7 |</span><br><span class="line">8 |     println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3);</span><br><span class="line">  |                                -- immutable borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0502`.</span><br><span class="line">error: could not compile `ownership` due to previous error</span><br></pre></td></tr></table></figure><p>当作用域内对某个变量值有一个不可变引用时，不能再有一个可变引用。</p><p>因为对于不可变引用来讲，并不希望突然发现引用的数据变了。然后，Rust 是允许对同一个变量有多个不可变引用的，因为这些不可变引用没有任何一个引用会对数据进行修改。</p><p>需要注意引用的作用域是从引用定义时，一直贯穿到最后一次使用。举个例子，下面的代码中之所以能编译，是因为不可变引用的最后一次使用在 <code>println!</code>，并且发生在定义可变引用之前：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; </span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; </span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r3);</span><br></pre></td></tr></table></figure><p>不可变引用 <code>r1</code>、<code>r2</code> 在调用 <code>println!</code> 之后就无效了，因为这是它们最后一次被使用，而这发生在 <code>r3</code> 声明之前，这里没有作用域的重叠，所以才能编译通过。形象点讲，编译器可以在作用域结束前的某个点就知道引用不会再使用。</p><p>尽管借用产生的错误比较烦，但是记住这个是 Rust 让你能在编译时而不是运行时就能发现潜在的 bug，并告诉你问题在哪里，而你也不用在运行时才来找寻数据的问题到底在哪里。</p><h2 id="悬垂引用"><a href="#悬垂引用" class="headerlink" title="悬垂引用"></a>悬垂引用</h2><p>在具有指针的编程语言中，很容易错误地创建悬垂指针（dangling pointer）——指向内存中可能已经分配给其他对象的位置的指针——这是因为在释放一些内存时仍然保留指向该内存的指针。然而，在 Rust 中，编译器保证引用永远不会有悬垂引用：如果你拥有对某个数据的引用，编译器将确保在引用消失之前数据不会超出作用域。这为避免悬垂引用提供了安全保证。</p><p>让我们看一下当尝试创建一个悬垂引用时，Rust 在编译时会如何处理。</p><p>文件名：src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:5:16</span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">  |                ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from</span><br><span class="line">help: consider using the `&#x27;static` lifetime</span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;&#x27;static String &#123;</span><br><span class="line">  |                 +++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0106`.</span><br><span class="line">error: could not compile `ownership` due to previous error</span><br></pre></td></tr></table></figure><p>这里的报错提到了 Rust 的另一个特性：生命周期。将在<a href="https://doc.rust-lang.org/book/ch10-00-generics.html">第十章</a>谈论这个特性。</p><p>这里的错误消息里面也明确给出了编译不通过的原因：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help: this function&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from</span><br></pre></td></tr></table></figure><p>我们在代码中加一些注释来帮助理解一下 <code>dangle</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123; <span class="comment">// dangle 返回一个 String 的引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s 是一个新的 String 变量</span></span><br><span class="line">  </span><br><span class="line">    &amp;s <span class="comment">// 我们返回了一个变量 s 的引用</span></span><br><span class="line">&#125; <span class="comment">// s 超出作用域，并且调用 drop，自动释放内存</span></span><br></pre></td></tr></table></figure><p>因为 <code>s</code> 是在函数 <code>dangle</code> 内创建的，当 <code>dangle</code> 函数执行完成后，<code>s</code> 的内存将被释放。但是我们尝试返回一个 <code>s</code> 的引用，这意味着返回的这个引用指向的是无效的 String。这并不可行，Rust 建议这个函数这样写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就没问题了，返回时 s 的所有权会转移，当 <code>no_dangle</code> 执行完后，s 的内存也不会被释放。</p><h2 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a>引用的规则</h2><p>让我们复习一下以上关于引用的讨论：</p><ul><li>在任何时间点，你只能在声明一个可变引用和同时声明多个不可变引用之间二选一。</li><li>引用必须保证始终有效。</li></ul><p>接下来，我们将讨论一种不同的引用：切片。</p>]]></content>
      
      
      <categories>
          
          <category> 文档翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust入门:什么是Ownership?</title>
      <link href="posts/60dc43a19411.html"/>
      <url>posts/60dc43a19411.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是 rust 官方文档中所有权章节翻译的第一篇，原文地址：<a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html</a></p></blockquote><p>Ownership 是 rust 语言独有的特性，对 rust 语言的其他部分有着很深的影响。它保证 rust 在不需要垃圾回收（即开发人员常说的 GC，Garbage Collection），所以理解 Ownership 的工作机制是十分重要的。在本章中，我们将讨论 Ownership 及其相关的几个功能：borrowing、slices，以及 rust 的内存布局。</p><blockquote><p>译者注：</p><ul><li>borrowing 暂且翻译为借用，slices 暂且翻译为切片，后文不再专门说明。如果以后顿悟了，有更好的翻译再来改。</li><li>在不特别解释的情况下，本文中所说的所有权，就是指 Ownership。</li><li>后续的内容中会按原文加上个人理解进行翻译，如果有插入非原文翻译内容，会专门用”译者注：” 来标识。</li><li>有些名词还会在小括号中给出英文原文，比如：堆（原文：heap）。</li></ul></blockquote><h1 id="什么是-Ownership？"><a href="#什么是-Ownership？" class="headerlink" title="什么是 Ownership？"></a>什么是 Ownership？</h1><p>所有权是 rust 用于管理内存的一系列的规则。所有编程语言都必须要管理自己使用计算机内存的方式。有些语言有垃圾回收机制，在程序运行期间，会定期查找不再使用的内存；还有其他的一些语言，开发者必须明确分配、释放内存。Rust 使用了第三种方式：内存通过所有权系统进行管理，编译器有一套相应的检查规则。违背了任何规则，编译都会失败。所有权的任何特性都不会让程序的运行性能降低。</p><p>因为所有权对于大多数开发人员来说是一个新的概念，它确实需要一些时间来理解和适应。好消息是，你对 rust 的所有权机制的理解越深，你就越容易开发出安全高效的代码，请坚持下去。</p><p>当你了解了所有权，你就有了一个坚实的基础用于理解 rust 的独特之处。在这一章，你将通过常见的 string 数据结构相关的一些例子来学习所有权。</p><blockquote><p><strong>堆和栈：</strong></p><p>很多的编程语言并不要求你理解关于堆和栈相关的知识。但是在像 Rust 这种系统编程语言中，值定义在栈还是堆上，会影响语言的行为方式，以及相应的一些必须做出的决定。解关于堆和栈相关的所有权知识将在本章后面的内容讲解，这里先简单讲解一下，以备不时之需。</p><p>堆和栈都是程序运行时内存的一部分，但是它们的结构各不相同。栈按获取值的顺序有序存储，并按相反的顺序删除值，这被成为先进后出。想象有一堆盘子：当你添加盘子时，把新添加的盘子放到最上面，而你要取一个盘子时，也是从最上面取。从中间取或者放盘子则不是很好操作！添加数据到栈中的操作叫做压栈（原文：pushing onto），从栈中删除数据，叫做弹栈（原文：popping off）。所有存在栈上的数据必须要有固定且已知的大小。编译时大小未知或者大小会改变的数据必须存储在堆中。</p><p>堆的数据比较乱：当你将数据写入到堆中，会申请一部分内存空间。内存分配器会在堆中寻找一块空的、足够大的内存，并标记为已被使用，然后返回一个指针。这个处理过程，叫做在堆内存分配（原文：allocating on the heap），有时候也直接简单叫作分配（写数据到栈里面时不需要考虑内存分配问题）。因为返回的指针的大小是已知且固定的，所以可以将指针存储在栈上面，但是当你想要获取真实的数据时，就必须通过指针来获取真实数据。想象一下你们团队到餐厅聚餐，当你进餐厅时，会说明你们有多少人，服务员会为你找到一个足够大的桌子，如果团队中有人比你晚到，那么他只需要问你在几号桌就能找到你。</p><p>写数据到栈比写数据到堆中快，因为写数据到栈里面时，内存分配器不需要去搜索新的内存空间来存储新数据，新的数据都是直接存在栈顶的。相较而言，在堆上分配内存要做的工作更多，因为内存分配器首先要找到一块足够大的内存，然后还要记录下来，为下一次内存分配做准备。</p><p>在堆上访问数据比在栈上访问数据要慢，因为访问堆上的数据需要通过指针进行寻址。现代的处理器在内存中跳跃越少，处理得就越快。以此类推，想象一下服务员在餐厅的很多个餐桌上为顾客点菜。最高效的方式是在 A 桌点完所有菜之后，再到 B 桌点菜，这样保证在每一桌都是完成了所有的点菜工作之后，再到下一桌。如果一会儿在 A 桌点个菜，一会儿在 B 桌点个菜，一会儿又会 B 桌点个菜，这样反复的效率是很低的。同样的道理，一种情况是处理器要处理的数据离当前位置比较近（比如在栈上面），另一种情况是接下来要处理的数据离当前位置很远（比如在堆上），前者肯定比后者更快。</p><p>当程序调用了一个函数，函数的参数值（可能包含堆上数据的指针）和函数的本地变量都通过压栈的方式写入到栈中，当函数执行完成，这些数据会通过弹栈操作删除。</p><p>跟踪代码的每一部分使用了堆上的什么数据，让堆上的重复数据量最小化，及时清除无用的堆上数据以保证不会内存耗尽，这些都是所有权系统要解决的问题。一旦理解了所有权，你通常不需要考虑堆、栈的问题，但是了解所有权系统的目标是管理堆上的数据有助于解释并理解所有权系统的工作方式。</p></blockquote><h2 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h2><p>首先，我们看看所有权的规则。在学习本章的示例时，请记住这几个所有权的规则：</p><ul><li>Rust 中每一个值都有所有者（原文：Owner）。</li><li>每个值在每个时刻，只会数据一个所有者。</li><li>当所有者从作用域中离开时，值会被清除。</li></ul><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>现在我们已经学习了 Rust 的基本语法，所有后面的例子中不会再包含定义 main 函数的代码，所以如果你要继续往下学习的话，请手动讲例子中的代码写到 main 函数中。总之，我们的例子会比较简洁，让我们更关注真实的细节，而不是样板代码。</p><p>所有权的第一个例子，我们将研究变量的作用域问题。作用域是程序中某一部分的有效范围。定义以下的变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>变量 <code>s</code> 指向一个字符串，这个字符串的值是硬编码到了程序中的。这个变量的有效范围是从它声明的点开始，一直到当前的作用域结束。代码清单 4-1 通过注释解释了变量 s 的有效范围。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s 在这里是无效的，因为这里 s 还未声明</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// s 从这里开始有效</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明变量 s 之后的处理逻辑</span></span><br><span class="line">&#125;                      <span class="comment">// 作用域到这里就结束了，s 也不在有效</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码清单 4-1: 变量和它的有效作用域</p><p>换言之，这里有两个比较重要的点：</p><ul><li>当 s 进入作用域，它就有效。</li><li>在离开作用域前，它一定是有效的。</li></ul><p>到这里，作用域和和有效变量之间的关系和其他的编程语言是相似的。现在我们会基于当前所理解的知识，再来理解 String 类型。</p><h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><p>要理解所有权的规则，我们需要一种比第 3 章的“<a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#data-types">Data Types</a>”还要复杂的数据类型。之前讲到的所有数据类型都是大小已知，并且可以存储在栈上，当其从作用域离开时，可以从栈上删除，并且当代码的其他部分需要相同值而作用域不同时，可以很快速、琐碎得复制一个新的、完全独立的变量。但是我们想要的是存储在堆上数据，想要探究 Rust 是如何清理这些数据的，而 <code>String</code> 类型是一个很好例子。</p><p>我们的讨论会聚焦的 String 类型的所有权相关的知识。这些知识也适用于其他的一些复杂数据类型，不管它们是标准库创建的，还是第三方库创建的，或者是你自己所创建的。更深度的关于 String 的讨论请参看<a href="https://doc.rust-lang.org/book/ch08-02-strings.html">第 8 章</a>。</p><p>我们知道字符串的字面值都是硬编码到代码中（译者注：这里是指前面的代码清单 4-1）。当我们想要处理一些文本时，字符串字面值是很有用的，但是它并不是用于所有的场景，比如：我们想要存储用户输入的文本，要怎么办？这种场景下，Rust 有第二种解决方案，那就是 <code>String</code> 类型。这个类型的数据在堆上进行管理，所以它能存储支持在编译时大小不可知的文本。你可以使用 <code>from</code> 函数，通过一个字符串字面值来创建一个 String 类型的变量。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里的双引号 <code>::</code> 操作，允许我们将这个特定的 <code>from</code> 函数的命名空间放在 String 类型下，而不是使用类似 <code>string_from</code> 的名称。我们会在第 5 章的“<a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#method-syntax">Method Syntax</a>”一节讨论这个操作符号，刚提到的命名空间会在第 7 章的 “<a href="https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">Paths for Referring to an Item in the Module Tree</a>”一节进行讨论。</p><p>上面定义的这种字符串是可以随时发生改变的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>); <span class="comment">// push_str() 添加一个字面值到字符串中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 这里会输出: hello, world!</span></span><br></pre></td></tr></table></figure><p>这里到底有什么不一样？为什么 <code>String</code> 可以改变，而字符串字面值不能改变？区别在于这两种类型在内存的处理上不一样。</p><h2 id="内存-amp-分配"><a href="#内存-amp-分配" class="headerlink" title="内存 &amp; 分配"></a>内存 &amp; 分配</h2><p>在使用字符串字面值时，我们在编译时就知道它的内容，所以这些文本会硬编码到最终的可执行文件中。这也是字符串字面值既快又高效的原因。但是这些特点都因为它有这不可变的特性。不幸的是，对于在编译时大小未知，或者在运行时大小会发生变化的每一段文本，我们并不可能都分别放一块内存到二进制文件中。</p><p>对于 String 类型，为了支持可变、可增长的一段文本，我们需要在堆上分配一段内存（编译时未知）用来保存其内容，这意味着：</p><ul><li>这段内存必须在运行时向内存分配器申请。</li><li>当我们使用完这块内存之后，我们需要一种方式能够将内存返还给内存分配器。</li></ul><p>对于第一点，由我们自己完成：当我们调用 <code>String::from</code> 时，它的内部实现会申请所需要的内存。这在编程语言中是通用的行为。</p><p>然而，第二点却不是这样。在有 GC 的编程语言中，GC 会跟踪并清理没有被任何地方使用的内存，并且我们并不需要关心它。在大多数没有 GC 的编程语言中，我们需要知道内存何时不再使用，并且必须明确的释放这段内存，就像我们申请内存时那样。要正确做到这一点，在编程历史上一直是一个难题。如果我们忘了，将会浪费内存，如果我们提前释放了内存，那将会得到无效的标变量，而如果我们释放了两次内存，那就是一个 bug。我们需要保证恰好一个 allocate 调用对应一个 free 调用。</p><p> Rust 却选择了不同的路：一旦程序运行超出了变量的作用域，那么内存会自动释放。这是代码清单 4-1 的 String 版本：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s 从这里开始生效</span></span><br><span class="line"><span class="comment">// 声明变量 s 后的处理逻辑</span></span><br><span class="line">&#125; <span class="comment">// 作用域到此结束，s 不再有效</span></span><br></pre></td></tr></table></figure><p>当 s 超出作用域时，Rust 会自动调用一个特定的函数来释放内存，这个函数就是 <code>drop</code>，在 drop 函数中，String 类型变量的所有者可以放置代码来释放内存。Rust 会在闭合的花括号除自动调用 drop 函数。</p><blockquote><p><strong>Note：</strong></p><p>在C++中，将资源在项目生命周期的末尾释放的这种模式有时被称为”资源获取即初始化”（Resource Acquisition Is Initialization，RAII）。如果您使用过RAII模式，那么Rust中的drop函数会很熟悉。</p></blockquote><p>这种模式对于编写 Rust 代码有着深远的影响。这现在看起来很简单，但是当我们想让多个变量使用堆上的内存时，情况变得复杂。现在让我们来看一些例子。</p><h3 id="变量和数据交互：移动"><a href="#变量和数据交互：移动" class="headerlink" title="变量和数据交互：移动"></a>变量和数据交互：移动</h3><blockquote><p>译者注：这里的“移动”对应原文的单词是“move”。</p></blockquote><p>在 Rust 中，多个变量可以通过不同的方式和同一数据进行交互。我们一起看看代码清单 4-2：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure><p>代码清单 4-2：将 integer 值赋值给变量 <code>x</code> 和 <code>y</code></p><p>我们能猜到这里做了什么：绑定 <code>5</code> 到变量 <code>x</code>；然后复制 <code>x</code> 的值并绑定到变量 <code>y</code> 上。我们现有有两个都等于 5 的变量，x 和 y。事实确实是这样，因为 integer 是一种简单的、大小已知且固定的类型，所以这里的 <code>5</code> 是放在栈里面的。</p><p>接下来我们看一个 String 类型的版本：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure><p>这看起来和前面的代码很像，我们可能会认为它和前面的代码清单 4-2 是一样的工作流程，比如第二行是复制变量 s1 的值并绑定到变量 s2 上。但事实并非如此。</p><p>让我们看看图 4-1，探究这里的 String 到底发生了什么。一个 String 类型变量由图左边的 3 部分组成：一个指向内存中保存字符串内容的内存的指针，一个 length 用于记录字符串长度，一个 capacity 用于记录字符串的容量。这一组数据存储在栈上。右边的图是堆上用来保存字符串内容的内存。 </p><p><img src="http://image.hanelalo.cn/image/202306122255974.png" alt="图 4-1：String 变量 s1 的内存结构"></p><p>图 4-1：String 变量 s1 的内存结构</p><p>length 是当前 String 变量的字符串内容的内存使用量，单位是字节（byte）。capacity 是变量从内存分配器申请的内存总量，单位也是字节。length 和 capacity 的差异很重要，但是在这里我们不关注 capacity。</p><p>当我们为 s1 和 s2 赋值时，字符串的数据会复制一份，这里所说的复制，复制的是栈上的指针、length、capacity，并不会赋值指针所指向的堆中的数据，内存中的数据之间的关系就像图 4-2 这样：</p><p><img src="http://image.hanelalo.cn/image/202306122258484.png" alt="图 4-2：复制 s1 的指针、length、capacity 得到 s2"></p><p>图 4-2：复制 s1 的指针、length、capacity 得到 s2</p><p>并不会像图 4-3 这样，如果 Rust 将堆上的数据也复制一份，那么当数据非常大是，这中复制操作的代价是非常大的。</p><p><img src="http://image.hanelalo.cn/image/202306122303392.png" alt="图 4-3：当执行 s1 = s1 时，可能发生的其他情况"></p><p>图 4-3：当执行 s1 = s1 时，可能发生的其他情况</p><p>在前面，我们说当变量超出作用域时，Rust 会自动调用 drop 函数释放内存。但是在图 4-2 中，两个指针指向了同一份内存数据，这里的问题在于，当 s1 和 s2 都超出了作用域，它们都会尝试释放相同的内存。这是前面提到的两次释放同一块内存的安全漏洞。</p><p>为了保证内存安全，在 <code>let s2 = s1;</code> 这一行后面，Rust 会将变量 s1 置为无效，所以当 s1 超出作用域时，Rust 不用自动释放任何内存。你可以事实在 <code>let s2 = s1;</code> 之后再使用变量 s1，你会发现会报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br></pre></td></tr></table></figure><p>运行代码就会报错，因为使用了无效的变量。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling ownership v0.<span class="number">1.0</span> (file:<span class="comment">///projects/ownership)</span></span><br><span class="line">error[E0382]: borrow of moved value: `s1`</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">5</span>:<span class="number">28</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> |     <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  |         -- <span class="keyword">move</span> occurs because `s1` has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line"><span class="number">3</span> |     <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">  |              -- value moved here</span><br><span class="line"><span class="number">4</span> |</span><br><span class="line"><span class="number">5</span> |     <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br><span class="line">  |                            ^^ value borrowed here after <span class="keyword">move</span></span><br><span class="line">  |</span><br><span class="line">  = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` which comes from the expansion of the <span class="keyword">macro</span> `println` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br><span class="line">help: consider cloning the value <span class="keyword">if</span> the performance cost is acceptable</span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">  |                ++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0382`.</span><br><span class="line">error: could not compile `ownership` due to previous error</span><br></pre></td></tr></table></figure><p>如果你在使用其他编程语言时，通过深拷贝和浅拷贝这两个词，那可能会觉得 Rust 这种只复制指针、length、capacity 的形式是浅拷贝。但是因为 Rust 将第一个变量作废了，所以不叫作浅拷贝，这种操作在 rust 中叫做移动（原文：move）。在这个例子中，我们认为是变量 s1 移动到了变量 s2，所以，内存中真正发生的操作应是像图 4-4 这样的：</p><p><img src="http://image.hanelalo.cn/image/202306122325694.png" alt="图 4-4：当 s1 失效后的内存示意图"></p><p>图 4-4：当 s1 失效后的内存示意图</p><p>这里终于解开了我们的疑惑，当 s2 超出作用域时，将只有它会释放这部分内存。</p><p>此外，这也是 Rust 在设计上作出的一个选择：Rust 从来不会主动深拷贝数据。因此，可以认为运行时任何的拷贝都是不会耗费很多性能的。</p><h3 id="变量和数据的交互：克隆"><a href="#变量和数据的交互：克隆" class="headerlink" title="变量和数据的交互：克隆"></a>变量和数据的交互：克隆</h3><blockquote><p>译者注：这里的“克隆”对应原文单词是“clone”。</p></blockquote><p>如果我们想要在 rust 中使用深拷贝，而不是仅仅只复制栈上的数据，可以使用 <code>clone</code> 方法。我们会在第 5 章讨论方法的语法，但因为方法在所有编程语言中是一个比较通用的概念，可能你在此之前就已经了解它了。</p><blockquote><p>译者注：本文中“方法”对应的英文原文是“method”，“函数”对应的英文原文是 “function”。</p></blockquote><p>下面是一个使用 <code>clone</code> 方法的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br></pre></td></tr></table></figure><p>它能像图 4-3 描述的一样正常工作：会将堆上的数据也复制一份。</p><p>当看见调用 <code>clone</code> 方法时，应该意识到这里执行的代码是很耗费性能的。</p><h3 id="栈上数据：复制"><a href="#栈上数据：复制" class="headerlink" title="栈上数据：复制"></a>栈上数据：复制</h3><p>下面的代码清单 4-3 使用了 integer，奇妙的是，它能正常运行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><p>这段代码按理说是有问题的，因为它并没有调用 clone 方法，但是 x、y 竟然依然都是有效的变量，换句话说，x 似乎并没有移动（move）到 y 上。</p><p>这是因为这里使用的 integer 类型的的长度在编译时就是已知且固定的，会保存在栈上，所以复制它的值就变得十分容易，这意味着当声明了变量 y 之后我们没必要让变量 x 失效。换句话说，这里没有深拷贝、浅拷贝之分，就算调用了 clone 方法，其实也和浅拷贝没区别。</p><p>Rust 有一个叫 Copy 的 trait（译者注：trait 可参见<a href="https://doc.rust-lang.org/book/ch10-02-traits.html%EF%BC%89%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%BA%86%E8%BF%99%E4%B8%AA">https://doc.rust-lang.org/book/ch10-02-traits.html），使用了这个</a> Copy 注解的类型，就会放在栈上面，就像 Integer 一样。如果一个类型使用了 Copy 的注解，它的变量将不会被 move，而是会被复制，当它的值被赋值给其他变量后，原来的变量依然还是有效的。</p><p>如果一个类型已经实现了 Drop trait，Rust 将不会允许该类型或者该类型的某一部分使用 Copy 注解，否则将会产生编译错误。要学习如何在你的自定义类型上使用 Copy 注解，可以看附录 C 的“Derivable Traits”一节。</p><p>你可以查看官方文档以确定哪些类型使用了 Copy trait，但是通常情况下，任何的标量值类型都可以使用 Copy trait。如果是需要分配资源，或者本身就是某种形式的资源的类型，肯定不能使用 Copy trait。</p><p>下面是一些使用了 Copy trait 的类型：</p><ul><li>所有的 integer 类型，比如 u32。</li><li>boolean 类型。</li><li>所有的浮点型，比如 f64。</li><li>字符类型。</li><li>tuple 类型，如果包含的类型都是实现了 Copy，则可以使用 Copy trait。比如 <code>(i32, i32)</code> 可以，而 <code>(i32, String)</code> 不行。</li></ul><h2 id="所有权和函数"><a href="#所有权和函数" class="headerlink" title="所有权和函数"></a>所有权和函数</h2><p>传一个参数值到函数中，和给一个变量赋值相似。函数传参会 move 或者复制，就像变量赋值一样。代码清单 4-3 中的例子通过注释解释了变量什么时候进入作用域，什么时候出作用域。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s</span>  = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s 进入作用域</span></span><br><span class="line">  <span class="title function_ invoke__">takes_ownership</span>(s); <span class="comment">// s 的值 move 到这个函数中</span></span><br><span class="line">  <span class="comment">// 所以 s 在这里无效了</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;<span class="comment">// x 进入作用域</span></span><br><span class="line">  <span class="title function_ invoke__">makes_copy</span>(x);<span class="comment">// x 会 move 进这个函数中</span></span><br><span class="line">  <span class="comment">// 但是因为 x 是 i32 类型的，所以到这里依然可以使用 x</span></span><br><span class="line">&#125; <span class="comment">// 到这里，x 超出作用域，然后是 s，但是 s 的值已经 move 了，所以这里不会针对 s 发生任何事情</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入作用域</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// 到这里，some_string 超出作用域，自动调用 drop，切内存被释放。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// 到这里 some_integer 超出作用域，无事发生</span></span><br></pre></td></tr></table></figure><p>代码清单 4-3：函数和所有权</p><p>如果我们在调用了 <code>takes_ownership</code> 后再尝试使用变量 <code>s</code>，Rust 会抛出一个编译一场，这个静态检查会防止写出 bug。尝试在 main 函数中添加代码来使用 <code>s</code> 和 <code>x</code>，看看你可以在哪里使用它们，而 Rust 又会在哪里阻止你使用它们。</p><h2 id="返回值和作用域"><a href="#返回值和作用域" class="headerlink" title="返回值和作用域"></a>返回值和作用域</h2><p>返回一个值，也会发生所有权的转换。代码清单 4-4 的代码和代码清单 4-3 一样使用注释解释了有返回值的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership 将它的返回值 move 到 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 move 到 takes_and_gives_back 中，这里也会将它的返回值 move 到 s3</span></span><br><span class="line">                                        </span><br><span class="line">&#125; <span class="comment">// s3、s1 超出作用域并释放内存，s2 已经 move 了，所以无事发生</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;             <span class="comment">// gives_ownership 会将返回值 move 到调用它的地方</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>); <span class="comment">// some_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// some_string 被返回，并 move 到调用的地方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line">                                                      </span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// a_string 被返回并 move 到调用的地方</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码清单 4-4：返回值的所有权转让</p><p>所有权会已知遵循相同的模式：赋值给另一个变量，将会将它 move 走。当一个在堆上有数据的变量超出作用域时，如果它的值没有 move 到其他变量上，那么堆上的数据将会被清除。</p><p>虽然这种方式可以运行，但是在每个函数中获取所有权并返回所有权的过程有点繁琐。如果我们只想让函数使用一个值而不获取所有权，那会变得相当麻烦。除了我们可能希望返回函数体中生成的数据之外，我们还需要将传入的值再次传递回去，以便之后继续使用。</p><p>Rust 允许我们的函数返回一个 tuple，比如下面的代码清单 4-5：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s2, len) = <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = s.<span class="title function_ invoke__">len</span>(); <span class="comment">// len() returns the length of a String</span></span><br><span class="line"></span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码清单 4-5：返回参数的所有权</p><p>但是对一个本就应该支持的常规操作来讲，这操作太复杂，幸运的是，Rust 有一个特性可以支持使用值，而不用转让所有权，这个特性就是引用。</p>]]></content>
      
      
      <categories>
          
          <category> 文档翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust入门:控制流</title>
      <link href="posts/66a763520737.html"/>
      <url>posts/66a763520737.html</url>
      
        <content type="html"><![CDATA[<p>本文会讲到 <code>if</code>、 <code>loop</code>、<code>while</code>、<code>for</code>语法，还会讲到在 rust 中的一些特殊语法，以及在使用上和其他编程语言的一些不同的地方。</p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>if 语句的语法其实没什么特殊的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x==<span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> x == <span class="number">1</span>&#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是需要注意的是，在某些编程语言中对于下面这种写法也是支持的，但是在 rust 中并不支持：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> x &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如在 js 语言中，这里 x 如果等于 0，那就是 false，否则就是 true，但在 rust 中，编译就会报错。</p><p>然后，在对某个变量赋值时，如果需要根据条件进行赋值的话，也能通过 <code>if...else...</code> 的形式进行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="keyword">if</span> condition &#123;<span class="number">5</span>&#125; <span class="keyword">else</span> &#123;<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，这里的 x，不论最后是 5 还是 6，最终的变量变量类型都是确定的，只是值不确定而已，如果 if 和 else 返回的值的类型不一致，是否支持呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val</span> = <span class="keyword">if</span> a == <span class="number">3</span> &#123;<span class="number">5</span>&#125; <span class="keyword">else</span> &#123;<span class="string">&quot;six&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value of val is:&#123;val&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">error[E0308]: `<span class="keyword">if</span>` and `<span class="keyword">else</span>` have incompatible types</span><br><span class="line">  --&gt; src/main.rs:32:35</span><br><span class="line">   |</span><br><span class="line">32 |     <span class="built_in">let</span> val = <span class="keyword">if</span> a == 3 &#123;5&#125; <span class="keyword">else</span> &#123;<span class="string">&quot;six&quot;</span>&#125;;</span><br><span class="line">   |                          -        ^^^^^ expected <span class="built_in">integer</span>, found `&amp;str`</span><br><span class="line">   |                          |</span><br><span class="line">   |                          expected because of this</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0308`.</span><br></pre></td></tr></table></figure><p>因为 if 和 else 的返回值类型不一致，所以编译会直接报错。</p><h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><p><code>loop</code> 看名称就能知道这是一种循环结构的语法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个简单的 loop 循环体结构，一旦运行，它就是会不停地输出 “Hello”，知道按下 Ctrl + C 才会停止，换句话说，这就是一个死循环。</p><p>rust 提供了 break 语句用来退出循环。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of result is:&#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是定义了一个可变的 counter 变量，然后每次循环会将 counter 加 1，如果 counter 等于 10，循环结束，并将 counter 的值乘以 2 作为返回值，返回值会赋值给 result 变量。</p><p>首先是，就以往的编程经验而言，这里的 <code>break counter * 2;</code> 改成 <code>return counter * 2;</code> 应该是可行的，但是实际上并不行，中介 loop 循环必须使用 break，如果有返回值的话，也必须写在 break 后面，且有分号在最后，以构成一个完整的 Statement。</p><blockquote><p>因为这里不支持 <code>return conunter * 2;</code> 这种写法，所以其实也是不支持直接写 <code>counter * 2</code> 这种写法的。</p></blockquote><p>然后就是，多重循环的退出问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">  <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> condition &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 break 只能退出内层循环，而外层循环只能等循环结束，或者为外层循环写一个 break。</p><p>在 rust 中，可以为 loop 命名，break 语句可以指定退出的是哪个循环。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;count&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;End count = &#123;count&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">count = 0</span><br><span class="line">remaining = 10</span><br><span class="line">remaining = 9</span><br><span class="line">count = 1</span><br><span class="line">remaining = 10</span><br><span class="line">remaining = 9</span><br><span class="line">count = 2</span><br><span class="line">remaining = 10</span><br><span class="line">End count = 2</span><br></pre></td></tr></table></figure><p>采用 <code>&#39;counting_up: loop &#123;&#125;</code> 的形式对 loop 进行命名， <code>&#39;counting_up:</code> 就是为 loop 命名的语法，前面的 <code>&#39;</code> 和后面的冒号都是必须，中间则是名称。</p><p>而在 break 指定退出的循环时，使用 <code>break &#39;counting_up;</code> 语法即可。 </p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> count != <span class="number">10</span> &#123;</span><br><span class="line">        count+=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count is &#123;count&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">7</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">count is 1</span><br><span class="line">count is 2</span><br><span class="line">count is 3</span><br><span class="line">count is 4</span><br><span class="line">count is 5</span><br><span class="line">count is 6</span><br><span class="line">count is 7</span><br></pre></td></tr></table></figure><p>while 循环相对来说就比较好理解了，其结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition &#123;</span><br><span class="line"><span class="comment">// loop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>condition 为 true 就执行一次循环逻辑，然后再判断 condition 是否为 true，直到 condition 为 false 时，while 循环才会结束。</p><p>当然，在循环体内，依然可以使用 break 来终止循环。</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>rust 的 for 循环结构体是 <code>for val in vals &#123;&#125;</code> 形式的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arrays</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">arr</span> <span class="keyword">in</span> arrays &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;arr&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">6</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;i&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html">The Rust Programming Language</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust入门:函数</title>
      <link href="posts/4ea40c7b8deb.html"/>
      <url>posts/4ea40c7b8deb.html</url>
      
        <content type="html"><![CDATA[<p>rust 不同于其他的编程语言，rust 有明确的 statement 和 expression 的概念。本文首先将讲解函数的定义，然后会解释 rust 中 statement 和 expression 的区别，然后进一步的了解函数的返回值的写法相关的知识。</p><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>在 rust 中，定义函数的关键字是 <code>fn</code>，一个函数应包括函数名称、函数参数、函数返回值类型、函数体。</p><p>比如多次出现的 main 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="comment">// something code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fn</code> 关键字表明当前是定义一个函数，<code>main</code> 是函数名称、<code>()</code> 里面是函数参数，只不过 main 函数没有参数，<code>&#123;&#125;</code> 里面则是函数要执行的内容。</p><p>我们再看一个要素比较齐全的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">do_something</span>(x:<span class="type">i32</span>, y:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">  <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>(x:i32, y:i32)</code> 表示 <code>do_something</code> 这个函数的参数是两个 i32 类型的参数，参数名称分别为 x、y，<code>-&gt; i32</code> 则是表示 <code>do_something</code> 函数的返回值类型为 i32 类型。</p><p>函数的调用倒是和其他常见的语言一样，就不赘述了。</p><blockquote><p>之所以不赘述，是因为我觉得 rust 根本就不适合作为编程入门的第一门语言。</p></blockquote><h2 id="关于-statement、expression"><a href="#关于-statement、expression" class="headerlink" title="关于 statement、expression"></a>关于 statement、expression</h2><p>在 rust 中，有明确的 statment、expression 的定义。</p><ul><li>Statement，是用于说明做了什么事，但并没有返回值。</li><li>Expression，计算得到一个结果值，Expression 是 Statement 的一部分。</li></ul><p>是不是有点迷糊？</p><p>举个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>这是一个 statement，它做的事是：定义一个变量 x，并将变量 x 赋值为 6，换句话讲，只能说 x 的值是 6，不能说赋值这个动作的结果是 xxx。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这是一个 expression，如果 x 等于 6，那么这个 expression 的计算结果就是 7。</p><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>在 rust 中，按照以往的编程语言的经验，我们定义一个函数可能是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>(a:<span class="type">i32</span>, b:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样没问题，但是，会发现下面这两种竟然也能正常返回：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>(a:<span class="type">i32</span>, b:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b <span class="comment">// 少了最后的分号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>(a:<span class="type">i32</span>, b:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a+b <span class="comment">// 不仅分号没了，连 return 关键字都省了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为在这里 <code>a+b</code> 是一个 expression，本身是有返回值的。</p><blockquote><p>前面讲到 expression 是有返回值的，所以我个人理解，它还隐含了 <code>return</code> 的语义在里面。</p></blockquote><p>那如果我在没有 return 关键字的情况下，在后面加上一个分号呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>(a:<span class="type">i32</span>, b:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 <code>cargo checkh</code> 就会有报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types</span><br><span class="line">  --&gt; src/main.rs:33:25</span><br><span class="line">   |</span><br><span class="line">33 | fn sum(a:i32, b:i32) -&gt; i32 &#123;</span><br><span class="line">   |    ---                  ^^^ expected `i32`, found `()`</span><br><span class="line">   |    |</span><br><span class="line">   |    implicitly returns `()` as its body has no tail or `return` expression</span><br><span class="line">34 |     a+b;</span><br><span class="line">   |        - help: remove this semicolon to return this value</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0308`.</span><br></pre></td></tr></table></figure><p>大概意思反正就是这里的需要一个 return 的 expression。</p><p>那么，就可以认为，当不加最后的分号时，<code>a+b</code>是一个 expression，本身有 return 语义存在，而价格分号之后，<code>a+b;</code> 变成了 statement，没有返回值了，也就没有 return 的语义在里面了，所以才会编译不通过。</p><blockquote><p>关于 statement、expression 这两个其实还是有点让人迷糊的，但是只要记住 rust 中这种函数 return 的写法就行了。</p></blockquote><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://doc.rust-lang.org/book/ch03-03-how-functions-work.html">The Rust Programming Language</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust入门:数据类型</title>
      <link href="posts/c7b7e6a95edf.html"/>
      <url>posts/c7b7e6a95edf.html</url>
      
        <content type="html"><![CDATA[<p>rust 的数据类型分为基础类型和复合类型。</p><blockquote><p>官方文档说的是 Scalar 和 Compound。</p></blockquote><p>其中 Scalar 类型有 4 种：</p><ol><li>integer，整数。</li><li>Floating-point numbers，浮点数。</li><li>Booleans，布尔类型。</li><li>Characters，字符类型。</li></ol><blockquote><p>对应 Java 中的 byte、short、int、long、float、double、boolean、char。</p></blockquote><p>Compound 可以将多个值分为一个类型。rust 原生提供的 Compound 类型有 2 种：</p><ol><li>Tuples 类型。</li><li>Arrays 类型。</li></ol><blockquote><p>对应 Java 中的数组。</p></blockquote><h2 id="Integer-类型"><a href="#Integer-类型" class="headerlink" title="Integer 类型"></a>Integer 类型</h2><p>Integer 类型分有符号、无符号两大类，每一类又根据内存占用分成 5 种。</p><table><thead><tr><th>Memory</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody><tr><td>8 bit</td><td>i8</td><td>u8</td></tr><tr><td>16 bit</td><td>i16</td><td>u16</td></tr><tr><td>32 bit</td><td>i32</td><td>u32</td></tr><tr><td>64 bit</td><td>i64</td><td>u64</td></tr><tr><td>128 bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table><p>其中 arch 一栏，不管是使用 isize 类型还是 usize 类型，占用的内存取决于 rust 的运行环境，如果是在 64 位操作系统环境下，isize、usize 就和 i64、u64 一样，如果是运行在 32 位操作系统环境下，isize、usize 就和 i32、u32 一样。</p><p>因为没种类型的内存占用有限制，所以没中类型能够表示的数值大小也是有范围的，如果占用内存是 n bit，则有符号的类型的取值范围是 <code>-(2^(n-1)) ~ 2^(n-1)-1</code>，无符号类型的取值范围是 <code>0 ~ 2^n - 1</code>。</p><blockquote><p>既然有上限，那势必会有溢出的时候，在 rust 中，如果是 debug 模式，integer 类型的变量溢出的话，会终止程序运行，而在 release 模式下，则默认不会终止程序，而是会把取值范围当成一个圈来处理。什么意思呢？比如 <code>u8</code> 类型的取值范围是 0 ～ 255，那么当一个 <code>u8</code> 类型的变量被赋值位 256 时，实际得到的值为 0，如果赋值为 257，则实际值为 2，以此类推。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span>: <span class="type">u8</span> = <span class="number">255</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is:&#123;x&#125;&quot;</span>);</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is:&#123;x&#125;&quot;</span>);</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is:&#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 debug 模式下运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">The value of x is:255</span><br><span class="line">thread <span class="string">&#x27;main&#x27;</span> panicked at <span class="string">&#x27;attempt to add with overflow&#x27;</span>, src/main.rs:15:9</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>在 release 模式下运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run --release</span><br><span class="line">The value of x is:255</span><br><span class="line">The value of x is:0</span><br><span class="line">The value of x is:1</span><br></pre></td></tr></table></figure></blockquote><p>Integer 类型的字面值支持十进制、十六进制、八进制、二进制、byte 这 5 种。</p><table><thead><tr><th>子面值类型</th><th>示例</th></tr></thead><tbody><tr><td>十进制</td><td>98_222、98222</td></tr><tr><td>十六进制</td><td>0xff</td></tr><tr><td>八进制</td><td>0o77</td></tr><tr><td>二进制</td><td>0b111</td></tr><tr><td>byte</td><td>b’A’</td></tr></tbody></table><p>其中 byte 只支持 <code>u8</code> 类型。</p><h2 id="Floating-Point-Numbers-浮点数类型"><a href="#Floating-Point-Numbers-浮点数类型" class="headerlink" title="Floating-Point Numbers 浮点数类型"></a>Floating-Point Numbers 浮点数类型</h2><p>浮点数类型只有 <code>f32</code>、<code>f64</code> 两种类型，都是有符号的类型。不明确指定的情况下，默认是 f64 类型，因为现在的 cpu 上，f32 和 f64 性能一样，但是 f64 有更高的精度。 </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">2.0</span>; <span class="comment">// f32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="boolean-类型"><a href="#boolean-类型" class="headerlink" title="boolean 类型"></a>boolean 类型</h2><p>当一个变量赋值为 true 或者 false 时，自动就会定义为布尔类型，只不过在 rust 里面布尔类型的类型关键字是 <code>bool</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="literal">true</span>; <span class="comment">//bool</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>:<span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">//bool</span></span><br></pre></td></tr></table></figure><p>在 rust 中，布尔类型只能是 true 或者 false，只会占用 1 byte 的内存。</p><h2 id="Character-类型"><a href="#Character-类型" class="headerlink" title="Character 类型"></a>Character 类型</h2><p>Rust 中，字符类型使用单引号，而字符串使用双引号。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 字符类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="string">&quot;A&quot;</span>; <span class="comment">// 字符串类型</span></span><br></pre></td></tr></table></figure><p>并且，字符类型采用的是 Unicode 编码，换句话说，它的值并不是只在 ASCII 码表的范围内，它可能是一个中文、英文、日文、韩文字符，甚至还能是一个 emoji。</p><h2 id="Tuple-类型"><a href="#Tuple-类型" class="headerlink" title="Tuple 类型"></a>Tuple 类型</h2><p>tuple 类型可以包含多个不同类型的值，但是，tuple 类型的长度是固定的，从定义 tuple 类型变量时指定，此后不能修改。</p><p>定义一个 tuple 类型的变量的语法如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>,<span class="type">f64</span>,<span class="type">bool</span>) = (<span class="number">16</span>,<span class="number">3.14</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">16</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>对于 tuple 的定义，也可以不显式指定类型。</p><p>在从 tuple 中取数据时，有两种方式。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>,<span class="type">f64</span>,<span class="type">bool</span>) = (<span class="number">16</span>,<span class="number">3.14</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">let</span> (quantity, price, paid) = tup;</span><br></pre></td></tr></table></figure><p>一种是定义相同数量的变量，直接从 tup 中取值，<code>(quantity, price, paid)</code> 的括号是必须的。</p><p>一种则是按索引的方式取值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>,<span class="type">f64</span>,<span class="type">bool</span>) = (<span class="number">16</span>,<span class="number">3.14</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">quantity</span> = tup.<span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">price</span> = tup.<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">paid</span> = tup.<span class="number">2</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Quantity:&#123;quantity&#125;,price:&#123;price&#125;,Paid:&#123;paid&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>和其他编程语言一样，索引下标也是从 0 开始。</p><h2 id="Array-数组类型"><a href="#Array-数组类型" class="headerlink" title="Array 数组类型"></a>Array 数组类型</h2><p>array 和 tuple 类似，只不过 array 要求其中的元素必须都是同一个类型，同样，array 的长度也是固定的。</p><p><strong>要定义一个 array 只需要用中括号将元素括起来，每个元素之间用逗号分割即可。</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>还有明确指定元素的数据类型和 array 的长度的方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>:[<span class="type">i32</span>;<span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>这里<code>[i32;5]</code> 的意思是定义一个元素类型为 i32，长度为 5 的数组。</p><p>最后，还有直接指定数组长度和初始化值的定义方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">3</span>; <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>这里的 <code>[3; 5]</code> 的意思是数组中的元素初始值为 3，数组长度为 5，所以这里的 arr 实际的值应该是 <code>[3, 3, 3, 3, 3]</code>。</p><blockquote><p>到目前位置，讲到的 tuple 和 array 都是长度不可变的，对于需要动态改变长度的数组，rust 提供了 vector 类型，这个在后面会讲到。</p></blockquote><p>然后我们再看看，要如何访问数组中的值。</p><p>如果是数组的话，倒是和 Java 一样，用 <code>arr[i]</code> 的形式就能随机访问数组中的元素。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The first item in arr is:&#123;&#125;&quot;</span>,arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The second item in arr is:&#123;&#125;&quot;</span>,arr[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The first item in arr is:1</span><br><span class="line">The second item in arr is:3</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://doc.rust-lang.org/book/ch03-02-data-types.html">The Rust Programming Language</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust入门:变量和常量</title>
      <link href="posts/78d5f302f768.html"/>
      <url>posts/78d5f302f768.html</url>
      
        <content type="html"><![CDATA[<h2 id="Rust-介绍"><a href="#Rust-介绍" class="headerlink" title="Rust 介绍"></a>Rust 介绍</h2><p>rust 是一种内存安全的、无内存 GC 的编程语言。在性能上远超 Java，甚至比 C++ 还要快，和 C 语言比起来虽然有差距但是并不大。</p><p>rust 没有像 Java 这种语言的 GC 机制， Java 是异步回收，最明显的弊端就是 Stop The World 的强制停顿，虽然近年来的 G1、ZGC 等垃圾收集器有明显改善，但依然有停顿。而 rust 也是存在内存释放的机制的，等到后续更深入的学习再详细讲解。</p><p>rust 虽然有优点，比如安全，甚至能保证只要编译通过，代码基本就不会有安全问题。相应的，学习曲线比较陡峭，比如其中的所有权、不可变的变量等机制更是让人难以掌握。</p><blockquote><p>如果你发现自己学会了 rust，那么大概率还处于入门都还算不上的阶段。</p></blockquote><h2 id="安装-Rust"><a href="#安装-Rust" class="headerlink" title="安装 Rust"></a>安装 Rust</h2><p>如果是在 MacOS 或者 Linux 上，可以使用下面的脚本进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure><p>安装完成后，会有下面一行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rust is installed now. Great!</span><br></pre></td></tr></table></figure><p>这里其实还安装了一个叫 <code>rustup</code> 的工具。<code>rustup</code> 是一个用来管理 rust 版本的命令行工具。后续可以使用 <code>rustup update</code> 命令来升级 rust 的版本。</p><p>然后执行下面的指令，检查 rust 是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rustc --version</span><br></pre></td></tr></table></figure><p>然后再检查一下 rust 的包管理器 cargo 是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo --version</span><br></pre></td></tr></table></figure><h2 id="从”Hello-World”开始"><a href="#从”Hello-World”开始" class="headerlink" title="从”Hello World”开始"></a>从”Hello World”开始</h2><p>Rust 的源代码文件是 <code>.rs</code> 格式的，和 Java 类似，有一个 main 函数作为整个程序的入口。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存了 main.rs 之后，执行 <code>rustc main.rs</code>，会发现出现了一个 main 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rustc main.rs</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">mainmain.rs</span><br></pre></td></tr></table></figure><p>这里的 main 文件是一个可执行文件，直接执行看看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>像这样单个文件还行，但是如果是要真正做一个 rust 开发的项目的话，势必会有很多包以来，所以一般都是使用 cargo，而不是 rustc。</p><p>使用 cargo 的话，首先得通过 cargo 新建一个项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new hello_world</span><br></pre></td></tr></table></figure><p>然后进入项目会发现有以下目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello_world\</span><br><span class="line">src\</span><br><span class="line">main.rs</span><br><span class="line">Cargo.toml</span><br></pre></td></tr></table></figure><p>src 是源代码目录，Cargo.toml 是项目的配置文件，其中包括项目的一些元数据，以及项目要依赖的第三方包（暂且叫包吧，其实在 rust 里面不叫包）。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cargo.toml</span></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_world&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure><p>接下来会介绍 3 个 cargo 的命令：</p><ul><li><p>cargo build</p><p>构建项目，这时会导入项目的依赖，并生成一个 target 文件夹，在 target/debug 文件夹中有一个和项目同名的可执行文件，同时，还会生成一个 Cargo.lock 文件，这个文件用于稳定项目的依赖，因为 cargo 支持语意化的版本管理，比如 <code>^0.8.0</code> 这种写法，并不是指定版本是 0.8.0，而是版本至少是 0.8.0，但必须小于 0.9.0，而项目依赖的版本将在第一次 build 时确定，为了保证稳定性，依赖的具体版本讲通过 Cargo.lock 文件进行锁定，后面不管重新 build 多少次，版本都不会变。</p><p>普通的 cargo build 是开发时使用的，如果要编译生成 release 版本，应该之中 <code>cargo build --release</code> 或者 <code>cargo build -r</code>，会在项目目录下生成 release 文件夹。</p></li><li><p>cargo check</p><p>cargo check 则是检查你的代码是不是可执行的，并不会生成可执行文件。</p></li><li><p>cargo run</p><p>编译代码，并执行，相当于执行 <code>cargo build</code> 之后，再执行生成的可执行文件。</p></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量不能变？"><a href="#变量不能变？" class="headerlink" title="变量不能变？"></a>变量不能变？</h3><p>先看一个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is:&#123;x&#125;&quot;</span>);</span><br><span class="line">x = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is:&#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候会编译失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error[E0384]: cannot assign twice to immutable variable `x`</span><br><span class="line"> --&gt; src/main.rs:4:5</span><br><span class="line">  |</span><br><span class="line">2 |     let x = 5;</span><br><span class="line">  |         -</span><br><span class="line">  |         |</span><br><span class="line">  |         first assignment to `x`</span><br><span class="line">  |         help: consider making this binding mutable: `mut x`</span><br><span class="line">3 |     println!(&quot;The value of x is:&#123;x&#125;&quot;);</span><br><span class="line">4 |     x = 6;</span><br><span class="line">  |     ^^^^^ cannot assign twice to immutable variable</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0384`.</span><br></pre></td></tr></table></figure><p>大概意思是不能为不可变的变量赋值两次。</p><p>在 rust 里面，变量默认是不可变的，换句话说，变量一旦赋值，就不能再重新赋值。</p><p>rust 提供了 <code>mut</code> 关键字来标识某个变量是可变的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is:&#123;x&#125;&quot;</span>);</span><br><span class="line">x = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is:&#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，编译就不会报错了。</p><h3 id="一段代码里面还能有同名的变量？"><a href="#一段代码里面还能有同名的变量？" class="headerlink" title="一段代码里面还能有同名的变量？"></a>一段代码里面还能有同名的变量？</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is:&#123;x&#125;&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is:&#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码先定义一个变量 x，赋值为 5，然后又重新定义了变量 x，赋值为 “Hello World”，按照以往的编程的习惯，这里应该会报错才对，但是在 rust 中依然能编译成功。</p><p>这里不仅是名字一样，变量的数据类型也从 i32 变成了 String 类型。rust 里面把这种机制叫做 shadow。个人理解应是遮蔽的意思，就是第二次定义的变量将第一次定义的变量遮住了，所以后续使用时只能看见第二次定义的变量。</p><blockquote><p>我觉得这样做能减缓一点变量命名困难的病。。。</p></blockquote><p>在 rust 中，变量也有scope 的概念，即作用域，而 shadow 机制还会受到 scope 的影响。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is:&#123;x&#125;&quot;</span>);</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is:&#123;x&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is:&#123;x&#125;&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of inner x is:&#123;x&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is:&#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling variables v0.1.0 (/Users/hanelalo/develop/rust-labs/variables)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.14s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x is:5</span><br><span class="line">The value of x is:6</span><br><span class="line">The value of x is:7</span><br><span class="line">The value of inner x is:14</span><br><span class="line">The value of x is:7</span><br></pre></td></tr></table></figure><p>可以看见的是，对于变量的 shadow 只在当前的 scope 中有效，从当前的 scope 离开后，就不存在 shadow 了。</p><p>所以，最后打印出来的 x 的值依然是 7，而不是 14。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量和不可变的变量有点像，但也有些区别：</p><ul><li>常量不允许使用 mut 关键字，因为常量是任何情况下都不可变，并不是像变量那样默认不可变。</li><li>常量使用 const 关键字定义，而不是 let。</li><li>常量必须明确指定数据类型。</li></ul><p>前面两点比较好理解，针对第 3 点给个例子，比如变量的定义可以是 <code>let x = 5</code>，会自动识别成 <code>i32</code> 的数据类型，或者也可以明确指定类型 <code>let x:i32 = 5</code>，换句话说，定义变量时，数据类型可以不指定，由 rust 自行判断类型，而定义常量则不行，必须指定类型：<code>const MAX_ALLOW_REQUEST_PER_SECOND:i32 = 10000</code>。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a href="https://rust-book.cs.brown.edu/ch01-01-installation.html">The Rust Programming Language</a></p></li><li><p><a href="https://semver.org/lang/zh-CN/">语义化版本</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch:简介</title>
      <link href="posts/4b946e6bf8b6.html"/>
      <url>posts/4b946e6bf8b6.html</url>
      
        <content type="html"><![CDATA[<h1 id="Elasticsearch-简介"><a href="#Elasticsearch-简介" class="headerlink" title="Elasticsearch 简介"></a>Elasticsearch 简介</h1><p>Elasticsearch 是一个分布式的文档存储系统。内部将文档序列化成 JSON 格式进行存储，如果集群中有多个节点，一旦数据被存储，可以从任何一个节点上访问到本存储的数据。</p><p>但是，因为一些内部机制的实现，所以 Elasticsearch 的搜索功能是一个<strong>近实时</strong>的功能，一般在 1 秒内。换句话讲，当数据写到 Elasticsearch 后，可能在 1 秒内还无法查询到。</p><blockquote><p>关于近实时的原因，本系列后续的文章会讲到。</p></blockquote><blockquote><p>在本系列的内容中，<code>es</code>、<code>ES</code> 在无特殊说明情况下，均指 Elasticsearch。</p></blockquote><h2 id="文档、索引"><a href="#文档、索引" class="headerlink" title="文档、索引"></a>文档、索引</h2><p>在 es 中，一条数据可以理解成 MySQL 中的一条数据，每条数据中又包含了很多字段，每个字段有自己的数据类型。</p><p>索引，有两种含义。当用作名词的时候，指的是相同类型的文档的集合，就相当于是 MySQL 中的表；当用作动词时，指的是将文档写入 es，这个过程 es 会建立倒排索引。</p><p>在MySQL 中每个字段都需要指定数据类型，而 es 中则可以选择不指定，而是让 es 自己进行探测，来决定每个字段是什么类型，但是，相同字段在不同文档中，不能是不同的类型。而对于字段类型，也可以自行指定，比如时间的存储格式。这就是每个索引创建时，可以指定的 mappings。</p><p>es 存储文档的时候，不同的字段类型，存储的方式也可能不同，比如 text 类型的字段存储在倒排索引中，而 number、geo 类型则是存储在 BKD 树中。</p><blockquote><p>倒排索引：记录每个单词（es 内部会对字段值做分词）出现过的文档列表。</p><p>BKD 树：说实话，网上找了好几篇文章看，都没看懂原理，大概意思是，能够支持动态数据的多维度搜索，比如像二叉树，其实是一维的搜索，为了支持多维搜索，衍生了 KD 树，但是 KD 树作为树不能自平衡，导致搜索效率低，浪费资源，又整合 B 树，衍生了 KDB 树，但是哪怕发展到了 KDB 树，也依然只支持静态数据的搜索，所以又整合 B+ 树，取二叉树、B 树、B+ 树、KD 树的优点，最后才发展成了 BKD 树，支持动态数据的多维度搜索。</p><p>这里的 D 是 Dimensional 的意思，比如平时说的 3D 的 D 大致就是这个词。</p><p>es 并不是在诞生支持就支持了 BKD 树，Lucene 也是在 6.0 才开始支持 BKD 树。</p></blockquote><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p>基于存储时对不同数据类型的存储优化，es 不仅支持类似 MySQL 的针对特定字段的查询，还支持了全文检索。</p><p>es 提供了简单易用的 Restful 风格的 api，但并不是只有查询的 api，读写的 api 都有，还有一些集群状态和工具类型的 api 也可以使用。可以直接在命令行中对 api 发起请求，或者通过 Kibana 发起请求。</p><p>es 的 api 支持结构化检索、全文检索，以及将两者结合在一起的复杂查询。结构化检索可以类比成 MySQL 中的 sql 语句的查询，全文检索则是会检索所有和查询字符串相匹配的文档，并按照文档和检索内容的相关性进行排序返回。</p><p>除了这些，es 还支持短语搜索，比如英文里面的 <code>from..to..</code> 这种短语的搜索，还支持模糊查询、前缀查询。</p><p>对于查询的操作，es 提供了一套完整的 JSON 格式的 DSL 进行查询，甚至还可以直接通过 sql 进行查询。</p><h2 id="扩展性、伸缩性"><a href="#扩展性、伸缩性" class="headerlink" title="扩展性、伸缩性"></a>扩展性、伸缩性</h2><p>es 天生支持分布式存储数据，可以根据需要进行扩展，当往集群中增加 node 时，es 会自动迁移数据到新的节点，让新的节点也分担集群的压力，并且这个过程，不需要重启应用。</p><p>es 中的索引，是一个多对个逻辑分片组成。文档分布在索引的分片中，而分片有分布在不同的节点上，这不仅降低了硬件损坏带来的影响，而且还能通过往集群中增加新的节点来扩大集群的查询容量。当集群增加或减少节点时，es 都会自动的迁移索引的分片，以平衡集群的负载情况。</p><p>es 中的分片，有主分片和副本分片两种。索引中的每个分档都属于某一个主分片，而每个主分片可以有多个副本分片，副本分片一般都和主分片在不同的节点上，这样能进一步防止硬件故障对集群造成影响，并且还能提升集群的查询性能。</p><p>es 中每个索引的主分片数，是在索引创建时就已经确定且再也不能更改的，而副本分片的数量则是随时更改的，并且不会中断读写。</p><h3 id="索引的大小、性能"><a href="#索引的大小、性能" class="headerlink" title="索引的大小、性能"></a>索引的大小、性能</h3><p>分片数量和分片大小，和索引的性能息息相关。分片数量越多，维护这些分片的消耗就越大，而单个分片越大，当 es 集群节点变更需要迁移分片时，所耗费的时间就越多。</p><p>查询大量的小分片，每个分片上的查询速度是比较快的，但分片越多，消耗的资源就越多，因为查询的次数变多了，所以有时候查询少量的大分片可能会更快，所以这个并没有固定是分片越多越好还是越少越好，需要按实际情况进行评估。</p><p>不过官方的建议有 2 个点：</p><ol><li>分片的平均大小建议在几个 G 到几十个 G 之间，对于一些时间序列的数据，通常在 20 到 40 GB。</li><li>要避免大分片，每个节点上的分片数量和堆内存成正比，通常每 GB 的分片数量不超过 20 个。</li></ol><blockquote><p>虽然是建议，但是通常还是应该比建议的标准还要严格些，不要非得节点上挤满了 20 个分片才进行集群扩容。</p></blockquote><h3 id="跨集群复制"><a href="#跨集群复制" class="headerlink" title="跨集群复制"></a>跨集群复制</h3><p>为了保证集群的节点自检有良好稳定的连接，通常会将集群的节点部署在同一个机房。但是，如果集群故障，那么相关的业务将会不可用，所以 es 提供了 CCR（Cross-cluster Replication，跨集群复制）。</p><p>CCR 能够自动同步主机群的索引数据到热备集群，如果主机群故障，热备的集群可以立马接管线上业务。</p><p>主集群可以进行读写操作，而备集群只能进行读操作。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://medium.com/swlh/bkd-trees-used-in-elasticsearch-40e8afd2a1a4">BKD trees, used in Elasticsearch</a></li><li><a href="https://www.programmersought.com/article/92224903019/">K-D tree, K-D-B tree, B-K-D tree</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Stream RocketMQ入门</title>
      <link href="posts/5382e3ced375.html"/>
      <url>posts/5382e3ced375.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h1><p>Spring Cloud Stream 提出 publish/subscribe、consumer-group、partition 等概念，内部还有 binder、binding 两个核心概念。</p><h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>用于集成消息中间件，创建各种消息总线对应的 Binding。换句话讲，各个消息总线都有自己的 Binder。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Binder</span>&lt;T, </span><br><span class="line">C <span class="keyword">extends</span> <span class="title class_">ConsumerProperties</span>, <span class="comment">// 消费者配置 </span></span><br><span class="line">P <span class="keyword">extends</span> <span class="title class_">ProducerProperties</span>&gt; &#123; <span class="comment">// 生产者配置</span></span><br><span class="line">  <span class="comment">// 创建消费者 binding</span></span><br><span class="line">Binding&lt;T&gt; <span class="title function_">bindConsumer</span><span class="params">(String name, String group, T inboundBindTarget,</span></span><br><span class="line"><span class="params">                          C consumerProperties)</span>;</span><br><span class="line"><span class="comment">// 创建生产者 binding</span></span><br><span class="line">Binding&lt;T&gt; <span class="title function_">bindProducer</span><span class="params">(String name, T outboundBindTarget, P producerProperties)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h2><p>Binding 包括 input binding 和 output binding。</p><p>Binding 是用于隔离业务代码和具体的消息中间的时间的一层抽象。</p><p><img src="http://image.hanelalo.cn/image/202305281650482.png" alt="binding"></p><h1 id="Spring-Cloud-Stream-RocketMQ"><a href="#Spring-Cloud-Stream-RocketMQ" class="headerlink" title="Spring Cloud Stream RocketMQ"></a>Spring Cloud Stream RocketMQ</h1><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>Spring Cloud Stream 本身有一些配置，同时还允许各个消息中间件的 binder、binding 增加自定义扩展配置。</p><p>现在看看一个简单的生产者配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18800</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rocket-producer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo-output:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">TEST-TOPIC-01</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span></span><br><span class="line">      <span class="attr">rocketmq:</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">name-server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">demo-output:</span></span><br><span class="line">            <span class="attr">producer:</span></span><br><span class="line">              <span class="attr">group:</span> <span class="string">test-group</span></span><br><span class="line">              <span class="attr">sync:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li><p>demo-output 是消息通道的名称，destination 则是 topic 的名称。</p></li><li><p><code>spring.cloud.stream.rocketmq</code> 系列的配置，则是 rocketmq 的自定义配置。</p><ul><li><code>spring.cloud.stream.rocketmq.binder.name-server</code> 配置的是 rocketmq name server 的地址。<code>spring.cloud.stream.rocketmq.bindings.demo-output.producer</code> 则是使用 demo-input 这个通道的生产者的专属配置，<code>group</code> 配置项是生产者组配置，<code>sync</code> 配置则是决定发送同步或是异步消息。</li></ul></li></ul><p>然后再看看代码中要如何发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderEventPublisher</span> &#123;</span><br><span class="line"></span><br><span class="line">    String CHANNEL=<span class="string">&quot;demo-output&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Output(CHANNEL)</span></span><br><span class="line">    MessageChannel <span class="title function_">demoOuput</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是使用 <code>@Output</code> 注解使用 demo-output 这个通道，返回的是一个 MessageChannel，后面就可以通过 MessageChannel 来发送消息。需要注意的是，<code>@Output</code> 注解的 value 填写的是在配置文件中声明的通道名称，而不是最终的 topic 的名称。</p><p>然后，还需要将这个接口注册成 Spring Bean，直接使用 <code>@EnableBinding</code> 注解即可，会自动为 OrderEventPublisher 接口创建代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableBinding(OrderEventPublisher.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RocketMqProducerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RocketMqProducerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，已经具备了发送消息的能力，再看看要如何使用 MessageChannel 发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;order&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderEventPublisher orderEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;finish&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">OrderEvent</span> <span class="variable">event</span> <span class="operator">=</span> OrderEvent.builder()</span><br><span class="line">                .orderId(UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">                .quantity(<span class="number">100L</span>)</span><br><span class="line">                .totalAmount(<span class="number">10000L</span>)</span><br><span class="line">                .type(<span class="string">&quot;realtime&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        MessageBuilder&lt;OrderEvent&gt; builder = MessageBuilder.withPayload(event);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">send</span> <span class="operator">=</span> orderEventPublisher.demoOuput().send(builder.build());</span><br><span class="line">        log.info(<span class="string">&quot;发送结果：&#123;&#125;&quot;</span>, send);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个 Http 接口，调用逻辑就是发送一个 OrderEvent，当构建好 OrderEvent，只需要通过 MessageBuilder 构建一个 Message，然后就能通过 MessageChannel 的 send() 方法进行发送。</p><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>消费者配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">$&#123;random.int(10000,19999)&#125;</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rocket-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo-input:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">TEST-TOPIC-01</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">CONSUMER-GROUP-02</span></span><br><span class="line">      <span class="attr">rocketmq:</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">name-server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">demo-input:</span></span><br><span class="line">            <span class="attr">consumer:</span></span><br><span class="line">              <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">              <span class="attr">broadcasting:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>为了方便模拟多个消费者的集群消费，这里将 <code>server.port</code> 设置成随机的端口。</li><li><code>spring.cloud.stream.bindings</code> 是 Spring Cloud Stream 的配置。<ul><li>demo-input 是定义的通道名称。</li><li>destination 是 topic 名称。</li><li>group 是消费者组的名称。</li></ul></li><li><code>spring.cloud.stream.rockqtmq</code> 是 rocketmq 的自定义配置。<ul><li><code>binder.name-server</code> 指定 rocketmq name server 的地址。</li><li><code>bindings.demo-input.consumer</code> 指定 demo-input 这个消息通道的消费者配置。 <ul><li>enable 表示是否开启消费。</li><li>broadcasting 表示是否广播消费。</li></ul></li></ul></li></ul><blockquote><p>集群消费：一条消息，在一个消费者组中，只能有一个消费者实例进行消费。</p><p>广播消费：一条消息，在一个消费者组中，所有的消费者实例都会消费。</p></blockquote><p>和生产者类似，消费者也需要定义一个接口来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderEventSink</span> &#123;</span><br><span class="line"></span><br><span class="line">    String CHANNEL=<span class="string">&quot;demo-input&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Input(CHANNEL)</span></span><br><span class="line">    SubscribableChannel <span class="title function_">demoInput</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，<code>@Input</code> 注解的 value 也要和配置文件中定义的通道名称一致，而不是和 topic 名称一致。</p><p>然后，还需要增加一个消费的监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEventConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(OrderEventSink.CHANNEL)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(<span class="meta">@Payload</span> OrderEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到消息&#123;&#125;&quot;</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听器通过 <code>@StreamListener</code> 定义，value 填写要监听的消息通道的名称即可，方法参数使用 <code>@Payload</code> 注解表示直接取消息体。</p><p>onMessage() 方法就是消费的逻辑了，如果消费有问题，抛出了异常，则消费失败，在集群消费的模式下，RoacketMQ 会进行重试。</p><p>最后，OrderEventSink 接口也需要通过 <code>@EnableBinding</code> 注解创建代理 bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableBinding(OrderEventSink.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RocketMqConsumerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RocketMqConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在将生产者、消费者都启动起来，访问消费者的 <code>/order/finish</code> 接口，消费者端将收到消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023-05-28 17:38:25.841  INFO 14881 --- [UMER-GROUP-02_1] c.h.rocket.consumer.OrderEventConsumer   : 接收到消息OrderEvent(orderId=af1d50f08d5c46f58cd528baf7959dbb, totalAmount=10000, quantity=100, type=realtime)</span><br></pre></td></tr></table></figure><p>到这里已经知道比较常规的使用。</p><h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><p>RocketMQ 支持了 18 个延迟级别，发送延时消息时，并不能自定义延迟的时间，只能指定延迟的级别，每个延迟级别有固定的延时时长。</p><p>延时消息主要是生产方发送时，指定延迟级别，RocketMQ 负责当延迟时间到达时再开放给消费者消费，换句话说，收到的是延时消息还是普通的消息，消费者是无感知的。</p><p>通过 Spring Cloud Stream RocketMQ 发送延迟消息时，因为 Spring Cloud Stream 的 API 是没有直接支持延迟消息的，所以在集成时，Spring Cloud Stream RocketMQ 选则通过 message 的 header 来指定延迟级别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;finish/delay&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finishDelay</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">OrderEvent</span> <span class="variable">event</span> <span class="operator">=</span> OrderEvent.builder()</span><br><span class="line">            .orderId(UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">            .quantity(<span class="number">100L</span>)</span><br><span class="line">            .totalAmount(<span class="number">10000L</span>)</span><br><span class="line">            .type(<span class="string">&quot;delay&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    MessageBuilder&lt;OrderEvent&gt; builder = MessageBuilder.withPayload(event);</span><br><span class="line">    builder.setHeader(MessageConst.PROPERTY_DELAY_TIME_LEVEL, <span class="number">3</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">send</span> <span class="operator">=</span> orderEventPublisher.demoOuput().send(builder.build());</span><br><span class="line">    log.info(<span class="string">&quot;发送结果：&#123;&#125;&quot;</span>, send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是通过 <code>MessageConst.PROPERTY_DELAY_TIME_LEVEL</code> 消息头指定延迟级别，延迟级别 3 对应的延时时长是 10 秒。</p><p>不同级别对应的延迟级别：</p><table><thead><tr><th>延迟级别</th><th>延时时长</th><th>延迟级别</th><th>延时时长</th><th>延迟级别</th><th>延时时长</th></tr></thead><tbody><tr><td>1</td><td>1s</td><td>7</td><td>3m</td><td>13</td><td>9m</td></tr><tr><td>2</td><td>5s</td><td>8</td><td>4m</td><td>14</td><td>10m</td></tr><tr><td>3</td><td>10s</td><td>9</td><td>5m</td><td>15</td><td>20m</td></tr><tr><td>4</td><td>30s</td><td>10</td><td>6m</td><td>16</td><td>30m</td></tr><tr><td>5</td><td>1m</td><td>11</td><td>7m</td><td>17</td><td>1h</td></tr><tr><td>6</td><td>2m</td><td>12</td><td>8m</td><td>18</td><td>2h</td></tr></tbody></table><h2 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h2><p>在开始讲消息重试之前，再回顾一下两种消费模式：</p><ul><li>集群消费：同一条消息，一个消费者组中只能有一个消费者实例进行消费。</li><li>广播消费：同一条消息，一个消费者组中所有消费者实例都会进行消费。</li></ul><p>因为这两种消费模式的机制不同，所以消费重试的机制，也只会在集群消费的模式下才会有。</p><p>消息重试，是通过延时消息实现，首次重试的延迟级别是 3，也就是 10 秒，要是再失败，就按延迟级别 4 进行重试，如果延迟级别 18 之后依然没能消费成功，就进入死信队列。</p><p>消费重试，则是在消费者端进行配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">$&#123;random.int(10000,19999)&#125;</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rocket-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo-input:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">TEST-TOPIC-01</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">CONSUMER-GROUP-02</span></span><br><span class="line">          <span class="attr">consumer:</span></span><br><span class="line">            <span class="attr">max-attempts:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">rocketmq:</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">name-server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">demo-input:</span></span><br><span class="line">            <span class="attr">consumer:</span></span><br><span class="line">              <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">              <span class="attr">broadcasting:</span> <span class="literal">false</span></span><br><span class="line">              <span class="attr">push:</span></span><br><span class="line">              <span class="attr">delay-level-when-next-consume:</span> <span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>增加了一个 consumer.max-attemps 配置，设置成 1，这是 Spring Cloud Stream 基于 Spring Retry 实现的本地重试，这里设置成  1。</li><li>在 RocketMQ 自定义配置中增加了 <code>delay-level-when-next-consume</code> 配置，这是 RocketMQ 提供的服务端发起的重试机制。如果是 -1，则失败后不重试，直接进入死信队列；如果是 0，则是由 broker 控制重试，即前面提到的从延时级别 3 开始重试；如果大于 0，则是由客户端自行控制重试。</li></ul><p>对于消费异常，Spring Cloud Stream 又提供了针对消费者组的异常处理，以及全局的消费异常处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServiceActivator(inputChannel = &quot;TEST-TOPIC-01.CONSUMER-GROUP-02.errors&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleError</span><span class="params">(ErrorMessage errorMessage)</span> &#123;</span><br><span class="line">    log.error(<span class="string">&quot;[handleError][payload：&#123;&#125;]&quot;</span>, ExceptionUtils.getRootCauseMessage(errorMessage.getPayload()));</span><br><span class="line">    log.error(<span class="string">&quot;[handleError][originalMessage：&#123;&#125;]&quot;</span>, errorMessage.getOriginalMessage());</span><br><span class="line">    log.error(<span class="string">&quot;[handleError][headers：&#123;&#125;]&quot;</span>, errorMessage.getHeaders());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@StreamListener(IntegrationContextUtils.ERROR_CHANNEL_BEAN_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">globalErrorHandler</span><span class="params">(ErrorMessage errorMessage)</span>&#123;</span><br><span class="line">    log.error(<span class="string">&quot;[globalHandleError][payload：&#123;&#125;]&quot;</span>, ExceptionUtils.getRootCauseMessage(errorMessage.getPayload()));</span><br><span class="line">    log.error(<span class="string">&quot;[globalHandleError][originalMessage：&#123;&#125;]&quot;</span>, errorMessage.getOriginalMessage());</span><br><span class="line">    log.error(<span class="string">&quot;[globalHandleError][headers：&#123;&#125;]&quot;</span>, errorMessage.getHeaders());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>@ServiceActivator</code> 用于接收指定消费者组的消费异常。</p><p><code>@StreamListener(IntegrationContextUtils.ERROR_CHANNEL_BEAN_NAME)</code> 用于监听全局的异常，这其实和普通的消费一样，只不过全局错误有一个专属的通道而已。</p><h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>顺序消息，RocketMQ 支持分区顺序消息、全局顺序消息两种。</p><p>分区顺序消息，对于指定的 topic 中的消息，通过 sharding key 进行分区，同一个分区内按严格 FIFO 的进行发布、消费。sharding key 是区别于普通消息 key 的字段。RocketMQ 通过将同一个 sharding 分区的消息发送的同一个队列来实现分区顺序消息。</p><p>全局顺序消息，指的是 topic 级别有序，topic 内的所有消息严格遵循 FIFO 的顺序进行发布、消费，这种保证了严格顺序的机制，就需要付出性能的代价，所以也只适用于性能要求不高，但是要求严格 FIFO 的场景。RocketMQ 是在分区顺序消息的基础上进行实现全局顺序消息，可以理解为全局顺序消息其实是通过只有一个消息分区的 topic 实现的，本质上还是分区顺序消息，只不过因为只有 1 个分区，就变成了全局顺序消息。</p><p>要是实现分区顺序消息很简单，只需要生产者将同一类消息发到同一个队列即可。通过增加一个 <code>spring.cloud.stream.bindings.&lt;name&gt;.producer.partition-key-expression</code> 配置来保证同一类消息发送到同一队列。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rocket-producer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo-output:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">TEST-TOPIC-01</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span></span><br><span class="line">          <span class="attr">producer:</span></span><br><span class="line">            <span class="attr">partition-key-expression:</span> <span class="string">headers[&#x27;partition&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>headers[partition]</code> 意思是取消息头中的 <code>partition</code> 字段作为分片的 sharding key。</p><p>如果要使用消息体中的某个字段作为 sharding key，也可以通过 <code>payload[&#39;id&#39;]</code> 的方式来指定，这里是指定 payload 中的 id 字段作为 sharding key。</p><p>需要注意的是，虽然在实现顺序消息时，生产方将同一种消息放到了同一个分区里面，但如果消费方是多个线程消费，那么就存在消费顺序被打乱的风险。</p><p>因此，一方面，对于广播消费这种模式，其实是天生就不支持顺序消息的，另一方面，如果消费方本身就是异步的消费，就算消息按顺序到达消费方，其实依然还是有乱序的风险。</p><p>所以在消费者的配置上，通过  <code>spring.cloud.stream.rocketmq.bindings.&lt;name&gt;.consumer.push.orderly</code> 控制是否顺序消费，默认是 false，表示并发多线程消费，设置为 true 就是顺序消费。可以看看 <code>RocketMQInboundChannelAdapter#doInit</code> 方法。</p><blockquote><p>Spring Cloud Stream RocketMQ 默认是 Push 模式的消费者，所以配置路径里面还使用了 <code>push</code> 的字样。</p></blockquote><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>事务消息并不是 Spring Cloud Stream 原生支持的，而是 RocketMQ 自己的特殊功能。</p><blockquote><p>下面是从 <a href="https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage">RoacketMQ 官网：事务消息</a> 扒下来的图：</p><p><img src="http://image.hanelalo.cn/image/202306040904379.png" alt="事务消息"></p><ol><li><p>生产者将消息发送至Apache RocketMQ服务端。</p></li><li><p>Apache RocketMQ服务端将消息持久化成功之后，向生产者返回Ack确认消息已经发送成功，此时消息被标记为”暂不能投递”，这种状态下的消息即为半事务消息。</p></li><li><p>生产者开始执行本地事务逻辑。</p></li><li><p>生产者根据本地事务执行结果向服务端提交二次确认结果（Commit或是Rollback），服务端收到确认结果后处理逻辑如下：</p><ul><li><p>二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。</p></li><li><p>二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。</p></li></ul></li><li><p>在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。 <strong>说明</strong> 服务端回查的间隔时间和最大回查次数，请参见<a href="https://rocketmq.apache.org/zh/docs/introduction/03limits">参数限制</a>。</p></li><li><p>生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</p></li><li><p>生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。</p></li></ol></blockquote><p>从上面的事务消息的发送的步骤来看，这其实和消费者没多大关系，消费端根本感知不到这条消息是不是事务消息，主要还是在生产者进行处理。</p><p>在生产者一方，要发送事务消息，相比之前的配置文件，还需要增加两个配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18800</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rocket-producer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">demo-output:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">TEST-TOPIC-03</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span></span><br><span class="line">      <span class="attr">rocketmq:</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">name-server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">demo-output:</span></span><br><span class="line">            <span class="attr">producer:</span></span><br><span class="line">              <span class="attr">group:</span> <span class="string">test-group</span></span><br><span class="line">              <span class="attr">sync:</span> <span class="literal">true</span></span><br><span class="line">              <span class="attr">producerType:</span> <span class="string">Trans</span> <span class="comment"># 事务消息</span></span><br><span class="line">              <span class="attr">transactionListener:</span> <span class="string">orderTransactionalListener</span> <span class="comment"># 事务消息监听器</span></span><br></pre></td></tr></table></figure><ul><li><code>spring.cloud.stream.rocketmq.bindings.&lt;name&gt;.producer.producerType</code>，将生产者类型设置为事务消息，默认是 Normal，普通消息。</li><li><code>spring.cloud.stream.rocketmq.bindings.&lt;name&gt;.producer.transactionListener</code>，事务消息监听器，用于执行本地事务和事务回查。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;orderTransactionalListener&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderTransactionalListener</span> <span class="keyword">implements</span> <span class="title class_">TransactionListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;execute local transaction:&#123;&#125;&quot;</span>, JSON.toJSONString(msg));</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;消息回查:&#123;&#125;&quot;</span>, JSON.toJSONString(msg));</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里会首先调用 <code>#executeLocalTransaction</code> 方法执行本地事务，但是返回的是 UNKNOW，所以隔一段时间会调用 <code>#checkLocalTransaction</code> 方法检查本地事务执行状态。</p></blockquote><p>事务消息监听器，需要实现 RocketMQ 提供的 <code>TransactionListener</code> 接口。</p><ul><li><p><code>#executeLocalTransaction</code> 方法用于执行本地事务，返回是的 LocalTransactionState 枚举类型。</p></li><li><p><code>#checkLocalTransaction</code> 方法用于处理事务消息回查，返回的也是 LocalTransactionState 枚举类型。</p></li></ul><p>LocalTransactionState 枚举有 3 个值：</p><ul><li><em>COMMIT_MESSAGE</em>，表示本地事务已提交。</li><li><em>ROLLBACK_MESSAGE</em>，表示本地事务已回滚。</li><li><em>UNKNOW</em>，表示状态还未知。</li></ul><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage">事务消息</a></li><li><a href="https://rocketmq.apache.org/zh/docs/featureBehavior/03fifomessage">顺序消息</a></li><li><a href="https://www.alibabacloud.com/help/en/message-queue-for-apache-rocketmq/latest/ordered-messages-1-0#section-utp-a6a-u2p">Ordered Messages</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prompt Engineering</title>
      <link href="posts/ee449bbf5714.html"/>
      <url>posts/ee449bbf5714.html</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文是学习吴恩达的 Prompt Engineering 课程的总结笔记。</p><p>课程地址：<a href="https://learn.deeplearning.ai/chatgpt-prompt-eng/lesson/2/guidelines">https://learn.deeplearning.ai/chatgpt-prompt-eng/lesson/2/guidelines</a></p><p>本文提到的实例代码依赖 openai 这个 python 库，所以需要事先进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install openai</span></span><br></pre></td></tr></table></figure><p>另外，还需要设置 openai 的 API Key：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line">openai.api_key=<span class="string">&quot;sk-....&quot;</span></span><br></pre></td></tr></table></figure><p>其中的 API Key 可以点击这个链接获取自己账户的 API Key：<a href="https://platform.openai.com/account/api-keys">https://platform.openai.com/account/api-keys</a></p><p>另外，本文的代码基本都会包含对以下辅助函数的调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_completion</span>(<span class="params">prompt, model=<span class="string">&quot;gpt-3.5-turbo&quot;</span></span>): </span><br><span class="line">    messages = [&#123;<span class="string">&quot;role&quot;</span>:<span class="string">&quot;user&quot;</span>,<span class="string">&quot;content&quot;</span>:prompt&#125;]</span><br><span class="line">    response = openai.ChatCompletion.create(</span><br><span class="line">        model=model,</span><br><span class="line">        messages=messages,</span><br><span class="line">        temperature=<span class="number">0</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> response.choices[<span class="number">0</span>].message[<span class="string">&quot;content&quot;</span>]</span><br></pre></td></tr></table></figure><p>prompt 就是输入的文本了，model 是使用的模型，这里硬编码成了 gpt-3.5-turbo。</p><p>更多的 api 使用规范参考：<a href="https://platform.openai.com/docs/api-reference">https://platform.openai.com/docs/api-reference</a></p><h1 id="Temperature-参数"><a href="#Temperature-参数" class="headerlink" title="Temperature 参数"></a>Temperature 参数</h1><p>temperature 参数的取值是 0~2，这个值越高，输出越随机，值越低，输出越稳定。</p><p>同样的 prompt，当 temperature 为 0 时，每次输出的内容基本能够保持一致，但是如果 temperature 是 0.8，或者其他数值时，每次输出的结果可能会不一样。</p><p>所以，如果构建的系统需要保持输出的稳定性，temperature 参数的值建议设置成 0，而如果想让应用更具有创造性，则可以适当调高该参数的值。</p><h1 id="使用准则"><a href="#使用准则" class="headerlink" title="使用准则"></a>使用准则</h1><ul><li>编写清晰而具体的指令。</li><li>给予模型思考的时间。</li></ul><h2 id="编写清晰而具体的指令"><a href="#编写清晰而具体的指令" class="headerlink" title="编写清晰而具体的指令"></a>编写清晰而具体的指令</h2><p>需要注意的是，不要把短的提示词和清晰、具体的提示词混淆，很多时候，更长的提示词能更清晰的描述问题的上下文，让模型能更准确的输出。</p><p>要编写一个清晰、准确的提示词，可以使用以下 4 种策略。</p><h3 id="使用分隔符"><a href="#使用分隔符" class="headerlink" title="使用分隔符"></a>使用分隔符</h3><p>使用分隔符，可以明确指出输入的不同部分。</p><p>比如使用 <code>&quot;&quot;&quot;</code>、`````、<code>&lt;&gt;</code> 、<code>---</code>等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">You should express what you want a model to do by \ </span></span><br><span class="line"><span class="string">providing instructions that are as clear and \ </span></span><br><span class="line"><span class="string">specific as you can possibly make them. \ </span></span><br><span class="line"><span class="string">This will guide the model towards the desired output, \ </span></span><br><span class="line"><span class="string">and reduce the chances of receiving irrelevant \ </span></span><br><span class="line"><span class="string">or incorrect responses. Don&#x27;t confuse writing a \ </span></span><br><span class="line"><span class="string">clear prompt with writing a short prompt. \ </span></span><br><span class="line"><span class="string">In many cases, longer prompts provide more clarity \ </span></span><br><span class="line"><span class="string">and context for the model, which can lead to \ </span></span><br><span class="line"><span class="string">more detailed and relevant outputs.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Summarize the text delimited by triple backticks \ </span></span><br><span class="line"><span class="string">into a single sentence.</span></span><br><span class="line"><span class="string">```<span class="subst">&#123;text&#125;</span>```</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">response = get_completion(prompt)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><p>上面的例子中的 prompt 是让 gpt 模型将 <code>中的文本总结成 1 句话，这里使用 </code>作为分隔符，有效的限定了文本的不同部分之间的边界。</p><p>这样做的好处是，可以有效地防止 prompt 注入。举个例子，如果这里没有指定某种符号作为分隔符，那么如果用户输入的 text 的内容是让 gpt 忽略前面的 prompt 内容并写一首关于熊猫的诗，那么整个应用将不会按照预想的逻辑运行。</p><p>总之，使用分隔符的好处是：</p><ol><li>使 prompt 更加清晰，gpt 能更清晰识别 prompt 文本中的不同部分。</li><li>防止 prompt 注入。</li></ol><h3 id="要求模型进行结构化的输出"><a href="#要求模型进行结构化的输出" class="headerlink" title="要求模型进行结构化的输出"></a>要求模型进行结构化的输出</h3><p>可以要求  gpt 输出一个 json、xml，甚至 html。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Generate  a list of three made-up book title along \</span></span><br><span class="line"><span class="string">with their authors and genres.</span></span><br><span class="line"><span class="string">Provide them in JSON format with the follow key:</span></span><br><span class="line"><span class="string">book_id,title,author,genre.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">response = get_completion(prompt)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;book1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The Lost City of Zorath&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Aria Blackwood&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;genre&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Fantasy&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;book2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The Last Survivors&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Ethan Stone&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;genre&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Science Fiction&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;book3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The Secret Life of Mrs. Jenkins&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Lila Rosewood&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;genre&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Mystery&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="要求模型检查条件是否得到满足"><a href="#要求模型检查条件是否得到满足" class="headerlink" title="要求模型检查条件是否得到满足"></a>要求模型检查条件是否得到满足</h3><p>可以要求模型做一些前置的检查，如果不满足这些检查条件时，则提示并终止任务。</p><p>比如，现在给 gpt 一段文本，要求它对文本进行总结，需要总结 step by step 的结构进行输出，如果提供的文本不满足这种结构，就提示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">text_1 = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Making a cup of tea is easy! First, you need to get some \ </span></span><br><span class="line"><span class="string">water boiling. While that&#x27;s happening, \ </span></span><br><span class="line"><span class="string">grab a cup and put a tea bag in it. Once the water is \ </span></span><br><span class="line"><span class="string">hot enough, just pour it over the tea bag. \ </span></span><br><span class="line"><span class="string">Let it sit for a bit so the tea can steep. After a \ </span></span><br><span class="line"><span class="string">few minutes, take out the tea bag. If you \ </span></span><br><span class="line"><span class="string">like, you can add some sugar or milk to taste. \ </span></span><br><span class="line"><span class="string">And that&#x27;s it! You&#x27;ve got yourself a delicious \ </span></span><br><span class="line"><span class="string">cup of tea to enjoy.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">You will be provided with text delimited by triple quotes. </span></span><br><span class="line"><span class="string">If it contains a sequence of instructions, \ </span></span><br><span class="line"><span class="string">re-write those instructions in the following format:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Step 1 - ...</span></span><br><span class="line"><span class="string">Step 2 - …</span></span><br><span class="line"><span class="string">…</span></span><br><span class="line"><span class="string">Step N - …</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If the text does not contain a sequence of instructions, \ </span></span><br><span class="line"><span class="string">then simply write \&quot;No steps provided.\&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">\&quot;\&quot;\&quot;<span class="subst">&#123;text_1&#125;</span>\&quot;\&quot;\&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">response = get_completion(prompt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Completion for Text 1:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><p>这里要求对三引号中的文本进行总结，并按照 Step 1 ~ Step N 进行输出，如果 text 的内容不存在这样的结构，就仅仅只是输出<code>No Stpes provided</code>。</p><p>Output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Completion for Text 1:</span><br><span class="line">Step 1 - Get some water boiling.</span><br><span class="line">Step 2 - Grab a cup and put a tea bag in it.</span><br><span class="line">Step 3 - Once the water is hot enough, pour it over the tea bag.</span><br><span class="line">Step 4 - Let it sit for a bit so the tea can steep.</span><br><span class="line">Step 5 - After a few minutes, take out the tea bag.</span><br><span class="line">Step 6 - Add some sugar or milk to taste.</span><br><span class="line">Step 7 - Enjoy your delicious cup of tea!</span><br></pre></td></tr></table></figure><p>当 text 的内容不存在这种结构时，比如 text 仅仅只有 Hello 时：</p><p>Output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Completion for Text 1:</span><br><span class="line">No steps provided.</span><br></pre></td></tr></table></figure><h3 id="向模型提供一些提示样本"><a href="#向模型提供一些提示样本" class="headerlink" title="向模型提供一些提示样本"></a>向模型提供一些提示样本</h3><p>给予模型一些成功的完整样本，并让执行任务。</p><p>比如，要求模型以一致的对话风格完善文本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Your task is to answer in a consistent style.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;child&gt;: Teach me about patience.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;grandparent&gt;: The river that carves the deepest \ </span></span><br><span class="line"><span class="string">valley flows from a modest spring; the \ </span></span><br><span class="line"><span class="string">grandest symphony originates from a single note; \ </span></span><br><span class="line"><span class="string">the most intricate tapestry begins with a solitary thread.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;child&gt;: Teach me about resilience.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">response = get_completion(prompt)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;grandparent&gt;: Resilience is like a tree that bends with the wind but never breaks. It is the ability to bounce back from adversity and keep moving forward, even when things get tough. Just like a tree that grows stronger with each storm it weathers, resilience is a quality that can be developed and strengthened over time.</span><br></pre></td></tr></table></figure><p>这是一个小孩在跟祖父母对话的场景，小孩说“教我什么是忍耐”时，祖父母的回答使用了比喻的方式来进行阐述。</p><p>那么当孩子说“什么是适应力”时，gpt 的回答也使用了比喻来进行阐述。</p><h2 id="给予模型思考的时间"><a href="#给予模型思考的时间" class="headerlink" title="给予模型思考的时间"></a>给予模型思考的时间</h2><p>当模型短时间内得不到答案时，应该重新设计 prompt，让模型在得出答案前有一系列推理，最终得到答案。</p><p>另外，给模型一个复杂任务时，如果模型无法短时间内完成，或者无法用少量的词完成时，往往会<strong>编造</strong>出一些错误的答案。</p><p>所以，在这个准则上，也提供了以下几个准则。</p><h3 id="指定完成一项任务所需要的步骤"><a href="#指定完成一项任务所需要的步骤" class="headerlink" title="指定完成一项任务所需要的步骤"></a>指定完成一项任务所需要的步骤</h3><p>比如下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">In a charming village, siblings Jack and Jill set out on \ </span></span><br><span class="line"><span class="string">a quest to fetch water from a hilltop \ </span></span><br><span class="line"><span class="string">well. As they climbed, singing joyfully, misfortune \ </span></span><br><span class="line"><span class="string">struck—Jack tripped on a stone and tumbled \ </span></span><br><span class="line"><span class="string">down the hill, with Jill following suit. \ </span></span><br><span class="line"><span class="string">Though slightly battered, the pair returned home to \ </span></span><br><span class="line"><span class="string">comforting embraces. Despite the mishap, \ </span></span><br><span class="line"><span class="string">their adventurous spirits remained undimmed, and they \ </span></span><br><span class="line"><span class="string">continued exploring with delight.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># example 1</span></span><br><span class="line">prompt_1 = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Perform the following actions: </span></span><br><span class="line"><span class="string">1 - Summarize the following text delimited by triple \</span></span><br><span class="line"><span class="string">backticks with 1 sentence.</span></span><br><span class="line"><span class="string">2 - Translate the summary into French.</span></span><br><span class="line"><span class="string">3 - List each name in the French summary.</span></span><br><span class="line"><span class="string">4 - Output a json object that contains the following \</span></span><br><span class="line"><span class="string">keys: french_summary, num_names.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Separate your answers with line breaks.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Text:</span></span><br><span class="line"><span class="string">```<span class="subst">&#123;text&#125;</span>```</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">response = get_completion(prompt_1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Completion for prompt 1:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><p>这个 prompt 让模型做了四件事并用换行符分隔：将`````中的内容总结成为一句话，将总结的内容翻译成法语，列出法语版的摘要总结中出现了每个名字，输出一个包含 french_summary、num_names 两个 key 的 json 文本。</p><p>Output:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Completion <span class="keyword">for</span> prompt <span class="number">1</span>:</span><br><span class="line">Two siblings, Jack <span class="keyword">and</span> Jill, go on a quest to fetch water <span class="keyword">from</span> a hilltop well, but misfortune strikes <span class="keyword">as</span> they both fall down the hill, yet they <span class="keyword">return</span> home slightly battered but <span class="keyword">with</span> their adventurous spirits undimmed.</span><br><span class="line"></span><br><span class="line">Deux frères et sœurs, Jack et Jill, partent en quête d<span class="string">&#x27;eau d&#x27;</span>un puits au sommet d<span class="string">&#x27;une colline, mais ils tombent tous les deux et retournent chez eux légèrement meurtris mais avec leur esprit d&#x27;</span>aventure intact. </span><br><span class="line">Noms: Jack, Jill.</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;french_summary&quot;</span>: <span class="string">&quot;Deux frères et sœurs, Jack et Jill, partent en quête d&#x27;eau d&#x27;un puits au sommet d&#x27;une colline, mais ils tombent tous les deux et retournent chez eux légèrement meurtris mais avec leur esprit d&#x27;aventure intact.&quot;</span>,</span><br><span class="line"><span class="string">&quot;num_names&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更进一步，对于输出的格式，还可以通过 prompt 进一步定制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">prompt_2 = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Your task is to perform the following actions: </span></span><br><span class="line"><span class="string">1 - Summarize the following text delimited by </span></span><br><span class="line"><span class="string">  &lt;&gt; with 1 sentence.</span></span><br><span class="line"><span class="string">2 - Translate the summary into French.</span></span><br><span class="line"><span class="string">3 - List each name in the French summary.</span></span><br><span class="line"><span class="string">4 - Output a json object that contains the </span></span><br><span class="line"><span class="string">  following keys: french_summary, num_names.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Use the following format:</span></span><br><span class="line"><span class="string">Text: &lt;text to summarize&gt;</span></span><br><span class="line"><span class="string">Summary: &lt;summary&gt;</span></span><br><span class="line"><span class="string">Translation: &lt;summary translation&gt;</span></span><br><span class="line"><span class="string">Names: &lt;list of names in Italian summary&gt;</span></span><br><span class="line"><span class="string">Output JSON: &lt;json with summary and num_names&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Text: &lt;<span class="subst">&#123;text&#125;</span>&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">response = get_completion(prompt_2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nCompletion for prompt 2:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Completion for prompt 2:</span><br><span class="line">Summary: Jack and Jill go on a quest to fetch water, but misfortune strikes and they tumble down the hill, returning home slightly battered but with their adventurous spirits undimmed. </span><br><span class="line">Translation: Jack et Jill partent en quête d&#x27;eau, mais la malchance frappe et ils dégringolent la colline, rentrant chez eux légèrement meurtris mais avec leurs esprits aventureux intacts.</span><br><span class="line">Names: Jack, Jill</span><br><span class="line">Output JSON: &#123;&quot;french_summary&quot;: &quot;Jack et Jill partent en quête d&#x27;eau, mais la malchance frappe et ils dégringolent la colline, rentrant chez eux légèrement meurtris mais avec leurs esprits aventureux intacts.&quot;, &quot;num_names&quot;: 2&#125;</span><br></pre></td></tr></table></figure><p>会发现 prompt 中使用<code>&lt;&gt;</code>这个符号的地方其实不止一个，但依然不影响模型的运行，并给出了指定格式的输出内容。</p><blockquote><p>从通常的编程语言的角度来看，这其实很神奇，虽然我们的提示词中有说总结 &lt;&gt; 中的内容，但整个提示词中不止一个地方有 &lt;&gt;，模型竟然自动识别到了要总结的文本是 Text 后面的内容。</p><p>这或许就是 ai 的魅力所在。</p></blockquote><h3 id="在得到答案前，先自定寻找解决方案"><a href="#在得到答案前，先自定寻找解决方案" class="headerlink" title="在得到答案前，先自定寻找解决方案"></a>在得到答案前，先自定寻找解决方案</h3><p>下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Determine if the student&#x27;s solution is correct or not.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Question:</span></span><br><span class="line"><span class="string">I&#x27;m building a solar power installation and I need \</span></span><br><span class="line"><span class="string"> help working out the financials. </span></span><br><span class="line"><span class="string">- Land costs $100 / square foot</span></span><br><span class="line"><span class="string">- I can buy solar panels for $250 / square foot</span></span><br><span class="line"><span class="string">- I negotiated a contract for maintenance that will cost \ </span></span><br><span class="line"><span class="string">me a flat $100k per year, and an additional $10 / square \</span></span><br><span class="line"><span class="string">foot</span></span><br><span class="line"><span class="string">What is the total cost for the first year of operations </span></span><br><span class="line"><span class="string">as a function of the number of square feet.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Student&#x27;s Solution:</span></span><br><span class="line"><span class="string">Let x be the size of the installation in square feet.</span></span><br><span class="line"><span class="string">Costs:</span></span><br><span class="line"><span class="string">1. Land cost: 100x</span></span><br><span class="line"><span class="string">2. Solar panel cost: 250x</span></span><br><span class="line"><span class="string">3. Maintenance cost: 100,000 + 100x</span></span><br><span class="line"><span class="string">Total cost: 100x + 250x + 100,000 + 100x = 450x + 100,000</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">response = get_completion(prompt)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The student&#x27;s solution is correct.</span><br></pre></td></tr></table></figure><p>这个 Prompt 是要模型判定学生的解题是否正确。</p><p>问题是：每平方土地成本 100 美元，每平方太阳能电池板 250 美元，签订了每年固定 100000 美元的维护合同，每平方还有额外的 10 美元成本，那么第一年运营的总成本是多少？</p><p>学生解题：假设有 x 平方，那么总成本为 100x + 250x + 100000 + 100x = 450x + 100000。</p><p>模型判定结果：学生是对的。</p><p>但实际上，是错误的，在这种情况下，我们可以试着让模型自己先解题，然后再和学生的解决方案对比，让判定结果更加准确。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Your task is to determine if the student&#x27;s solution \</span></span><br><span class="line"><span class="string">is correct or not.</span></span><br><span class="line"><span class="string">To solve the problem do the following:</span></span><br><span class="line"><span class="string">- First, work out your own solution to the problem. </span></span><br><span class="line"><span class="string">- Then compare your solution to the student&#x27;s solution \ </span></span><br><span class="line"><span class="string">and evaluate if the student&#x27;s solution is correct or not. </span></span><br><span class="line"><span class="string">Don&#x27;t decide if the student&#x27;s solution is correct until </span></span><br><span class="line"><span class="string">you have done the problem yourself.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Use the following format:</span></span><br><span class="line"><span class="string">Question:</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string">question here</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string">Student&#x27;s solution:</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string">student&#x27;s solution here</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string">Actual solution:</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string">steps to work out the solution and your solution here</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string">Is the student&#x27;s solution the same as actual solution \</span></span><br><span class="line"><span class="string">just calculated:</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string">yes or no</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string">Student grade:</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string">correct or incorrect</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Question:</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string">I&#x27;m building a solar power installation and I need help \</span></span><br><span class="line"><span class="string">working out the financials. </span></span><br><span class="line"><span class="string">- Land costs $100 / square foot</span></span><br><span class="line"><span class="string">- I can buy solar panels for $250 / square foot</span></span><br><span class="line"><span class="string">- I negotiated a contract for maintenance that will cost \</span></span><br><span class="line"><span class="string">me a flat $100k per year, and an additional $10 / square \</span></span><br><span class="line"><span class="string">foot</span></span><br><span class="line"><span class="string">What is the total cost for the first year of operations \</span></span><br><span class="line"><span class="string">as a function of the number of square feet.</span></span><br><span class="line"><span class="string">``` </span></span><br><span class="line"><span class="string">Student&#x27;s solution:</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string">Let x be the size of the installation in square feet.</span></span><br><span class="line"><span class="string">Costs:</span></span><br><span class="line"><span class="string">1. Land cost: 100x</span></span><br><span class="line"><span class="string">2. Solar panel cost: 250x</span></span><br><span class="line"><span class="string">3. Maintenance cost: 100,000 + 100x</span></span><br><span class="line"><span class="string">Total cost: 100x + 250x + 100,000 + 100x = 450x + 100,000</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string">Actual solution:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">response = get_completion(prompt)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Let x be the size of the installation in square feet.</span><br><span class="line"></span><br><span class="line">Costs:</span><br><span class="line">1. Land cost: 100x</span><br><span class="line">2. Solar panel cost: 250x</span><br><span class="line">3. Maintenance cost: 100,000 + 10x</span><br><span class="line"></span><br><span class="line">Total cost: 100x + 250x + 100,000 + 10x = 360x + 100,000</span><br><span class="line"></span><br><span class="line">Is the student&#x27;s solution the same as actual solution just calculated:</span><br><span class="line">No</span><br><span class="line"></span><br><span class="line">Student grade:</span><br><span class="line">Incorrect</span><br></pre></td></tr></table></figure><p>这个新的 prompt 让模型先自己对问题进行解决，然后再和学生的解决方案对比，再判断和学生的解决方案是否一致，再判定学生的解决方案是否正确。</p><p>为了确保是模型自己解决这个问题，prompt 中还特地强调在自己完成解决方案之前不能判定学生的方案的对错：Don’t decide if the student’s solution is correct until you have done the problem yourself.</p><h1 id="模型的局限性"><a href="#模型的局限性" class="headerlink" title="模型的局限性"></a>模型的局限性</h1><p>因为模型读取了大量的数据，但是并不能完整准确地记录所有的内容，所以当它回答一些晦涩难懂的问题时，可能会产生幻觉，会编造一些看起来真实但实际上是并不真实的回答。这也是 gpt 模型目前已知的一个缺陷。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prompt=<span class="string">&quot;简单讲讲刘备和曹操结拜兄弟的故事&quot;</span></span><br><span class="line">response = get_completion(prompt)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">刘备和曹操结拜兄弟的故事源于《三国演义》。据传，刘备和曹操在东汉末年，都是出身名门的豪族，但由于时局动荡，两人都失去了家族的地位和财富。他们在一次相遇后，互相交流了彼此的遭遇和心情，深感彼此的志向和品德相投，于是决定结为兄弟。</span><br><span class="line">刘备和曹操在结拜时，按照古代的习俗，要进行三次拜礼。第一次拜礼时，刘备说：“我刘备愿与你结为兄弟，如同手足之情，共同扶持天下。”曹操回答：“我曹操也愿与你结为兄弟，如同肝胆相照，共同建功立业。”第二次拜礼时，两人交换了誓言，表示要共同努力，不离不弃。第三次拜礼时，两人用刀割破手指，混合鲜血，喝下了誓血，表示要永远保持兄弟之情。</span><br><span class="line">刘备和曹操结拜后，曹操帮助刘备重建了家族，刘备也在曹操的帮助下，成为了一名有名的将领。但是，由于两人的政治理念和野心不同，最终还是走上了对立的道路，成为了三国时期的两大敌对势力。</span><br></pre></td></tr></table></figure><p>为了减少这种幻觉，你可以在 prompt 中指定模型在引用某些资源的基础上作答，这样能更好的避免出现“幻觉”。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>如果构建的系统需要保持输出的稳定性，temperature 参数的值建议设置成 0。</li><li>对与 gpt 模型的使用，为了让它的回答更准确，指令需要清晰、具体，但并不代表指令一定非常短，同时还可以通过增加分隔符来防止 prompt 注入，通过限制输出的结构、指定条件的检查、prompt 带上提示样本等策略，亦可以提高输出的准确性。</li><li>对于比较复杂的任务，可以告诉模型，完成这个任务需要的步骤，让模型一步一步进行推进，而不是一步到位。</li><li>模型的输出，在面对晦涩难懂的任务时，会出现“幻觉”，这种情况，可以在 prompt 指定让模型在引用某些资源的基础上进行回答，可以尽量避免出现“幻觉”。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Prompt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AIGC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis源码解析：配置解析</title>
      <link href="posts/d313d441e973.html"/>
      <url>posts/d313d441e973.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了行文方便，后文 MyBatis 都使用全小写：mybatis。</p></blockquote><p>最开始学习 mybatis 时，都会先写一个 mybatis-config.xml，在里面对 mybatis 进行配置，包括导入 mapper 文件等，而 mapper 文件又是单独的一些 xxxMapper.xml 文件，这还不算完，在 Java 中使用时，还需要使用一个 SqlSessionFactoryBuilder 读取配置，得到 SqlSessionFactory，然后才能获取 Mapper 等对象进行业务上的 CRUD。</p><p>OK，其实配置解析最终就是为了得到一个 SqlSessionFactory。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure><p>配置文件的内容就不赘述，主要关注如何解析，我们直接开冲。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(inputStream, environment, properties);</span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先初始化一个 XMLConfigBuilder，它是 mybatis 提供的用来解析 xml 配置文件的解析器。</li><li>调用 <code>XMLConfigBuilder#parse()</code> 方法进行解析，得到一个 Configuration 对象，这也是本文着重讲的地方。</li><li>调用 <code>#build</code> 方法初始化了一个 <code>DefaultSqlSessionFactory</code> 对象。</li></ol><h1 id="初始化-Configuration-对象"><a href="#初始化-Configuration-对象" class="headerlink" title="初始化 Configuration 对象"></a>初始化 Configuration 对象</h1><p>Configuration 对象并不是调用  <code>XMLConfigBuilder#parse()</code> 才创建，而是在创建 XMLConfigBuilder 对象时，内部就已经创建了一个 Configuration 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">XMLConfigBuilder</span><span class="params">(XPathParser parser, String environment, Properties props)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line">  ErrorContext.instance().resource(<span class="string">&quot;SQL Mapper Configuration&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.configuration.setVariables(props);</span><br><span class="line">  <span class="built_in">this</span>.parsed = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">this</span>.environment = environment;</span><br><span class="line">  <span class="built_in">this</span>.parser = parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>new Configuration()</code> 本身也做了很多事。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Configuration</span><span class="params">()</span> &#123;</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;JDBC&quot;</span>, JdbcTransactionFactory.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;MANAGED&quot;</span>, ManagedTransactionFactory.class);</span><br><span class="line"></span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;JNDI&quot;</span>, JndiDataSourceFactory.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;POOLED&quot;</span>, PooledDataSourceFactory.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;UNPOOLED&quot;</span>, UnpooledDataSourceFactory.class);</span><br><span class="line"></span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;PERPETUAL&quot;</span>, PerpetualCache.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;FIFO&quot;</span>, FifoCache.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;LRU&quot;</span>, LruCache.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;SOFT&quot;</span>, SoftCache.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;WEAK&quot;</span>, WeakCache.class);</span><br><span class="line"></span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;DB_VENDOR&quot;</span>, VendorDatabaseIdProvider.class);</span><br><span class="line"></span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;XML&quot;</span>, XMLLanguageDriver.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;RAW&quot;</span>, RawLanguageDriver.class);</span><br><span class="line"></span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;SLF4J&quot;</span>, Slf4jImpl.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;COMMONS_LOGGING&quot;</span>, JakartaCommonsLoggingImpl.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;LOG4J&quot;</span>, Log4jImpl.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;LOG4J2&quot;</span>, Log4j2Impl.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;JDK_LOGGING&quot;</span>, Jdk14LoggingImpl.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;STDOUT_LOGGING&quot;</span>, StdOutImpl.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;NO_LOGGING&quot;</span>, NoLoggingImpl.class);</span><br><span class="line"></span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;CGLIB&quot;</span>, CglibProxyFactory.class);</span><br><span class="line">  typeAliasRegistry.registerAlias(<span class="string">&quot;JAVASSIST&quot;</span>, JavassistProxyFactory.class);</span><br><span class="line"></span><br><span class="line">  languageRegistry.setDefaultDriverClass(XMLLanguageDriver.class);</span><br><span class="line">  languageRegistry.register(RawLanguageDriver.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见这里注册了很多的类的别名，比如 <code>JDBC</code> 对应 <code>JdbcTransactionFactory</code>。</p><p>除此之外，还注册了一个默认的 DriverClass。</p><h1 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// XMLConfigBuilder</span></span><br><span class="line"><span class="keyword">public</span> Configuration <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   parsed = <span class="literal">true</span>;</span><br><span class="line">   parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">   <span class="keyword">return</span> configuration;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li>首先判断 parsed 是否为 true，如果是 true，表示已经在解析了，则直接抛出异常。</li><li>开始解析之前，将 pared 置为 true，放置重复解析。</li><li>调用 <code>#parseConfiguration(XNode)</code> 方法对 <code>&lt;configuration&gt;</code> 标签进行解析，这里可以看出是使用 xpath 的方式进行解析的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseConfiguration</span><span class="params">(XNode root)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 解析 properties 标签</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析 settings 标签</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">settings</span> <span class="operator">=</span> settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    <span class="comment">// 加载配置日志打印实现</span></span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    <span class="comment">// 加载类型别名配置</span></span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">    <span class="comment">// 加载插件配置</span></span><br><span class="line">    pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">    <span class="comment">// 加载 objectFactory 配置</span></span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">    <span class="comment">// 加载 objectWrapperFactory 配置</span></span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">    <span class="comment">// 加载 reflectorFactory 配置</span></span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">    <span class="comment">// 初始化 setting，在此之前只是得到了各项配置的值，但是并没有放到 configuration 中</span></span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    <span class="comment">// 解析 environments 标签，支持多环境配置</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析 databaseIdProvider </span></span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析 typeHandlers，类型转换处理器</span></span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">    <span class="comment">// 解析 mapper 文件</span></span><br><span class="line">    mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h2><p>ObjectFactory 是用于创建创建 sql 语句的返回值对象的，mybatis 中有默认实现 <code>DefaultObjectFactory</code>，只是使用默认的构造函数创建对象实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置 properties</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> properties configuration properties</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">    <span class="comment">// NOP</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通过默认构造函数创建一个对象实例</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">   *          the generic type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">   *          Object type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the t</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; T <span class="title function_">create</span><span class="params">(Class&lt;T&gt; type)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通过指定参数的构造函数创建一个对象实例</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">   *          the generic type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">   *          Object type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgTypes</span></span><br><span class="line"><span class="comment">   *          Constructor argument types</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgs</span></span><br><span class="line"><span class="comment">   *          Constructor argument values</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the t</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; T <span class="title function_">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断指定类型是否为 Collection 类型</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">   *          the generic type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">   *          Object type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> whether it is a collection or not</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 3.1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; <span class="type">boolean</span> <span class="title function_">isCollection</span><span class="params">(Class&lt;T&gt; type)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要自定义这段逻辑的话，就可以实现这个接口，然后使用 <code>objectFactory</code> 标签进行配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;org.apache.ibatis.submitted.global_variables_defaults.SupportClasses$CustomObjectFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;objectFactory.name:default&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectFactory</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="ObjectWrapperFactory"><a href="#ObjectWrapperFactory" class="headerlink" title="ObjectWrapperFactory"></a>ObjectWrapperFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectWrapperFactory</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断是否须要需要做wrapper封装</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasWrapperFor</span><span class="params">(Object object)</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取封装类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ObjectWrapper <span class="title function_">getWrapperFor</span><span class="params">(MetaObject metaObject, Object object)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口提供了 2 个方法：</p><ul><li><code>#hasWrapperFor(Object)</code> 方法用于判断是否需要做对象封装。</li><li><code>#getWrapperFor(MetaObject, Object)</code> 方法用于做具体的封装工作。</li></ul><p>该接口的默认实现是 <code>DefaultObjectWrapperFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultObjectWrapperFactory</span> <span class="keyword">implements</span> <span class="title class_">ObjectWrapperFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasWrapperFor</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ObjectWrapper <span class="title function_">getWrapperFor</span><span class="params">(MetaObject metaObject, Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReflectionException</span>(<span class="string">&quot;The DefaultObjectWrapperFactory should never be called to provide an ObjectWrapper.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见，在默认逻辑上，这个类是不能被调用的，换句话说，<code>ObjectWrapperFactory</code> 接口的功能在 mybatis 中是没有使用的。</p><p>MetaObject 类，从名称上就知道，是为了提供统一的元数据进行操作的工具类。</p><p>ObjectWrapper 接口则是通过 MetaObject 实现对对象的统一操作方法。</p><h2 id="settings-解析"><a href="#settings-解析" class="headerlink" title="settings 解析"></a>settings 解析</h2><p>settings 的解析，分了 2 步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseConfiguration</span><span class="params">(XNode root)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 解析 settings 标签</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">settings</span> <span class="operator">=</span> settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 初始化 setting，在此之前只是得到了各项配置的值，但是并没有放到 configuration 中</span></span><br><span class="line">    settingsElement(settings);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Properties <span class="title function_">settingsAsProperties</span><span class="params">(XNode context)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">  <span class="comment">// Check that all settings are known to the configuration class</span></span><br><span class="line">  <span class="type">MetaClass</span> <span class="variable">metaConfig</span> <span class="operator">=</span> MetaClass.forClass(Configuration.class, localReflectorFactory);</span><br><span class="line">  <span class="keyword">for</span> (Object key : props.keySet()) &#123;</span><br><span class="line">    <span class="comment">// 判断 Configuration 有没有 key 相应的 setter 方法</span></span><br><span class="line">    <span class="keyword">if</span> (!metaConfig.hasSetter(String.valueOf(key))) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;The setting &quot;</span> + key + <span class="string">&quot; is not known.  Make sure you spelled it correctly (case sensitive).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> props;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">settingsElement</span><span class="params">(Properties props)</span> &#123;</span><br><span class="line">  configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty(<span class="string">&quot;autoMappingBehavior&quot;</span>, <span class="string">&quot;PARTIAL&quot;</span>)));</span><br><span class="line">  configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty(<span class="string">&quot;autoMappingUnknownColumnBehavior&quot;</span>, <span class="string">&quot;NONE&quot;</span>)));</span><br><span class="line">  configuration.setCacheEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;cacheEnabled&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">  configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty(<span class="string">&quot;proxyFactory&quot;</span>)));</span><br><span class="line">  configuration.setLazyLoadingEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;lazyLoadingEnabled&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#settingsAsProperties(XNode)</code> 方法，解析的是 <code>&lt;settings&gt;</code> 标签，首先解释将 <code>&lt;settings&gt;</code> 标签的子标签 <code>&lt;setting&gt;</code> 都解析成了 Properties，然后又逐一判断了 Configuration 类是否有相应的配置属性的 setter 方法，只要其中一个配置在 Configuration 中没有，则直接抛出异常。</p><p><code>#settingElement(Properties)</code> 方法则就比较简单，因为前一个方法只是解析得到了每项配置的值，并未设置到 Configuration 类中，而这里就是单纯的做配置值的写入，对于 propeties 参数中没有的配置项，也都有相应的默认配置在此配置。</p><h2 id="environments-解析"><a href="#environments-解析" class="headerlink" title="environments 解析"></a>environments 解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">environmentsElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">// 如果 context 为 null 说明没有配置 environments</span></span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置当前默认激活的环境配置 id</span></span><br><span class="line">    <span class="keyword">if</span> (environment == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取 environments 标签的 default 属性值，作为当前默认激活的环境</span></span><br><span class="line">      environment = context.getStringAttribute(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : context.getChildren()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">      <span class="comment">// 判断当前 environment 标签的 id 是否是指定的默认环境的 id，如果是，则解析相应的配置，否则直接跳过 </span></span><br><span class="line">      <span class="keyword">if</span> (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">        <span class="comment">// 解析 transactionManager 标签</span></span><br><span class="line">        <span class="type">TransactionFactory</span> <span class="variable">txFactory</span> <span class="operator">=</span> transactionManagerElement(child.evalNode(<span class="string">&quot;transactionManager&quot;</span>));</span><br><span class="line">        <span class="comment">// 解析 dataSource 标签</span></span><br><span class="line">        <span class="type">DataSourceFactory</span> <span class="variable">dsFactory</span> <span class="operator">=</span> dataSourceElement(child.evalNode(<span class="string">&quot;dataSource&quot;</span>));</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> dsFactory.getDataSource();</span><br><span class="line">        Environment.<span class="type">Builder</span> <span class="variable">environmentBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Environment</span>.Builder(id)</span><br><span class="line">            .transactionFactory(txFactory)</span><br><span class="line">            .dataSource(dataSource);</span><br><span class="line">        <span class="comment">// 设置 environment</span></span><br><span class="line">        configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里贴一段 environments 标签的配置片段，方便理解。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;UNPOOLED&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Environments 标签的解析主要分为 2 步：</p><ol><li>设置默认的环境 id。</li><li>解析默认的环境配置。</li></ol><p>默认的环境配置是必须设置，不然解析工作没法往下进行，并且在 <code>#isSpecifiedEnvironment(String)</code> 方法中，如果默认的环境未指定，即 <code>environment</code> 变量还是 null 的话，会直接报错。</p><p>解析默认的环境配置，又分为了 3 步：</p><ol><li>解析 <code>&lt;transactionManager&gt;</code> 标签，这里解析得到的是一个 <code>TransactionFactory</code> 对象。</li><li>解析 <code>&lt;dataSource&gt;</code> 标签，这里解析得到的是一个 <code>DataSourceFactory</code> 对象，然后从该对象中才获取到了 DataSource。</li><li>通过前 2 步解析的结果组装 <code>Environment</code> 对象，并设置进 configuration 中。</li></ol><h3 id="transactionManager-标签解析"><a href="#transactionManager-标签解析" class="headerlink" title="transactionManager 标签解析"></a>transactionManager 标签解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TransactionFactory <span class="title function_">transactionManagerElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">// 检查 transactionManager 是否配置，如果未配置，则抛异常</span></span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取 type 属性字段值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">    <span class="comment">// 将所有 property 子标签解析成一个 Properties 对象</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">// 通过 type 得到 TransactionFactory 具体的实现类，并得到一个具体的实例</span></span><br><span class="line">    <span class="type">TransactionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (TransactionFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    <span class="comment">// 通过 setProperties 方法设置属性</span></span><br><span class="line">    factory.setProperties(props);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Environment declaration requires a TransactionFactory.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取 type 字段值。</li><li>解析 property 子标签，放入一个 Properties 对象。</li><li>通过 type 获取 TransactionFactory 具体的实现，并得到实例化对象，深入查看 <code>#resolveClass(String)</code> 方法的逻辑，其实 type 是一个类别名，类别名除了在解析 <code>&lt;typeAliases&gt;</code> 标签时会注册，在 Configuration 类的默认无参构造中，也会注册很多。</li><li>通过 <code>TransactionFactory#setProperties(Properties)</code> 方法设置属性。</li></ol><p>这里再看看 TransactionFactory 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置自定义参数，接口的 default 方法，默认空实现，实现类可不实现该方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties props)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从现有连接中新创建一个 Transaction </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Transaction <span class="title function_">newTransaction</span><span class="params">(Connection conn)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从现有的 DataSource 中创建一个新的 Transaction</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Transaction <span class="title function_">newTransaction</span><span class="params">(DataSource dataSource, TransactionIsolationLevel level, <span class="type">boolean</span> autoCommit)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见，setProperties() 方法作为一个自定义实现的参数设置的方法，实现类可以不实现该方法。</p><h3 id="dataSource-标签解析"><a href="#dataSource-标签解析" class="headerlink" title="dataSource 标签解析"></a>dataSource 标签解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DataSourceFactory <span class="title function_">dataSourceElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">// 判断 dataSource 是否配置，如果没配置直接抛异常</span></span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取 type 属性值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">    <span class="comment">// 解析 property 子标签</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">// 通过 type 获取 DataSourceFactory 实现类，并实例化</span></span><br><span class="line">    <span class="type">DataSourceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (DataSourceFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    <span class="comment">// 通过 setProperties 方法设置参数</span></span><br><span class="line">    factory.setProperties(props);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Environment declaration requires a DataSourceFactory.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dataSource 标签的解析过程和 transactionManager 标签的解析逻辑基本一致，不再赘述，这里再看看 DataSourceFactory 接口的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataSourceFactory</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties props)</span>;</span><br><span class="line">  DataSource <span class="title function_">getDataSource</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见，和 TransactionFactory 不同的是，DataSourceFacory 的 <code>#setProperties(Properties)</code> 方法是必须实现的。 </p><h2 id="mapper-解析"><a href="#mapper-解析" class="headerlink" title="mapper 解析"></a>mapper 解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">// 判断子标签是否为 package</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过包名导入 mapper</span></span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 解析 mapper 子标签</span></span><br><span class="line">        <span class="comment">// 获取 resource 属性值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取 url 属性值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取 class 属性值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperClass</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 只配置了 resource，加载相应的资源并通过 XMLMapperBuilder 进行解析，换言之，</span></span><br><span class="line">          <span class="comment">// 这里是导入了 Mapper 的 xml 配置文件</span></span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">          <span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource)) &#123;</span><br><span class="line">            <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">            <span class="comment">// 解析 mapper xml 配置文件</span></span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url != <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 只配置了 url，依然是当成 xml 配置文件进行解析</span></span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          <span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getUrlAsStream(url))&#123;</span><br><span class="line">            <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">            <span class="comment">// 解析 mapper xml 配置文件</span></span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 只配置了 class </span></span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// url、class、resource 3 个属性，只能配置其中一个，否则解析过程就会抛出异常</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>如果子标签是 <code>&lt;package&gt;</code> 则按包名导入。</li><li>如果子标签是 <code>&lt;mapper&gt;</code>，则开始解析其 resource、url、class 3 个属性，这 3 个属性只能配置其中一个，resource、url 指定的是 xml 配置文件，调用<code>XMLMapperBuilder#parse()</code> 方法进行解析和导入，而 class 属性指定的是 Java 类，加载了对应的 Class 对象之后，直接调用 <code>Configuration#addMapper(Class)</code> 方法进行导入，内部是直接调用了 <code>MapperRegistry#addMapper(Class)</code> 方法进行导入，其实通过包名导入时，最终也是通过这个方法进行的导入。</li></ol><p>那么，接下来需要关注 2 个方法：</p><ol><li><code>XMLMapperBuilder#parse()</code> 方法，负责解析 mapper 的 xml 配置文件并进行导入。</li><li><code>MapperRegistry#addMapper(Class)</code> 方法，直接通过 Class 进行导入。</li></ol><h3 id="mapper-xml-配置文件解析"><a href="#mapper-xml-配置文件解析" class="headerlink" title="mapper xml 配置文件解析"></a>mapper xml 配置文件解析</h3><h3 id="通过-Class-导入-mapper"><a href="#通过-Class-导入-mapper" class="headerlink" title="通过 Class 导入 mapper"></a>通过 Class 导入 mapper</h3>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码解析：循环依赖</title>
      <link href="posts/699a08b1d2d6.html"/>
      <url>posts/699a08b1d2d6.html</url>
      
        <content type="html"><![CDATA[<p>前面几篇文章已经讲完了 bean 加载的大部分核心内容，并多次提及了循环依赖这个词。本文会讲述循环依赖如何产生，Spring 是如何解决，已经当前解决方案的局限，其中涉及大家耳熟能详的三级缓存、AOP 代理等技术点。</p><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p>我们知道循环依赖最简单的例子就是对象 A 和 对象 B 相互依赖注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Spring 加载 bean 的时候，不管先加载哪一个，到注入时，都需要得到另一个 bean 的实例引用。加载 A 需要得到 B 的引用，此时去加载 B，又需要拿到 A 的引用，但是此时 A 还没创建完成，如果不做处理，这里就会陷入创建 A、B 两个实例的无限循环之中。</p><h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>网上都说 Spring 解决循环依赖，主要是还是依靠三级缓存的机制，所以有必要先了解三级缓存。</p><p>在之前的博文中已经讲过，Spring 中有三级缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance.</span></span><br><span class="line"><span class="comment"> * 一级缓存，存储单例 bean 名称和对应的最终版的 Bean 实例对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance.</span></span><br><span class="line"><span class="comment"> * 二级缓存，存储单例 bean 名称和对应的 Bean 的最初版本 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory.</span></span><br><span class="line"><span class="comment"> * 三级缓存，存储单例 bean 名称和对应的 Bean 的函数式工厂对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><ul><li>一级缓存 singletonObjects，记录 beanName 和已完成所有初始化工作的 bean 实例的映射关系。</li><li>二级缓存 earlySingltonObjects，记录 beanName 和已实例化但未初始化的 bean 实例的映射关系。</li><li>三级缓存 singltonFactories，记录 beanName 和 bean 的 ObjectFactory 的映射关系。</li></ul><p>实例化，是指在内存中创建了对象；初始化，是指实例化之后，进行的一些列初始化操作，这里讲初始化，包括对象属性的填充以及执行特定的初始化方法等。</p><p>所以，“翻译”一下，一级缓存存的是完成了实例化、初始化的 bean 实例，二级缓存存的是已经完成了实例化的 bean 实例。</p><p>需要注意的是，bean 创建过程中，都是先加入三级缓存，再进入二级缓存，最后进入一级缓存。</p><h2 id="解决循环依赖"><a href="#解决循环依赖" class="headerlink" title="解决循环依赖"></a>解决循环依赖</h2><p>我们首先按照前面讲循环依赖时，新建 A、B 两个 bean，然后我们根据前面几篇博文的思路，一点点剖析。</p><p>这里首先加载 bean A，那么整体的流程图如下：</p><p><img src="http://image.hanelalo.cn/image/202301082122583.svg" alt="Spring循环依赖"></p><p>上图中，绿色为创建 A 的过程，蓝色为创建 B 的过程，可以看见，A 的创建由容器主动触发，而 B 的创建并非容器主动触发，而是因为 A 依赖了 B，当 A 要进行属性填充时，调用了 getBean() 方法创建了 B 的实例。</p><p>同样的，B 也依赖了 A，当为 B 实例进行属性填充时，会调用 getBean() 方法获取 A 的实例，但是因为 getBean() 方法会调用 getSinglton() 方法尝试获取 A 的实例，而 A 实例在此之前通过 ObjectFactory 的方式放到了第三级缓存中，所以，getSinglton() 方法会返回在之前创建的 A 实例的引用，并将 A 从三级缓存迁移到二级缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line"><span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line"><span class="comment">// singletonObjects，一级缓存，存储 beanName 和 bean 实例对象的映射关系</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span></span><br><span class="line"><span class="comment">// 目标 bean 是否还在创建中</span></span><br><span class="line">&amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="comment">// 从二级缓存中获取 bean 实例，二级缓存中的 bean 实例一般都是还没创建完成的实例</span></span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span></span><br><span class="line"><span class="comment">// 二级缓存中依然没有，如果允许提前创建，就访问三级缓存</span></span><br><span class="line">&amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="comment">// 单例模式同步双重校验</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 从三级缓存中拿到 bean 的 ObjectFactory 对象，从而拿到 bean 的早期引用</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="comment">// 将 bean 实例放入二级缓存</span></span><br><span class="line"><span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="comment">// 将 beanName 和 ObjectFactory 的映射关系从三级缓存中删除</span></span><br><span class="line"><span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们回头看看这里的 ObjectFactory 里面有什么？</p><p>从前面的流程看见，是实例化了 A 对象之后，才加入了三级缓存，代码位于 doCreateBean() 方法中，最后的 ObjectFactory 的内容对应的就是 <code>AbstractAutowireCapableBeanFactory#getEarlyBeanReference()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>beanName 是 bean 名称。</li><li>mbd 是 bean 的 MergedBeanDefinition。</li><li>bean 则是还未加载完成的 bean 实例。</li></ul><p>中间的 if 和 for 循环可以暂时跳过，因为这部分是一些自定义扩展的逻辑，包括 Spring AOP 的逻辑，抛开这些不谈，其实就是直接返回的刚实例化好的 bean 实例，尽管还没有完成属性填充等操作，但就算最终完成了属性填充、初始化等操作，对象的引用是不会变的，所以这里拿到了对象引用就够了。</p><p>就这样，创建 B 时，也拿到了 A 的实例，虽然 A 还并不“完整”。</p><p>拿到 A 的实例之后，B 也就能正常创建完成，而创建 A 时调用的 populateBean() 方法也能正常拿到 B 的实例，A 最终也能创建完成。</p><p>到这里，思路和逻辑应该还是比较清晰的，那就继续思考一个问题：既然创建 B 时，拿 A 对象的时候，会把 A 放到从三级缓存迁移二级缓存，那为何不一开始就将 A 放在二级缓存中，这样 B 依然能正常拿到 A 的实例，这个过程中三级缓存的作用不大，换言之，这里我们我们要思考的是，<strong>第三级缓存有什么用？</strong></p><h3 id="第三级缓存和-AOP"><a href="#第三级缓存和-AOP" class="headerlink" title="第三级缓存和 AOP"></a>第三级缓存和 AOP</h3><blockquote><p>在前面已经有单独的一篇博文详细讲过 Spring AOP: <a href="/posts/629e417006f1">Spring源码解析：Spring AOP</a>。</p></blockquote><p>其实网上很多博文都说过，是因为 AOP 机制的存在，才让第三级缓存变成了“必须”，我觉得这其实没错，确实和 AOP 也有关系。</p><p>还是 A、B 两个 bean 循环依赖的例子，不过 A 还多了一层 AOP 代理，我们知道 Spring 的代理方式有 JDK 动态代理和基于 Cglib 实现的动态代理，这两种代理的区别，以及动态代理和静态代理的区别，可以参考很久之前的博文：<a href="/posts/b8f5ebf685e8">静态代理和动态代理</a>，这里就不再赘述。</p><p>这里只需要明确 Spring 中代理生成的对象，和被代理的对象并不是同一个对象，Spring 启动完成后，对于有代理的情况，依赖的都是代理生成的对象，而不是最原始的那个 Java 对象。</p><p>有点绕，拿前面 A、B 循环依赖的例子说明，A 多了一层 AOP 代理，那么 B 最终拿到的 A 对象其实不是上面的流程图最开始创建 A 对象的引用，而是它的代理对象 Proxy$A，让 B 拿不到真正的 A 对象，这样才能从逻辑上保证 AOP 能真正完成切面。</p><p>好的，那么接下来，基于以上的例子，就有 3 个问题要解决：</p><ol><li>问题一：B 如何拿到 A 的代理对象的？</li><li>问题二：A 的创建过程中，最终放到一级缓存中的也应是代理对象，如果没有另一个 bean 依赖它，那是什么时候做了这层代理的工作，拿到代理对象？</li><li>问题三：第三级缓存对 AOP 有什么必要性？</li></ol><blockquote><p>如果把有 AOP 的情况弄明白了，那自然就明白了没有 AOP 横插一脚的循环依赖的情况了。</p></blockquote><h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><blockquote><p>问题一：B 如何拿到 A 的代理对象的？</p></blockquote><p>前面的的 A、B 初始化得了流程图中，有一个细节是没有画出来的，就是在 doGetBean() 方法执行过程中会调用 <code>DefaultSingletonBeanRegistry#getSingleton(String)</code> 方法，参数为要回去的 bean 的 beanName 该方法又会调用 <code>DefaultSingletonBeanRegistry#getSingleton(String, boolean)</code> 方法，其中第一个参数依然为 beanName，第二个参数则是决定是否允许返回 bean 的早期引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line"><span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line"><span class="comment">// singletonObjects，一级缓存，存储 beanName 和 bean 实例对象的映射关系</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span></span><br><span class="line"><span class="comment">// 目标 bean 是否还在创建中</span></span><br><span class="line">&amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="comment">// 从二级缓存中获取 bean 实例，二级缓存中的 bean 实例一般都是还没创建完成的实例</span></span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span></span><br><span class="line"><span class="comment">// 二级缓存中依然没有，如果允许提前创建，就访问三级缓存</span></span><br><span class="line">&amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="comment">// 单例模式同步双重校验</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 从三级缓存中拿到 bean 的 ObjectFactory 对象，从而拿到 bean 的早期引用</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="comment">// 将 bean 实例放入二级缓存</span></span><br><span class="line"><span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="comment">// 将 beanName 和 ObjectFactory 的映射关系从三级缓存中删除</span></span><br><span class="line"><span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我也把 A、B 两个 bean 加载的流程图再搬过来。</p><p><img src="http://image.hanelalo.cn/image/202301082122583.svg" alt="Spring循环依赖"></p><p>在 A 加载过程中，因为对 B 的依赖，触发了 B 的加载，B 加载时，又依赖 A，所以又调用了 <code>getBean(String)</code> 方法获取 A 的实例，而此时，A 的实例对象虽然已经创建，但并不在一、二级缓存中，而只是被第三级缓存中的 A 的 ObjectFactory 持有。所以上面这次 <code>getSingleton(String, boolean)</code> 的调用，会拿到 A 的 ObjectFactory 并执行其逻辑。</p><p>A 对应的 ObjectFacotry 的逻辑其实就是下面这个方法，在源码中能找到的不多说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里从 BeanPostProcessor 的缓存中拿到了 smartInstantiationAware：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BeanPostProcessorCache</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> List&lt;InstantiationAwareBeanPostProcessor&gt; instantiationAware = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> List&lt;SmartInstantiationAwareBeanPostProcessor&gt; smartInstantiationAware = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> List&lt;DestructionAwareBeanPostProcessor&gt; destructionAware = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> List&lt;MergedBeanDefinitionPostProcessor&gt; mergedDefinition = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 SmartInstantiationAwareBeanPostProcessor 的诸多实现类，包括一个抽象实现类 AbstractAutoProxyCreator，这个抽象类又有两个实现类：AnnotationAwareAspectJAutoProxyCreator、AspectJAwareAdvisorAutoProxyCreator。</p><p>这两个实现类是 Spring AOP 的组合到 Spring 容器的关键组件。</p><pre><code class="highlight mermaid">classDiagramdirection BTclass AbstractAdvisorAutoProxyCreatorclass AbstractAutoProxyCreatorclass AnnotationAwareAspectJAutoProxyCreatorclass AspectJAwareAdvisorAutoProxyCreatorclass BeanPostProcessor &#123;&lt;&lt;Interface&gt;&gt;&#125;class InstantiationAwareBeanPostProcessor &#123;&lt;&lt;Interface&gt;&gt;&#125;class SmartInstantiationAwareBeanPostProcessor &#123;&lt;&lt;Interface&gt;&gt;&#125;AbstractAdvisorAutoProxyCreator  --&gt;  AbstractAutoProxyCreator AbstractAutoProxyCreator  ..&gt;  SmartInstantiationAwareBeanPostProcessor AnnotationAwareAspectJAutoProxyCreator  --&gt;  AspectJAwareAdvisorAutoProxyCreator AspectJAwareAdvisorAutoProxyCreator  --&gt;  AbstractAdvisorAutoProxyCreator InstantiationAwareBeanPostProcessor  --&gt;  BeanPostProcessor SmartInstantiationAwareBeanPostProcessor  --&gt;  InstantiationAwareBeanPostProcessor</code></pre><p>抽象实现类 <code>AbstractAutoProxyCreator</code> ，也实现了 <code>getEarlyBeanReference</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前两行代码只是缓存的处理，cacheKey 要么是 beanName，要么就是 bean 的 Class。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getCacheKey</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> (FactoryBean.class.isAssignableFrom(beanClass) ?</span><br><span class="line">BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> beanClass;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>wrapIfNecessary</code> 方法，会有具体生成代理的逻辑，这里不再深究，可再 <a href="/posts/629e417006f1">Spring源码解析：Spring AOP</a> 中深入了解。</p><p>从上面可以看出，<strong>通过第三级缓存的 ObjectFactory 是可以拿到 bean 的代理对象的，哪怕此时 A 的 bean 对象实例没有初始化完成，但至少对象的内存引用地址不会再变了。</strong></p><h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><blockquote><p>问题二：A 的创建过程中，最终放到一级缓存中的也应是代理对象，如果没有另一个 bean 依赖它，那是什么时候做了这层代理的工作，拿到代理对象？</p></blockquote><p>这个其实在前面的流程图中的最后一步，执行 A 的初始化逻辑时发生的，具体的入口就是在 doCreateBean() 方法中，调用了 initializeBean() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 执行 init-method 之前的前处理器</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 执行 init-method 方法</span></span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">(mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>),</span><br><span class="line">beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 执行 init-method 后处理器</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段逻辑里面，参数 bean 就是实例化后的 bean 对象实例，然后再执行以下 3 步：</p><ol><li>初始化前，调用 applyBeanPostProcessorsBeforeInitialization() 方法，执行 <code>BeanPostProcessor#postProcessBeforeInitialization()</code> 方法（但 AOP 的逻辑没在这一步）。</li><li>执行初始化方法，比如执行配置文件执行的 init-method。</li><li>初始化后，调用 applyBeanPostProcessorsAfterInitialization() 反复噶，执行 <code>BeanPostProcessor#postProcessAfterInitialization()</code> 方法，这里才有 AOP 的处理逻辑。</li></ol><p>所以这里我们只关注第 3 步，查看 AnnotationAwareAspectJAutoProxyCreator、AspectJAwareAdvisorAutoProxyCreator 的类继承接口，可以看见，在这一步，执行的是它们的父类的方法：<code>AbstractAutoProxyCreator#postProcessAfterInitialization(Object, String)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又看见了熟悉的 <code>wrapIfNecessary()</code> 方法，所以这里其实也能拿到代理对象。</p><p>不过，这里代码虽然短，但是背后的逻辑比较复杂：</p><ol><li>如果不曾有 B 或者其他 bean 依赖 A，那么到上述逻辑时，势必会调用到 wrapIfNecessary() 方法中，创建 A 的代理对象并返回。</li><li>如果有 B 或者其他 bean 依赖 A，那么到这里时，要么是 A 已经创建了代理对象，则直接返回 bean，要么就是还没有创建，则直接创建代理对象并返回。</li></ol><p>如果直接返回 bean，那表明再次之前，代理对象已经创建，那也只能是因为其他 bean 的依赖而创建，那么此时最终会暴露出来的 A 的 bean 实例，其实是前面第一个问题中调用 getSingleton(String) 方法时，就已经进入了二级缓存的代理对象。</p><p>当 <code>initializeBean()</code> 方法执行完成后，还会调用一次 getSingleton(String, boolean) 方法，只不过第二个参数传入的是 false，也就是说只能第一、二级缓存中获取实例，而对于 A 再调用 <code>initializeBean()</code> 方法前就已经创建了代理对象的情况，则肯定是能在第二级缓存中拿到代理对象的。</p><p>那么，到这里就能发现，不管哪种方式，其实都能拿到代理对象，最终放入一级缓存中。</p><h4 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h4><blockquote><p>问题三：第三级缓存对 AOP 有什么必要性？</p></blockquote><p>这里的必要性，我认为，其实是因为解决循环依赖时，如果没有第三级缓存，在还有 AOP 的情况下，是没办法拿到还在加载中的 bean 的代理对象的，因为第二级和第一级缓存中对象的区别只是是否完成了初始化工作，但实际上确实同一个内存地址引用，而 AOP 处理过后的代理对象，和原来的对象，已经连内存地址引用都不是同一个。</p><h2 id="循环依赖解决方案的局限性"><a href="#循环依赖解决方案的局限性" class="headerlink" title="循环依赖解决方案的局限性"></a>循环依赖解决方案的局限性</h2><p>从前面的流程图，以及各种逻辑细节的讨论中，我们会发现，循环依赖的解决，主要是依赖于 bean 的加载过程中允许获取早期引用，即拿到一个业务上非完整的对象引用，换句话说，需要 new 这个关键字的逻辑执行完之后，才有这个早期引用。</p><p>而如果是通过构造函数初始化，且循环依赖的 bean 还恰好和这个构造函数相关联，以前面的例子来看，就会出现 A 实例还未创建就触发了 B 的创建，而 B 依赖 A，又会获取 A 的早期实例，但是此时 A 实例化都还没有完成，从而导致局面僵死。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Spring 循环依赖的解决方案，依赖于 Spring 的三级缓存机制。</li><li>该解决方案，不适用于构造函数上的循环依赖。</li><li>Spring 的第三级缓存，对于解决有 AOP 代理穿插其中的循环依赖，是必要的，因为能通过第三级缓存拿到依赖 bean 的代理对象。</li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="/posts/629e417006f1">Spring源码解析：Spring AOP</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码解析：Spring AOP</title>
      <link href="posts/629e417006f1.html"/>
      <url>posts/629e417006f1.html</url>
      
        <content type="html"><![CDATA[<p>本来是要写循环依赖的，但是写着写着才想起都没讲解 AOP，那循环依赖就没饭讲得比较透彻了，所以先讲 AOP 的体系梳理一遍。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="AOP-核心概念"><a href="#AOP-核心概念" class="headerlink" title="AOP 核心概念"></a>AOP 核心概念</h2><ul><li><p>Aspect</p><p>其实就是一个用来实现 AOP 的模块。Spring AOP 中要么通过 XML schema 指定的类或者直接通过 <code>@Aspect</code> 注解来实现。</p></li><li><p>Join point</p><p>连接点，在程序运行过程中进行增强的点，比如在 Spring 中的某个方法。</p></li><li><p>Advice</p><p>在某个特定的连接点的切入方式。这样说其实有点难理解，其实就是日常使用切面时，常常需要注意的 <code>around</code>、<code>before</code>、<code>after</code> 这三种切入形式。</p></li><li><p>Pointcut</p><p>断言 Join point 是否匹配。advice 会关联一个 Pointcut 表达式，并通过 Pointcut 匹配所有 Join point，这个动作是 AOP 的核心概念。</p></li><li><p>Introduction</p><p>可以为类型额外声明方法或者属性。Spring AOP 能让你为任意的被 Advice 处理过的类增加实现接口。</p></li><li><p>Target object</p><p>被一个或多个 Advice 处理后的对象，Spring 中一般使用动态代理，所以 Target Object 肯定是代理对象。</p></li><li><p>AOP proxy</p><p>为了实现 AOP 契约，通过 AOP 框架创建的对象。Spring 中 AOP proxy 都是通过 Jdk 动态代理或者 Cglib 创建的。</p></li><li><p>Weaving</p><p>用于链接 aspects 和其他应用程序或类型，用于创建 Target Object。它可以在编译时、加载时、运行时完成。Spring AOP 和其他纯 Java 的 AOP 框架一样，都是在运行时进行这一步。</p></li></ul><p>Spring 中，Advice 还细分为了下面 5 种：</p><ol><li>Before Advice，在 Join point 之前执行 Advice，除非抛出了一场，不然不会阻断流程到达 Join point。</li><li>After returning advice，通常是在 Join point 执行完全完成之后执行 Advice（比如方法不抛异常而正常返回后）。</li><li>After throwing advice，在 Join point 对应的方法因异常而退出时执行 Advice。</li><li>After advice，不管是正常返回还是方法异常退出，都一定会在之后执行 Advice，这就和 finally 关键一样。</li><li>Around advice，包围整个 Join point 的执行，可以在执行前、后都加上一些自定义的操作。</li></ol><h2 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h2><ul><li>execution，这个其实就是用来匹配 Join point，Spring 中常用的主要就是它。</li><li>@annottion，用于匹配有指定注解的 Join point。</li></ul><blockquote><p><strong>Notice</strong></p><p>其实关键字还有很多，但这里就不赘述，这里主要介绍一下 Pointcut 表达式常用的几个关键字。</p></blockquote><h2 id="代理机制"><a href="#代理机制" class="headerlink" title="代理机制"></a>代理机制</h2><p>前面说到，Spring 中动态代理有两种方式：一种是 JDK 动态代理，由 JDK 原生提供；一种是 Cglib，是一个开源的字节码生成器项目，在 spring-core 中重新封装了一次后使用。</p><p>在 Spring 中，默认的规则是：如果代理对象实现了多个接口，则使用 JDK 动态代理，如果没有实现任何接口，则使用 Cglib。如果在 Spring 中要强制使用 Cglib，可以将 <code>&lt;aop:config&gt;</code> 标签的 <code>proxy-target-class</code> 属性设置为 true。如果是在使用 @AspectJ 时要强制使用 Cglib，则需要设置 <code>&lt;aop:aspectj-autoproxy&gt;</code> 标签的 <code>proxy-target-class</code> 属性为 true。</p><blockquote><p><code>&lt;aop:config&gt;</code>、<code>&lt;aop:aspectj-autoproxy&gt;</code> 有什么区别？后面讲。</p></blockquote><p>但是，Cglib 对 final 关键字修饰的方法是没办法进行代理的。</p><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>在官方文档里面介绍了很多 Spring AOP 的重要接口，为了方便理解，这里就不直接一个个介绍接口，接下来会从 Spring IOC 容器启动过程中 AOP 相关逻辑入手，一步步进行解释。</p><p>首先，我们知道在 Spring 中要启用 AspectJ，可以通过 xml 配置文件开启，另一种方式则是可以通过在配置类上增加 <code>@EnableAspectJAutoProxy</code> 注解实现，这两种其实都差不多，这里以 xml 方式开始深入其原理。</p><h2 id="AOP-标签解析"><a href="#AOP-标签解析" class="headerlink" title="AOP 标签解析"></a>AOP 标签解析</h2><p>如果还记得最开始学习 Spring 时是如何在 xml 文件里面配置 AOP 的话，应该就知道，AOP 相关的标签并不在 Spring 的默认命名空间里面，而是需要单独引入，属于自定义标签，只不过是 Spring 已经实现了。</p><p>在<a href="/posts/163184d50150">Spring 源码解析：自定义标签</a>一文中，有提到，自定义标签需要实现 NamespaceHandlerSupport 抽象类，AOP 对应的实现类就是 <code>AopNamespaceHandler</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopNamespaceHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the &#123;<span class="doctag">@link</span> BeanDefinitionParser BeanDefinitionParsers&#125; for the</span></span><br><span class="line"><span class="comment"> * &#x27;&#123;<span class="doctag">@code</span> config&#125;&#x27;, &#x27;&#123;<span class="doctag">@code</span> spring-configured&#125;&#x27;, &#x27;&#123;<span class="doctag">@code</span> aspectj-autoproxy&#125;&#x27;</span></span><br><span class="line"><span class="comment"> * and &#x27;&#123;<span class="doctag">@code</span> scoped-proxy&#125;&#x27; tags.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// In 2.0 XSD as well as in 2.5+ XSDs</span></span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;config&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConfigBeanDefinitionParser</span>());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;aspectj-autoproxy&quot;</span>, <span class="keyword">new</span> <span class="title class_">AspectJAutoProxyBeanDefinitionParser</span>());</span><br><span class="line">registerBeanDefinitionDecorator(<span class="string">&quot;scoped-proxy&quot;</span>, <span class="keyword">new</span> <span class="title class_">ScopedProxyBeanDefinitionDecorator</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only in 2.0 XSD: moved to context namespace in 2.5+</span></span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;spring-configured&quot;</span>, <span class="keyword">new</span> <span class="title class_">SpringConfiguredBeanDefinitionParser</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="aop-aspectj-autoproxy-标签解析"><a href="#aop-aspectj-autoproxy-标签解析" class="headerlink" title="aop:aspectj-autoproxy 标签解析"></a>aop:aspectj-autoproxy 标签解析</h2><p>我们直接看 aspectj-autoproxy 对应的 AspectJAutoProxyBeanDefinitionParser 的 parse() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">extendBeanDefinition(element, parserContext);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两步，第一步主要是为了注册 <code>AnnotationAwareAspectJAutoProxyCreator</code> 这个 bean，这算是 AOP 这个功能一切的开始；第二步则是解析 <code>aspectj-autoproxy</code> 标签的子标签。</p><p>这里主要关注第一步，也就是 <code>AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span><br><span class="line"><span class="params">ParserContext parserContext, Element sourceElement)</span> &#123;</span><br><span class="line"><span class="comment">// 注册 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line"><span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line"><span class="comment">// 处理 proxy-target-class 属性和 expose-proxy 属性</span></span><br><span class="line">useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line"><span class="comment">// 注册组件</span></span><br><span class="line">registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样只关注 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; APC_PRIORITY_LIST = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">// Set up the escalation list...</span></span><br><span class="line">APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);</span><br><span class="line">APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span><br><span class="line"><span class="params">BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerOrEscalateApcAsRequired</span><span class="params">(</span></span><br><span class="line"><span class="params">Class&lt;?&gt; cls, BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line"></span><br><span class="line">Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AUTO_PROXY_CREATOR_BEAN_NAME = org.springframework.aop.config.internalAutoProxyCreator</span></span><br><span class="line"><span class="comment">// 先判断 beanDefinition 是否存在</span></span><br><span class="line"><span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line"><span class="comment">// 如果已经存在，则拿到已经存在 BeanDefinition 和当前要注册的 beanClass 比较</span></span><br><span class="line"><span class="type">BeanDefinition</span> <span class="variable">apcDefinition</span> <span class="operator">=</span> registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line"><span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line"><span class="comment">// 不是同一个 class, 则比较优先级，数字越大，优先级越高</span></span><br><span class="line"><span class="type">int</span> <span class="variable">currentPriority</span> <span class="operator">=</span> findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line"><span class="type">int</span> <span class="variable">requiredPriority</span> <span class="operator">=</span> findPriorityForClass(cls);</span><br><span class="line"><span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(cls);</span><br><span class="line">beanDefinition.setSource(source);</span><br><span class="line">beanDefinition.getPropertyValues().add(<span class="string">&quot;order&quot;</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line"><span class="comment">// 设置 bean 的 role 为 spring 基础设施类的 bean</span></span><br><span class="line">beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line"><span class="comment">// 注册 beanDefinition</span></span><br><span class="line">registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line"><span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findPriorityForClass</span><span class="params">(<span class="meta">@Nullable</span> String className)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; APC_PRIORITY_LIST.size(); i++) &#123;</span><br><span class="line">Class&lt;?&gt; clazz = APC_PRIORITY_LIST.get(i);</span><br><span class="line"><span class="keyword">if</span> (clazz.getName().equals(className)) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line"><span class="string">&quot;Class name [&quot;</span> + className + <span class="string">&quot;] is not a known auto-proxy creator class&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码逻辑上看，AOP 功能的开启并非必须使用 <code>AnnotationAwareAspectJAutoProxyCreator</code>，根据环境的不同，可能也会注册成其他的类，不过 beanName 都是 <code>org.springframework.aop.config.internalAutoProxyCreator</code>。</p><p>对于这个 beanName 已经注册的情况，则取出已注册的 BeanDefinition 的 class，对比两个 class 在 APC_PRIORITY_LIST 中的优先级，在 APC_PRIORITY_LIST 中越往后的优先级越高。</p><blockquote><p>前面讲到 AOP 标签解析的 AopNamespaceHandler 时，代码中有一个 config 标签的解析，解析时会注册 <code>AspectJAwareAdvisorAutoProxyCreator</code> 类的 BeanDefinition，beanName 也是 <code>org.springframework.aop.config.internalAutoProxyCreator</code>，那么逻辑上看，如果同时使用了 config、aspectj-autoproxy，那么最终注册的其实是 <code>AnnotationAwareAspectJAutoProxyCreator</code>。</p></blockquote><h2 id="AnnotationAwareAspectJAutoProxyCreator-类"><a href="#AnnotationAwareAspectJAutoProxyCreator-类" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator 类"></a>AnnotationAwareAspectJAutoProxyCreator 类</h2><h3 id="类继承结构"><a href="#类继承结构" class="headerlink" title="类继承结构"></a>类继承结构</h3><p>我们看看 AnnotationAwareAspectJAutoProxyCreator 这个类的继承结构。</p><pre><code class="highlight mermaid">classDiagramdirection BTclass AbstractAdvisorAutoProxyCreatorclass AbstractAutoProxyCreatorclass AnnotationAwareAspectJAutoProxyCreatorclass AopInfrastructureBean &#123;&lt;&lt;Interface&gt;&gt;&#125;class AspectJAwareAdvisorAutoProxyCreatorclass Aware &#123;&lt;&lt;Interface&gt;&gt;&#125;class BeanClassLoaderAware &#123;&lt;&lt;Interface&gt;&gt;&#125;class BeanFactoryAware &#123;&lt;&lt;Interface&gt;&gt;&#125;class BeanPostProcessor &#123;&lt;&lt;Interface&gt;&gt;&#125;class InstantiationAwareBeanPostProcessor &#123;&lt;&lt;Interface&gt;&gt;&#125;class Ordered &#123;&lt;&lt;Interface&gt;&gt;&#125;class ProxyConfigclass ProxyProcessorSupportclass Serializable &#123;&lt;&lt;Interface&gt;&gt;&#125;class SmartInstantiationAwareBeanPostProcessor &#123;&lt;&lt;Interface&gt;&gt;&#125;AbstractAdvisorAutoProxyCreator  --&gt;  AbstractAutoProxyCreator AbstractAutoProxyCreator  ..&gt;  BeanFactoryAware AbstractAutoProxyCreator  --&gt;  ProxyProcessorSupport AbstractAutoProxyCreator  ..&gt;  SmartInstantiationAwareBeanPostProcessor AnnotationAwareAspectJAutoProxyCreator  --&gt;  AspectJAwareAdvisorAutoProxyCreator AspectJAwareAdvisorAutoProxyCreator  --&gt;  AbstractAdvisorAutoProxyCreator BeanClassLoaderAware  --&gt;  Aware BeanFactoryAware  --&gt;  Aware InstantiationAwareBeanPostProcessor  --&gt;  BeanPostProcessor ProxyConfig  ..&gt;  Serializable ProxyProcessorSupport  ..&gt;  AopInfrastructureBean ProxyProcessorSupport  ..&gt;  BeanClassLoaderAware ProxyProcessorSupport  ..&gt;  Ordered ProxyProcessorSupport  --&gt;  ProxyConfig SmartInstantiationAwareBeanPostProcessor  --&gt;  InstantiationAwareBeanPostProcessor</code></pre><p>这张图需要注意的有 2 点：</p><ol><li>AnnotationAwareAspectJAutoProxyCreator 继承自 AspectJAwareAdvisorAutoProxyCreator，从命名上看，前者主要是支持了注解方式的 AOP。</li><li>AnnotationAwareAspectJAutoProxyCreator 实现了 BeanPostProcessor 接口，BeanPostProcessor 是 Spring 提供的一个用于自定义修改 bean 实例的扩展接口，AOP 其实就是通过这个机制生效的。</li></ol><p>在初始化 bean 之前，会调用 BeanPostProcessor 的 postProcessBeforeInitialization() 方法，初始化后会调用 postProcessAfterInitialization() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册-BeanPostProcessor"><a href="#注册-BeanPostProcessor" class="headerlink" title="注册 BeanPostProcessor"></a>注册 BeanPostProcessor</h3><p>BeanPostProcessor 的 bean 是在 bean 加载时注册到 beanPostProcessor 的列表中的。</p><p>在 Spring 容器初始化过程中，调用了一个 refresh() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(</span></span><br><span class="line"><span class="params">String[] configLocations, <span class="type">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span><br><span class="line"><span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">super</span>(parent);</span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>refresh() 方法并不是只有 ClassPathXmlApplicationContext 在调用，这里只是以 ClassPathXmlApplicationContext 举例。</p></blockquote><p>refresh() 中就是整个 Spring 启动的流程了，其中有调用 <code>registerBeanPostProcessors()</code> 方法用于注册 BeanPostProcessor，这里不展开将，后面开一篇新的博文专门讲 BeanPostProcessor。</p><p>这个方法主要是讲所有 BeanPostProcessor 的实现类都拿到，并调用 getBean() 方法进行了实例化、初始化，然后将 bean 注册到了 <code>AbstractBeanFactory</code> 的 beanPostProcessors 中，后面具体使用的时候还会根据实现类所实现或继承的某些特殊的接口或类做过滤后使用。</p><h3 id="获取代理实例"><a href="#获取代理实例" class="headerlink" title="获取代理实例"></a>获取代理实例</h3><p>这里直接看 <code>AbstractAutoProxyCreator#wrapIfNecessary()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line"><span class="comment">// 检查 beanName 和缓存</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 bean 对应的增强规则，如果没有，说明不需要增强</span></span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="built_in">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否是spring的基础设施 bean，或者需要直接忽略</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 advisor</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">     <span class="comment">// 创建代理</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line"><span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先是一些前置检查，是否需要代理。</li><li>获取 Advisor。</li><li>创建代理类。</li></ol><h4 id="获取所有-Advisor"><a href="#获取所有-Advisor" class="headerlink" title="获取所有 Advisor"></a>获取所有 Advisor</h4><p>根据当前 bean 的 Class 和 beanName 获取增强的 Advisor。</p><blockquote><p>因为这里执行的 BeanPostProcessor 实例是 AnnotationAwareAspectJAutoProxyCreator，从该类的继承结构看，这里调用的 getAdvicesAndAdvisorsForBean() 方法在 AbstractAdvisorAutoProxyCreator 抽象类中。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是通过 beanClass 和 beanName 获取符合条件的 Advisor 实例，然后就直接返回了。</p><p>这里需要解释一下的是， advisor 这个概念在前面介绍 AOP 概念时是没提到的。advisor 是 Spring 实现 AOP 时用于维护 advice 和 pointcut 的关系而建立的一类接口。</p><blockquote><p>In Spring, an Advisor is an aspect that contains only a single advice object associated with a pointcut expression.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"><span class="comment">// 先获取所有 Advisor</span></span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line"><span class="comment">// 过滤得到可以用在当前bean上的 Advisor</span></span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">extendAdvisors(eligibleAdvisors);</span><br><span class="line"><span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就很简单了，先获取所有 Advisor，然后再过滤得到可以用在当前 bean 上的 Advisor。</p><p>先看获取所有 Advisor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findCandidateAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 通过父类获取直接实现 Advisor 接口的 bean</span></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="built_in">super</span>.findCandidateAdvisors();</span><br><span class="line"><span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.aspectJAdvisorsBuilder != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 构建 Advisor,这里主要是寻找使用 @Aspect 注解的 bean</span></span><br><span class="line">advisors.addAll(<span class="built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Advisor 有两种来源，一种是直接实现 Advisor 接口的 bean 实例，一种是使用 <code>@Aspect</code> 注解的 bean，这里关注使用 <code>@Aspect</code> 注解的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title function_">buildAspectJAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// aspectBeanNames 缓存</span></span><br><span class="line">List&lt;String&gt; aspectNames = <span class="built_in">this</span>.aspectBeanNames;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果未null，则开始加载</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">aspectNames = <span class="built_in">this</span>.aspectBeanNames;</span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">aspectNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 获取所有 bean,所以这里传入的 bean 类型是 Object</span></span><br><span class="line">String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line"><span class="built_in">this</span>.beanFactory, Object.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="comment">// 默认环境下isEligibleBean()基本都是返回true</span></span><br><span class="line"><span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// We must be careful not to instantiate beans eagerly as in this case they</span></span><br><span class="line"><span class="comment">// would be cached by the Spring container but would not have been weaved.</span></span><br><span class="line"><span class="comment">// 通过 beanName 获取 beanClass</span></span><br><span class="line">Class&lt;?&gt; beanType = <span class="built_in">this</span>.beanFactory.getType(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (beanType == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 beanClass 判断是否是 Aspect 实现</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">aspectNames.add(beanName);</span><br><span class="line"><span class="type">AspectMetadata</span> <span class="variable">amd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectMetadata</span>(beanType, beanName);</span><br><span class="line"><span class="comment">// 是否是单例模式</span></span><br><span class="line"><span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line"><span class="comment">// 构建 advisor 实例</span></span><br><span class="line"><span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">BeanFactoryAspectInstanceFactory</span>(<span class="built_in">this</span>.beanFactory, beanName);</span><br><span class="line">List&lt;Advisor&gt; classAdvisors = <span class="built_in">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="comment">// 如果是单例模式 bean，则放入 advisorCache</span></span><br><span class="line"><span class="built_in">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果不是单例 bean，则放入 aspectFactoryCache</span></span><br><span class="line"><span class="built_in">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">&#125;</span><br><span class="line">advisors.addAll(classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Per target or per this.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; is a singleton, but aspect instantiation model is not singleton&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">PrototypeAspectInstanceFactory</span>(<span class="built_in">this</span>.beanFactory, beanName);</span><br><span class="line"><span class="built_in">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">advisors.addAll(<span class="built_in">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// aspectNames 已经缓存过的情况</span></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line"><span class="comment">// 从 advisorsCache 缓存中获取 Advisor</span></span><br><span class="line">List&lt;Advisor&gt; cachedAdvisors = <span class="built_in">this</span>.advisorsCache.get(aspectName);</span><br><span class="line"><span class="keyword">if</span> (cachedAdvisors != <span class="literal">null</span>) &#123;</span><br><span class="line">advisors.addAll(cachedAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果 advisorsCache 中没有，尝试从 aspectFactoryCache 中获取</span></span><br><span class="line"><span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="built_in">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">advisors.addAll(<span class="built_in">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aspectNames 是当前容器中的 Advisor 实例的名称缓存，如果为 null，说明还未加载过，需要加载，如果不为 null，则从缓存中获取，这里关注第一次加载的逻辑，即 aspectNames 为 null 的情况。</p><ol><li>获取所有的 Object 类型的 beanName，基本是获取了所有的 beanName。</li><li>获取 beanName 对应的 beanClass，并判断是否有 <code>@Aspect</code> 注解，如果有，则是符合条件的，要开始构建 Advisor。</li><li>如果 bean 是单例的，构建好的 Advisor 放入 advisorsCache 中进行缓存。</li><li>如果不是单例 bean，构建 Advisor 的 factory 对象放入 aspectFactoryCache 中缓存，这和 Spring 三级缓存的思想有些许相似。</li></ol><h4 id="过滤-Advisor"><a href="#过滤-Advisor" class="headerlink" title="过滤 Advisor"></a>过滤 Advisor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findAdvisorsThatCanApply</span><span class="params">(</span></span><br><span class="line"><span class="params">List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"></span><br><span class="line">ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">ProxyCreationContext.setCurrentProxiedBeanName(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>ThreadLocal 设置当前正在创建代理的 bean。</li><li>获取可以使用的 Advisor 对象。</li><li>清除第一步中在 ThreadLocal 中的标记。</li></ol><blockquote><p>说实，我不明白第 1、3 步有啥用。</p></blockquote><p>这里主要关注第二步的过滤逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title function_">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line"><span class="comment">// candidateAdvisors 为空，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 符合要求的 Advisor</span></span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="comment">// 如果是 IntroductionAdvisor 且可用</span></span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasIntroductions</span> <span class="operator">=</span> !eligibleAdvisors.isEmpty();</span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line"><span class="comment">// already processed</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否可用</span></span><br><span class="line"><span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对是否实现 IntroductionAdvisor 接口的过滤进行了区分，Intrdocution 这个概念在前面 AOP 核心概念章节已经介绍过。</p><p>核心的就是两个 canApply() 方法，两个参数的 canApply() 其实是直接调用的 3 个参数的 canApply() 方法，不过第三个参数直接传了 false，所以我们直接看有 3 个参数的 canApply() 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">canApply</span><span class="params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="type">boolean</span> hasIntroductions)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line"><span class="keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line"><span class="type">PointcutAdvisor</span> <span class="variable">pca</span> <span class="operator">=</span> (PointcutAdvisor) advisor;</span><br><span class="line"><span class="keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It doesn&#x27;t have a pointcut so we assume it applies.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要关注 PointcutAdvisor 类型的检查。这里能看到当 Advisor 是 PointcutAdvisor 类型时，又调用了一个 canApply() 方法进行检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="type">boolean</span> hasIntroductions)</span> &#123;</span><br><span class="line">Assert.notNull(pc, <span class="string">&quot;Pointcut must not be null&quot;</span>);</span><br><span class="line"><span class="comment">// 使用 Pointcut 的 ClassFilter 进行匹配</span></span><br><span class="line"><span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 Pointcut 的 MethodMatcher</span></span><br><span class="line"><span class="type">MethodMatcher</span> <span class="variable">methodMatcher</span> <span class="operator">=</span> pc.getMethodMatcher();</span><br><span class="line"><span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line"><span class="comment">// No need to iterate the methods if we&#x27;re matching any method anyway...</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">IntroductionAwareMethodMatcher</span> <span class="variable">introductionAwareMethodMatcher</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 是否是代理类型</span></span><br><span class="line"><span class="keyword">if</span> (!Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="comment">// 获取到原始的 class 并放入 classes 中</span></span><br><span class="line">classes.add(ClassUtils.getUserClass(targetClass));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取要代理的类的所有接口并添加到 classes 中</span></span><br><span class="line">classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"><span class="comment">// 使用 MethodMatcher 对方法进行匹配</span></span><br><span class="line"><span class="keyword">if</span> (introductionAwareMethodMatcher != <span class="literal">null</span> ?</span><br><span class="line">introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :</span><br><span class="line">methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 Pointcut 提供的 ClassFilter 对 class 进行匹配。</li><li>获取 Pointcut 提供的 MethodMatcher，如果是 IntroductionAwareMethodMatcher 类型，还需要转型一次。</li><li>如果 targetClass 不是代理类，则获取原始的类 Class，放入到 classes 中；</li><li>获取 targetClass 实现的所有接口，放入 classes 中。</li><li>循环 classes，通过 MethodMatcher 对 targetClass 的每个方法进行匹配，如果 MethodMatcher 是 IntroductionAwareMethodMatcher 类型，则使用转型后的 introductionAwareMethodMatcher 调用 IntroductionAwareMethodMatcher 接口的方法进行匹配。</li></ol><p>这里需要注意的是，又出现了 AOP 中的重要接口：</p><ol><li><p>Pointcut</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pointcut</span> &#123;</span><br><span class="line"></span><br><span class="line">ClassFilter <span class="title function_">getClassFilter</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">MethodMatcher <span class="title function_">getMethodMatcher</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Pointcut</span> <span class="variable">TRUE</span> <span class="operator">=</span> TruePointcut.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pointcut 这个概念最开始时已经讲过，Spring 中定义这个接口是为了能够复用 Pointcut，一个 Pointcut 能支持多个 Advice，换言之就是一个 Pointcut 支持实现多个切面。</p><p>Pointcut 内包含了一个 ClassFilter 和一个 MethodMatcher。</p></li><li><p>ClassFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Class clazz)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassFilter 用于匹配指定的类与当前 Pointcut 是否匹配，如果 match() 方法一直返回 true，则所有类都能匹配。</p></li><li><p>MethodMatcher</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodMatcher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method m, Class&lt;?&gt; targetClass)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRuntime</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method m, Class&lt;?&gt; targetClass, Object... args)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>match(Method, Class)</code> 方法用于匹配指定 targetClass 的指定方法是否在当前 Pointcut 上匹配，在创建 AOP 代理时调用此方法进行判断，以避免运行时每次调用被代理方法都执行此方法。</li><li><code>isRuntime</code>，是否是运行时执行。</li><li><code>matches(Method, Class, Objects...)</code>，如果前两个方法都返回 true，则本方法在每次方法调用时都会执行。</li></ul></li></ol><p>到此为止，获取 Advisor 的逻辑结束，接下来就是创建代理对象。</p><h4 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line"><span class="comment">// 将要代理的原始 Class 设置到 BeanDefinition 中，key 为 org.springframework.aop.framework.autoproxy.originalTargetClass</span></span><br><span class="line">AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="built_in">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">proxyFactory.copyFrom(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 proxyTargetClass，配置文件中的 proxy-target-class 的值</span></span><br><span class="line"><span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line"><span class="comment">// 如果想要代理类和被代理类能够直接强转的话，只能使用 Cglib 动态代理</span></span><br><span class="line"><span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line"><span class="comment">// 设置 proxyTargetClass 为 true，则只能通过 Cglib 动态代理</span></span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 通过判断是否有能够用来做 Jdk 动态代理的接口，设置 proxyFactory 中的 interfaces 和 proxyTargetClass</span></span><br><span class="line">evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完善 ProxyFactory</span></span><br><span class="line"><span class="comment">// 获取 Advisor，这里 specificInterceptors 本身其实就是一个 Advisor 数组</span></span><br><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">proxyFactory.addAdvisors(advisors);</span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">proxyFactory.setFrozen(<span class="built_in">this</span>.freezeProxy);</span><br><span class="line"><span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">proxyFactory.setPreFiltered(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use original ClassLoader if bean class not locally loaded in overriding class loader</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getProxyClassLoader();</span><br><span class="line"><span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp; classLoader != beanClass.getClassLoader()) &#123;</span><br><span class="line">classLoader = ((SmartClassLoader) classLoader).getOriginalClassLoader();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建代理类</span></span><br><span class="line"><span class="keyword">return</span> proxyFactory.getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果 beanFactory 是 ConfigurableListableBeanFactory 类型，将原始的被代理的 Class 缓存到 BeanDefinition 中，key 为 <code>org.springframework.aop.framework.autoproxy.originalTargetClass</code>。</li><li>创建 ProxyFactory。</li><li>重写 proxyTargetClass 属性。</li><li>重新获取 Advisor 并完善 ProxyFactory。</li><li>创建代理类。</li></ol><p>最后一步到底是如何创建的，本文就不再深究了，因为即将涉及到字节码织入的只是，目前没必要了解这么深。</p><p>这一节主要关注第 3 步中对 proxyTargetClass 的处理，也就是下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line"><span class="comment">// 如果想要代理类和被代理类能够直接强转的话，只能使用 Cglib 动态代理</span></span><br><span class="line"><span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line"><span class="comment">// 设置 proxyTargetClass 为 true，则只能通过 Cglib 动态代理</span></span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 通过判断是否有能够用来做 Jdk 动态代理的接口，设置 proxyFactory 中的 interfaces 和 proxyTargetClass</span></span><br><span class="line">evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是 proxyTargetClass 属性，在本文最开始的时候提过，这个属性如果设置成 true，那就会强制使用 Cglib 动态代理，上面这段逻辑就不会走了。</p><p>如果 proxyTargetClass 设置为 false，就有可能会使用 Jdk 动态代理，但是 Jdk 动态代理也有一定的局限性，必须要求被代理类有实现某个接口才行，具体可参考<a href="/posts/b8f5ebf685e8">静态代理和动态代理</a>，所以这种情况还需要判断一次到底要使用哪种动态代理方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldProxyTargetClass</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory &amp;&amp;</span><br><span class="line">AutoProxyUtils.shouldProxyTargetClass((ConfigurableListableBeanFactory) <span class="built_in">this</span>.beanFactory, beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求 beanFactory 是 ConfigurableListableBeanFactory 类型，且 AutoProxyUtils.shouldProxyTargetClass() 方法返回 true，这个方法最主要是其实就是看 BeanDefinition 中是否要求被代理类是否能和代理类强转，如果要求能强转的话，就不能使用 Jdk 动态代理，只能使用 Cglib 动态代理，所以如果 shouldProxyTargetClass() 返回 true 的话，proxyFactory 的 proxyTargetClass 属性就会设置为 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">evaluateProxyInterfaces</span><span class="params">(Class&lt;?&gt; beanClass, ProxyFactory proxyFactory)</span> &#123;</span><br><span class="line">Class&lt;?&gt;[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, getProxyClassLoader());</span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasReasonableProxyInterface</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; ifc : targetInterfaces) &#123;</span><br><span class="line"><span class="comment">// 不能是配置回调类接口、不能是其他jvm语言的接口，且接口数量大于 0</span></span><br><span class="line"><span class="keyword">if</span> (!isConfigurationCallbackInterface(ifc) &amp;&amp; !isInternalLanguageInterface(ifc) &amp;&amp;</span><br><span class="line">ifc.getMethods().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">hasReasonableProxyInterface = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hasReasonableProxyInterface) &#123;</span><br><span class="line"><span class="comment">// Must allow for introductions; can&#x27;t just set interfaces to the target&#x27;s interfaces only.</span></span><br><span class="line"><span class="comment">// 设置代理类要实现的接口列表（Jdk 动态代理是通过实现和被代理类相同的接口做的）</span></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; ifc : targetInterfaces) &#123;</span><br><span class="line">proxyFactory.addInterface(ifc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果 hasReasonableProxyInterface 为 false 说明没有可以提供给 Jdk 动态代理用的接口，</span></span><br><span class="line"><span class="comment">// 只能将 proxyTargetClass 设置为 true，强制使用 Cglib 创建代理</span></span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>获取被代理类实现的所有接口</p></li><li><p>如果接口数大于 0 这些接口需要符合以下 2 个条件</p><ul><li><p>不能是 Spring 中的配置回调类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isConfigurationCallbackInterface</span><span class="params">(Class&lt;?&gt; ifc)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (InitializingBean.class == ifc || DisposableBean.class == ifc || Closeable.class == ifc ||</span><br><span class="line">AutoCloseable.class == ifc || ObjectUtils.containsElement(ifc.getInterfaces(), Aware.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不能是其他 JVM 语言定义的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isInternalLanguageInterface</span><span class="params">(Class&lt;?&gt; ifc)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (ifc.getName().equals(<span class="string">&quot;groovy.lang.GroovyObject&quot;</span>) ||</span><br><span class="line">ifc.getName().endsWith(<span class="string">&quot;.cglib.proxy.Factory&quot;</span>) ||</span><br><span class="line">ifc.getName().endsWith(<span class="string">&quot;.bytebuddy.MockAccess&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口方法数量大于 0</p></li></ul></li><li><p>如果第二步中进行过滤后，还有剩余的接口，那么这些接口就可以用来作为 Jdk 动态代理的接口，调用 proxyFactory.addInterface() 方法进行记录，创建代理类时使用。</p></li><li><p>如果第 2 步过后，一个接口都没剩下，那就只能使用 Cglib 做动态代理，将 proxyTargetClass 属性设置为 true。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>Spring AOP 通过 AspectJ 实现， 如果要强制使用 Cglib 进行动态代理，则需要将 proxyTargetClass 设置为 true，但也存在不能代理 final 修饰的方法的问题。</li><li>Spring 中启用 AOP，要么通过 xml 配置，要么通过 @EnableAspectJAutoProxy 注解开启，不管哪种，最后的核心都是会注册 AnnotationAwareAspectJAutoProxyCreator 这个 bean。</li><li>因为 AnnotationAwareAspectJAutoProxyCreator 实现了 BeanPostProcessor 接口，所以是在创建时注册到 BeanFactory 的 beanPostProcessors 中，但是并不是和其他的业务 bean 一起初始化的，加载顺序上，是先加载了 BeanPostProcessor 的 bean，同时注册，然后再创建其他自定义的业务 bean。</li><li>Pointcut 接口是为了复用的连接点，能在一个连接点上关联多个 Advice。</li><li>Advisor 是 Spring 为了维护 Advice 和 Pointcut 的关联关系而创建的接口。</li><li>Jdk 动态代理依赖接口实现，如果被代理类没有合适的接口，就不能使用 Jdk 动态代理，只能使用 Cglib 动态代理。</li><li>因为 proxyTargetClass 默认是 false，所以 Spring AOP 默认使用的是 Jdk 动态代理。</li></ol><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop">Aspect Oriented Programming with Spring</a></p></li><li><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-api">Spring AOP APIs</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码解析：Bean加载（四）</title>
      <link href="posts/aa5df6d65c56.html"/>
      <url>posts/aa5df6d65c56.html</url>
      
        <content type="html"><![CDATA[<p>在前面几篇博文中，已经详细介绍了 bean 的实例化。在实例化完成后，bean 并没有真正的完全可用，此时还需要进行一些必要的依赖属性填充。</p><p>换言之，只是通过构造函数将 bean 实例构建出来了，但是里面一些并未通过构造函数进行初始化的属性，还需要单独再填充一次。</p><p>填充属性的在<a href="/posts/54dce9e15d4c#doCreateBean-%E6%96%B9%E6%B3%95">Spring源码解析：Bean加载（二）</a>中就已经提到过，位于 doCreateBean() 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bw == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果 BeanDefinition 中判定是有属性值的，但是 BeanWrapper 为 null，直接抛异常</span></span><br><span class="line"><span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 不需要进行属性填充，直接return</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InstantiationAwareBeanPostProcessors 用于提供在 bean 的属性设置前修改 bean，比如用来支持自定义的属性注入。</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line"><span class="keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line"><span class="comment">// 如果后处理器一旦有一个返回 false, 就不填充属性值</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取自动注入类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">resolvedAutowireMode</span> <span class="operator">=</span> mbd.getResolvedAutowireMode();</span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line"><span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line"><span class="comment">// 按 beanName 注入</span></span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line"><span class="comment">// 按照 bean 的类型注入</span></span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">PropertyDescriptor[] filteredPds = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">pvs = mbd.getPropertyValues();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line"><span class="type">PropertyValues</span> <span class="variable">pvsToUse</span> <span class="operator">=</span> bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后处理</span></span><br><span class="line">pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pvs = pvsToUse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依赖检查</span></span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pvs != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 2. 将属性应用到 bean 中, 前面只是找到了每一个依赖的 bean 而已</span></span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里核心逻辑主要有 2 个点：</p><ol><li>获取注入类型，根据自动注入类型，解析注入的 bean。</li><li>将上一步对应的解析值，设置到 bean 中，对应 <code>applyPropertyValues()</code> 方法。</li></ol><h2 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取自动注入类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">resolvedAutowireMode</span> <span class="operator">=</span> mbd.getResolvedAutowireMode();</span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line"><span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line"><span class="comment">// 按 beanName 注入</span></span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line"><span class="comment">// 按照 bean 的类型注入</span></span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入类型从 <code>AbstractBeanDefinition#getResolvedAutowireMode()</code> 中得到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getResolvedAutowireMode</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.autowireMode == AUTOWIRE_AUTODETECT) &#123;</span><br><span class="line"><span class="comment">// 如果自动注入类型是 autodetect, 就根据构造函数判断最终的注入类型</span></span><br><span class="line">Constructor&lt;?&gt;[] constructors = getBeanClass().getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line"><span class="keyword">if</span> (constructor.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// parameterCount==0说明有无参构造，直接返回通过 type注入</span></span><br><span class="line"><span class="keyword">return</span> AUTOWIRE_BY_TYPE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过构造函数注入</span></span><br><span class="line"><span class="keyword">return</span> AUTOWIRE_CONSTRUCTOR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 就以当前值返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.autowireMode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据注入类型的不同，又调用了 <code>#autowireByName</code>、<code>#autowireByType</code> 方法。</p><h3 id="autowireByName"><a href="#autowireByName" class="headerlink" title="autowireByName"></a>autowireByName</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">autowireByName</span><span class="params">(</span></span><br><span class="line"><span class="params">String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> &#123;</span><br><span class="line"><span class="comment">//寻找非简单类型的需要注入的属性，像基础类型和Date就数据简单类型</span></span><br><span class="line">String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line"><span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line"><span class="comment">// 因为是按照名称注入，所以这里直接将属性名称作为beanName进行搜索</span></span><br><span class="line"><span class="keyword">if</span> (containsBean(propertyName)) &#123;</span><br><span class="line"><span class="comment">// 递归初始化相关 bean</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(propertyName);</span><br><span class="line">pvs.add(propertyName, bean);</span><br><span class="line"><span class="comment">// 注册 bean 依赖关系</span></span><br><span class="line">registerDependentBean(propertyName, beanName);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Added autowiring by name from bean name &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; via property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Not autowiring property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; of bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; by name: no matching bean found&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这里首先通过<code>#unsatisfiedNonSimpleProperties()</code> 方法剔除了一些简单类型的字段，其实就是一些 Java 的基础类型和 Date 类型；</li><li>然后就判断属性名对应的 bean 是否存在，存在就通过 <code>#getBean()</code> 方法获取 bean 实例，这里如果依赖的 bean 还没创建，则会开始创建依赖的 bean；</li><li>注册 bean 的依赖关系，其实就是容器维护了一个 map 用于记录各个 bean 之间的依赖关系。</li></ol><h3 id="autowireByType"><a href="#autowireByType" class="headerlink" title="autowireByType"></a>autowireByType</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">autowireByType</span><span class="params">(</span></span><br><span class="line"><span class="params">String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getCustomTypeConverter();</span><br><span class="line"><span class="keyword">if</span> (converter == <span class="literal">null</span>) &#123;</span><br><span class="line">converter = bw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 1. 获取非简单属性</span></span><br><span class="line">String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line"><span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 2. 寻找需要注入的属性</span></span><br><span class="line"><span class="type">PropertyDescriptor</span> <span class="variable">pd</span> <span class="operator">=</span> bw.getPropertyDescriptor(propertyName);</span><br><span class="line"><span class="comment">// Don&#x27;t try autowiring by type for type Object: never makes sense,</span></span><br><span class="line"><span class="comment">// even if it technically is a unsatisfied, non-simple property.</span></span><br><span class="line"><span class="keyword">if</span> (Object.class != pd.getPropertyType()) &#123;</span><br><span class="line"><span class="comment">// 获取写入属性值的方法</span></span><br><span class="line"><span class="type">MethodParameter</span> <span class="variable">methodParam</span> <span class="operator">=</span> BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line"><span class="comment">// Do not allow eager init for type matching in case of a prioritized post-processor.</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">eager</span> <span class="operator">=</span> !(bw.getWrappedInstance() <span class="keyword">instanceof</span> PriorityOrdered);</span><br><span class="line"><span class="type">DependencyDescriptor</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowireByTypeDependencyDescriptor</span>(methodParam, eager);</span><br><span class="line"><span class="comment">// 3. 解析指定 beanName 的属性匹配的值并存放在 autowiredBeanNames 中</span></span><br><span class="line"><span class="comment">// 如果注入的是一个 list，将会找到所有匹配的类型注入</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">autowiredArgument</span> <span class="operator">=</span> resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line"><span class="keyword">if</span> (autowiredArgument != <span class="literal">null</span>) &#123;</span><br><span class="line">pvs.add(propertyName, autowiredArgument);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line"><span class="comment">// 4. 注册依赖关系</span></span><br><span class="line">registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Autowiring by type from bean name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; via property &#x27;&quot;</span> +</span><br><span class="line">propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + autowiredBeanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">autowiredBeanNames.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedDependencyException</span>(mbd.getResourceDescription(), beanName, propertyName, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过 <code>#unsatisfiedNonSimpleProperties()</code> 方法获取非简单属性，然后开始遍历得到的每一个属性。</li><li>根据属性名得到相应的 PropertyDescriptor。PropertyDescriptor 是 JDK 中定义的类，持有一个属性的 read、write 方法引用。</li><li><code>#resolveDependency()</code> 方法解析依赖。</li><li>注册依赖关系。</li></ol><p>下面再深入看看 <code>#resolveDependency()</code> 方法。</p><h4 id="resolveDependency"><a href="#resolveDependency" class="headerlink" title="resolveDependency"></a>resolveDependency</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String requestingBeanName,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="comment">// 初始化参数名称发现</span></span><br><span class="line">descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line"><span class="comment">// 对注入 Optional 类型处理</span></span><br><span class="line"><span class="keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;</span><br><span class="line"><span class="keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ObjectFactory 注入类型处理</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||</span><br><span class="line">ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DependencyObjectProvider</span>(descriptor, requestingBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// javaxInjectProviderClass 类型处理</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jsr330Factory</span>().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 普通的 bean 注入处理，构建惰性加载的代理</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(</span><br><span class="line">descriptor, requestingBeanName);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 通用处理逻辑</span></span><br><span class="line">result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是对普通 bean 的注入和一些特殊类型的 bean 的注入分开进行处理，但主要关注 <code>#doResolveDependency()</code> 方法对普通注入的解析。</p><p>同时需要注意的是，对于普通注入的处理，如果注入时选择了延迟加载，则需要在这里以代理的方式对延迟加载进行支持，如果不是延迟加载，则会调用 <code>#doResolveDependency()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="comment">// 设置注入点</span></span><br><span class="line"><span class="type">InjectionPoint</span> <span class="variable">previousInjectionPoint</span> <span class="operator">=</span> ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 针对给定工厂解决此依赖关系的快捷方式</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">shortcut</span> <span class="operator">=</span> descriptor.resolveShortcut(<span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">if</span> (shortcut != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> shortcut;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依赖 bean 类型</span></span><br><span class="line">Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line"><span class="comment">// 处理 @Value 注解</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line"><span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">strVal</span> <span class="operator">=</span> resolveEmbeddedValue((String) value);</span><br><span class="line"><span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> (beanName != <span class="literal">null</span> &amp;&amp; containsBean(beanName) ?</span><br><span class="line">getMergedBeanDefinition(beanName) : <span class="literal">null</span>);</span><br><span class="line">value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> (typeConverter != <span class="literal">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnsupportedOperationException ex) &#123;</span><br><span class="line"><span class="comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span></span><br><span class="line"><span class="keyword">return</span> (descriptor.getField() != <span class="literal">null</span> ?</span><br><span class="line">converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理多种类型的 bean，这里主要处理 Stream、Array、Collection、Map 这几种类型的依赖注入</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">multipleBeans</span> <span class="operator">=</span> resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line"><span class="keyword">if</span> (multipleBeans != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> multipleBeans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 到这里基本可以确定这里要注入的 bean 只有一个</span></span><br><span class="line">Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line"><span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 最终如果没有找到依赖的 bean, 并且 @Autowired 上的 required 是 true, 就抛异常</span></span><br><span class="line"><span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String autowiredBeanName;</span><br><span class="line">Object instanceCandidate;</span><br><span class="line"><span class="comment">// 如果匹配到了多个 bean</span></span><br><span class="line"><span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line"><span class="comment">// 有多个 bean，但是通过 @Primary、@Priority、fieldName 都没有找到</span></span><br><span class="line"><span class="keyword">if</span> (autowiredBeanName == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 但是 @Autowired 的 required 属性为 true，且注入的类型不是多个 bean 一起注入，</span></span><br><span class="line"><span class="comment">// 抛异常，找到了多个 bean, 但是一个都没匹配上</span></span><br><span class="line"><span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line"><span class="keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不是多个 bean 一起注入，并且 @Autowired 的 required 属性为 false，就返回 null</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line"><span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line"><span class="comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 恰好只匹配上了一个 bean</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// We have exactly one match.</span></span><br><span class="line">Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">autowiredBeanName = entry.getKey();</span><br><span class="line">instanceCandidate = entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (autowiredBeanNames != <span class="literal">null</span>) &#123;</span><br><span class="line">autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceCandidate <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line"><span class="comment">// 如果拿到的是依赖的类型的 Class，从 beanFactory 中获取实例</span></span><br><span class="line">instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> instanceCandidate;</span><br><span class="line"><span class="keyword">if</span> (result <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line"><span class="comment">// 处理每找到 bean 的情况</span></span><br><span class="line"><span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断拿到的 bean 实例和实际依赖的类型是否匹配，不匹配则抛异常</span></span><br><span class="line"><span class="keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(autowiredBeanName, type, instanceCandidate.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的注释已经很详细，就不再赘述了。</p><p>到这里，注入 bean 的解析就基本完结了，接下来看看 <code>#applyPropertyValues()</code> 方法对属性值的设置。</p><h2 id="applyPropertyValues-方法"><a href="#applyPropertyValues-方法" class="headerlink" title="applyPropertyValues() 方法"></a>applyPropertyValues() 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (pvs.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MutablePropertyValues</span> <span class="variable">mpvs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">mpvs = (MutablePropertyValues) pvs;</span><br><span class="line"><span class="comment">// 如果已经转换为对应类型，直接设置进 beanWrapper 中即可</span></span><br><span class="line"><span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line"><span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 真正将属性值设置到 bean 实例中</span></span><br><span class="line">bw.setPropertyValues(mpvs);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">original = mpvs.getPropertyValueList();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果不是 MutablePropertyValues 封装类型，直接使用原始属性值列表</span></span><br><span class="line">original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型转换器</span></span><br><span class="line"><span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getCustomTypeConverter();</span><br><span class="line"><span class="keyword">if</span> (converter == <span class="literal">null</span>) &#123;</span><br><span class="line">converter = bw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">BeanDefinitionValueResolver</span> <span class="variable">valueResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionValueResolver</span>(<span class="built_in">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(original.size());</span><br><span class="line"><span class="type">boolean</span> <span class="variable">resolveNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 转换成对应类型</span></span><br><span class="line"><span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line"><span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line"><span class="comment">// 如果已经做了类型转换，则直接添加到 deepCopy</span></span><br><span class="line">deepCopy.add(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 属性名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> pv.getName();</span><br><span class="line"><span class="comment">// 原始值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">originalValue</span> <span class="operator">=</span> pv.getValue();</span><br><span class="line"><span class="comment">// AutowiredPropertyMarker.INSTANCE 表示这个属性是需要注入的属性</span></span><br><span class="line"><span class="keyword">if</span> (originalValue == AutowiredPropertyMarker.INSTANCE) &#123;</span><br><span class="line"><span class="type">Method</span> <span class="variable">writeMethod</span> <span class="operator">=</span> bw.getPropertyDescriptor(propertyName).getWriteMethod();</span><br><span class="line"><span class="keyword">if</span> (writeMethod == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Autowire marker for property without write method: &quot;</span> + pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 originalValue 重新赋值为 DependencyDescriptor</span></span><br><span class="line">originalValue = <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(writeMethod, <span class="number">0</span>), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到 bean 实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">resolvedValue</span> <span class="operator">=</span> valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line"><span class="comment">// convertedValue 记录转换后的值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">convertedValue</span> <span class="operator">=</span> resolvedValue;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">convertible</span> <span class="operator">=</span> bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line"><span class="comment">// 使用自定义类型转换器进行转换</span></span><br><span class="line"><span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Possibly store converted value in merged bean definition,</span></span><br><span class="line"><span class="comment">// in order to avoid re-conversion for every created bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line"><span class="comment">// 缓存转换后的值，避免每次注入都要重新做一次转换</span></span><br><span class="line"><span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">pv.setConvertedValue(convertedValue);</span><br><span class="line">&#125;</span><br><span class="line">deepCopy.add(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (convertible <span class="comment">// 可转换的</span></span><br><span class="line">&amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue <span class="comment">// 值类型是字符串</span></span><br><span class="line">&amp;&amp; !((TypedStringValue) originalValue).isDynamic() <span class="comment">// 不是动态生成的字符串</span></span><br><span class="line">&amp;&amp; !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123; <span class="comment">// 不是Collection或者数组</span></span><br><span class="line">pv.setConvertedValue(convertedValue);</span><br><span class="line">deepCopy.add(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">resolveNecessary = <span class="literal">true</span>;</span><br><span class="line">deepCopy.add(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(pv, convertedValue));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mpvs != <span class="literal">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">mpvs.setConverted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set our (possibly massaged) deep copy.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 设置属性值</span></span><br><span class="line">bw.setPropertyValues(<span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(deepCopy));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总而言之，这里就是对不需要转换的值，直接注入到 bean 中，对需要转换的则先转换过后，注入到 bean 中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在填充属性时：</p><ol><li>解析属性值，会初始化依赖的 bean。</li><li>如果属性值需要转换，则会转换后进行注入，如果有自定义的类型转换器就使用自定义，否则直接使用 BeanWrapper 作为类型转换器。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码解析：Bean加载（三）</title>
      <link href="posts/6ef71fd715cb.html"/>
      <url>posts/6ef71fd715cb.html</url>
      
        <content type="html"><![CDATA[<p>在 <a href="/posts/54dce9e15d4c">Spring 源码解析：Bean 加载（二）</a> 中梳理了 createBean() 方法的主流程，本文则是其中创建实例部分的详解。</p><h2 id="BeanWrapper"><a href="#BeanWrapper" class="headerlink" title="BeanWrapper"></a>BeanWrapper</h2><p>看完上一篇博文后，可以明确的是，createBean() 方法直接拿到的不是 bean 实例，而是一个 BeanWrapper 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 创建 bean 实例</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先从 factoryBeanInstanceCache 中通过 beanName 获取对象实例，如果结果为 null，则说明未创建过，就调用 <code>#createBeanInstance()</code> 创建实例。</p><p>BeanWrapper 接口是有 BeanWrapperImpl 一个实现类，它持有最后创建的 bean 实例的引用，除此之外，还提供了操作 bean 实例的一些能力。</p><blockquote><p>Provides operations to analyze and manipulate standard JavaBeans: the ability to get and set property values (individually or in bulk), get property descriptors, and query the readability/writability of properties.</p><p>提供分析和操作标准 JavaBeans 的操作：获取和设置属性值（单独或批量）、获取属性描述符以及查询属性的可读性可写性的能力。</p><p>—- 摘自 Spring 源码 BeanWrapper 接口描述</p></blockquote><h2 id="createBeanInstance"><a href="#createBeanInstance" class="headerlink" title="createBeanInstance()"></a>createBeanInstance()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> &#123;</span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line"><span class="comment">// 1. 获取 bean class</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果类不是 public，且 BeanDefinition 不允许访问非 public 的构造方法，则直接报错</span></span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 尝试从 InstanceSupplier 中获取 bean</span></span><br><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line"><span class="keyword">if</span> (instanceSupplier != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 如果配置了工厂方法，就以工厂方法初始化</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">resolved</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">autowireNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果有多个构造函数，需要根据参数锁定构造函数或者对应工厂方法</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="comment">// 这里如果 resolvedConstructorOrFactoryMethod 不为 null，</span></span><br><span class="line"><span class="comment">// 说明是重复创建 bean，就能直接知道要使用的构造函数是哪一个</span></span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">resolved = <span class="literal">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 如果已经解析过，使用解析好的构造函数</span></span><br><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="comment">// 是否需要构造器注入</span></span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="comment">// 构造器注入方式初始化</span></span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 使用默认构造器初始化</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 到这里就需要开始决策使用哪一个构造函数进行初始化</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="literal">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line"><span class="comment">// 构造器注入</span></span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line"><span class="comment">// 7. 如果有优先使用的构造函数配置，则使用该构造函数</span></span><br><span class="line">ctors = mbd.getPreferredConstructors();</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 使用默认构造器初始化，无参构造</span></span><br><span class="line"><span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取 bean class。</li><li>如果类不是 public，且 BeanDefinition 不允许访问非 public 的构造方法，则直接报错。</li><li>如果 BeanDefinition 中有提供 Supplier，则调用 <code>Supplier#get()</code> 方法获取 bean 实例。</li><li>如果 BeanDefinition 的 factoryMethodName 不为空，说明是通过工厂创建的 bean，调用 <code>#instantiateUsingFactoryMethod（）</code> 方法进行 bean 的创建。</li><li>第 5 步其实是对 bean 重复创建的场景的优化（比如 prototype 类型的 bean），第一次创建后，使用的构造方式、参数解析结果等都记录在了 BeanDefinition 中，第二次创建时可以直接使用，不用再重新解析。</li><li>到了第六步说明只能使用构造函数进行创建，但是可能会有多个构造函数，这里需要通过 BeanPostProcessor 决定能使用的构造函数有哪些，如果最后得到的构造函数不为空，则调用 <code>#autowireConstructor()</code> 方法进行创建，并进行构造器注入。</li><li>上一步未能得到能使用的构造函数，则判断 BeanDefinition 中是否指定了优先使用的构造函数，如果有，则使用该构造函数进行 bean 创建及构造器注入。</li><li>最后的兜底操作，使用默认构造无参构造 <code>#instantiateBean()</code> 进行创建。</li></ol><h2 id="Supplier-接口"><a href="#Supplier-接口" class="headerlink" title="Supplier 接口"></a>Supplier 接口</h2><p>Supplier 接口不是 Spring 定义的接口，而是 JDK 8 中定义的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Supplier 接口只有一个 <code>#get()</code> 接口，也没有入参。</p><p><code>@FunctionalInterface</code> 注解是函数式接口才会有的注解，有该注解时，会检查接口是否只有一个方法，但该注解并不是必须的。</p><p>很少看见有这种创建方式，不深究，主要知道 Supplier 接口怎么用就好。</p><h2 id="Bean-工厂"><a href="#Bean-工厂" class="headerlink" title="Bean 工厂"></a>Bean 工厂</h2><p>通过工厂方法创建 bean 的入口是 <code>#instantiateUsingFactoryMethod()</code> 方法，但是该方法内部也是调用了 <code>ConstructorResolver#instantiateUsingFactoryMethod()</code> 方法进行工厂方法的解析及 bean 创建。</p><blockquote><p><strong>前方高能预警</strong></p><p>下面 <code>#instantiateUsingFactoryMethod()</code> 方法的加注释快接近 300 行了，所以看起来比较吃力，主要知道它逻辑的主方向即可。</p><p>说实话这种大方法，在 Spring 里面太少见了，看吐了没，其实现在依然是没能理解透，但是也必要非的纠结如此细节的东西。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanWrapper <span class="title function_">instantiateUsingFactoryMethod</span><span class="params">(</span></span><br><span class="line"><span class="params">String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">BeanWrapperImpl</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>();</span><br><span class="line"><span class="built_in">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">Object factoryBean;</span><br><span class="line">Class&lt;?&gt; factoryClass;</span><br><span class="line"><span class="type">boolean</span> isStatic;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取工厂 bean 的 beanName</span></span><br><span class="line"><span class="type">String</span> <span class="variable">factoryBeanName</span> <span class="operator">=</span> mbd.getFactoryBeanName();</span><br><span class="line"><span class="keyword">if</span> (factoryBeanName != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (factoryBeanName.equals(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;factory-bean reference points back to the same bean definition&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取工厂 bean</span></span><br><span class="line">factoryBean = <span class="built_in">this</span>.beanFactory.getBean(factoryBeanName);</span><br><span class="line"><span class="comment">// 如果要创建的 bean 是单例的，但是 singletonObjects 中已经存在该 bean，就直接报错</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ImplicitlyAppearedSingletonException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册bean依赖关系</span></span><br><span class="line"><span class="built_in">this</span>.beanFactory.registerDependentBean(factoryBeanName, beanName);</span><br><span class="line">factoryClass = factoryBean.getClass();</span><br><span class="line">isStatic = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It&#x27;s a static factory method on the bean class.</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.hasBeanClass()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;bean definition declares neither a bean class nor a factory-bean reference&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态工厂，需要提供工厂类的全类名</span></span><br><span class="line">factoryBean = <span class="literal">null</span>;</span><br><span class="line">factoryClass = mbd.getBeanClass();</span><br><span class="line">isStatic = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法的 Method 引用</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">factoryMethodToUse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">ArgumentsHolder</span> <span class="variable">argsHolderToUse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 方法参数</span></span><br><span class="line">Object[] argsToUse = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法参数，最初getBean()时传的，不为空的话，可以以此确定具体的工厂方法</span></span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">argsToUse = explicitArgs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Object[] argsToResolve = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 从缓存中获取工厂方法的引用及参数</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="keyword">if</span> (factoryMethodToUse != <span class="literal">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line"><span class="comment">// Found a cached factory method...</span></span><br><span class="line">argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line"><span class="keyword">if</span> (argsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (argsToResolve != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 参数类型转换，比如：配置文件写的字面值是字符串，但实际上可能需要转换成int</span></span><br><span class="line">argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (factoryMethodToUse == <span class="literal">null</span> || argsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Need to determine the factory method...</span></span><br><span class="line"><span class="comment">// Try all methods with this name to see if they match the given arguments.</span></span><br><span class="line">factoryClass = ClassUtils.getUserClass(factoryClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从工厂类中拿到的工厂方法</span></span><br><span class="line">List&lt;Method&gt; candidates = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 工厂方法是否唯一</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isFactoryMethodUnique) &#123;</span><br><span class="line"><span class="keyword">if</span> (factoryMethodToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">factoryMethodToUse = mbd.getResolvedFactoryMethod();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (factoryMethodToUse != <span class="literal">null</span>) &#123;</span><br><span class="line">candidates = Collections.singletonList(factoryMethodToUse);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (candidates == <span class="literal">null</span>) &#123;</span><br><span class="line">candidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 通过反射获取工厂类中的方法：如果允许访问私有方法则获取所有方法，否则只获取public的方法</span></span><br><span class="line">Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);</span><br><span class="line"><span class="keyword">for</span> (Method candidate : rawCandidates) &#123;</span><br><span class="line"><span class="keyword">if</span> (Modifier.isStatic(candidate.getModifiers()) == isStatic &amp;&amp; mbd.isFactoryMethod(candidate)) &#123;</span><br><span class="line">candidates.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到的工厂方法只有一个，且参数为空，且BeanDefinition中定义的工厂方法也没有参数</span></span><br><span class="line"><span class="comment">// 就能确定具体的工厂方法</span></span><br><span class="line"><span class="keyword">if</span> (candidates.size() == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="literal">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line"><span class="type">Method</span> <span class="variable">uniqueCandidate</span> <span class="operator">=</span> candidates.get(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">mbd.factoryMethodToIntrospect = uniqueCandidate;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">mbd.constructorArgumentsResolved = <span class="literal">true</span>;</span><br><span class="line">mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line">bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取的工厂方法个数不唯一，先进行排序</span></span><br><span class="line"><span class="keyword">if</span> (candidates.size() &gt; <span class="number">1</span>) &#123;  <span class="comment">// explicitly skip immutable singletonList</span></span><br><span class="line">candidates.sort(AutowireUtils.EXECUTABLE_COMPARATOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ConstructorArgumentValues</span> <span class="variable">resolvedValues</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">autowiring</span> <span class="operator">=</span> (mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line"><span class="type">int</span> <span class="variable">minTypeDiffWeight</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">Set&lt;Method&gt; ambiguousFactoryMethods = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构架bean所需要的参数个数</span></span><br><span class="line"><span class="type">int</span> minNrOfArgs;</span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">minNrOfArgs = explicitArgs.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// We don&#x27;t have arguments passed in programmatically, so we need to resolve the</span></span><br><span class="line"><span class="comment">// arguments specified in the constructor arguments held in the bean definition.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line"><span class="comment">// 从 BeanDefinition 中取</span></span><br><span class="line"><span class="type">ConstructorArgumentValues</span> <span class="variable">cargs</span> <span class="operator">=</span> mbd.getConstructorArgumentValues();</span><br><span class="line">resolvedValues = <span class="keyword">new</span> <span class="title class_">ConstructorArgumentValues</span>();</span><br><span class="line">minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">minNrOfArgs = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Deque&lt;UnsatisfiedDependencyException&gt; causes = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始循环前面得到的方法列表</span></span><br><span class="line"><span class="keyword">for</span> (Method candidate : candidates) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">parameterCount</span> <span class="operator">=</span> candidate.getParameterCount();</span><br><span class="line"><span class="comment">// 如果方法参数数量小于minNrOfArgs，则直接跳过</span></span><br><span class="line"><span class="keyword">if</span> (parameterCount &gt;= minNrOfArgs) &#123;</span><br><span class="line">ArgumentsHolder argsHolder;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span><br><span class="line"><span class="comment">// 如果 explicitArgs 参数不为null,则工厂方法的参数个数必须和explicitArgs一致，否则直接跳过</span></span><br><span class="line"><span class="comment">// spring启动时，调用getBean()一般传的null</span></span><br><span class="line"><span class="keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">argsHolder = <span class="keyword">new</span> <span class="title class_">ArgumentsHolder</span>(explicitArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Resolved constructor arguments: type conversion and/or autowiring necessary.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String[] paramNames = <span class="literal">null</span>;</span><br><span class="line"><span class="type">ParameterNameDiscoverer</span> <span class="variable">pnd</span> <span class="operator">=</span> <span class="built_in">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line"><span class="keyword">if</span> (pnd != <span class="literal">null</span>) &#123;</span><br><span class="line">paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建方法参数数组</span></span><br><span class="line">argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw,</span><br><span class="line">paramTypes, paramNames, candidate, autowiring, candidates.size() == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Ignoring factory method [&quot;</span> + candidate + <span class="string">&quot;] of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Swallow and try next overloaded factory method.</span></span><br><span class="line"><span class="keyword">if</span> (causes == <span class="literal">null</span>) &#123;</span><br><span class="line">causes = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">causes.add(ex);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数类型的差异权重</span></span><br><span class="line"><span class="comment">// isLenientConstructorResolution 表示是否按宽松模式解析构造函数，默认为true</span></span><br><span class="line"><span class="type">int</span> <span class="variable">typeDiffWeight</span> <span class="operator">=</span> (mbd.isLenientConstructorResolution() ?</span><br><span class="line">argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line"><span class="comment">// Choose this factory method if it represents the closest match.</span></span><br><span class="line"><span class="comment">// 获取差异权重最小的工厂方法</span></span><br><span class="line"><span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">factoryMethodToUse = candidate;</span><br><span class="line">argsHolderToUse = argsHolder;</span><br><span class="line">argsToUse = argsHolder.arguments;</span><br><span class="line">minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">ambiguousFactoryMethods = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Find out about ambiguity: In case of the same type difference weight</span></span><br><span class="line"><span class="comment">// for methods with the same number of parameters, collect such candidates</span></span><br><span class="line"><span class="comment">// and eventually raise an ambiguity exception.</span></span><br><span class="line"><span class="comment">// However, only perform that check in non-lenient constructor resolution mode,</span></span><br><span class="line"><span class="comment">// and explicitly ignore overridden methods (with the same parameter signature).</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (factoryMethodToUse != <span class="literal">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp;</span><br><span class="line">!mbd.isLenientConstructorResolution() &amp;&amp;</span><br><span class="line">paramTypes.length == factoryMethodToUse.getParameterCount() &amp;&amp;</span><br><span class="line">!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) &#123;</span><br><span class="line"><span class="keyword">if</span> (ambiguousFactoryMethods == <span class="literal">null</span>) &#123;</span><br><span class="line">ambiguousFactoryMethods = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">ambiguousFactoryMethods.add(factoryMethodToUse);</span><br><span class="line">&#125;</span><br><span class="line">ambiguousFactoryMethods.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (factoryMethodToUse == <span class="literal">null</span> || argsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (causes != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 解析失败，抛异常</span></span><br><span class="line"><span class="type">UnsatisfiedDependencyException</span> <span class="variable">ex</span> <span class="operator">=</span> causes.removeLast();</span><br><span class="line"><span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line"><span class="built_in">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; argTypes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(minNrOfArgs);</span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Object arg : explicitArgs) &#123;</span><br><span class="line">argTypes.add(arg != <span class="literal">null</span> ? arg.getClass().getSimpleName() : <span class="string">&quot;null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (resolvedValues != <span class="literal">null</span>) &#123;</span><br><span class="line">Set&lt;ValueHolder&gt; valueHolders = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(resolvedValues.getArgumentCount());</span><br><span class="line">valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());</span><br><span class="line">valueHolders.addAll(resolvedValues.getGenericArgumentValues());</span><br><span class="line"><span class="keyword">for</span> (ValueHolder value : valueHolders) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">argType</span> <span class="operator">=</span> (value.getType() != <span class="literal">null</span> ? ClassUtils.getShortName(value.getType()) :</span><br><span class="line">(value.getValue() != <span class="literal">null</span> ? value.getValue().getClass().getSimpleName() : <span class="string">&quot;null&quot;</span>));</span><br><span class="line">argTypes.add(argType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">argDesc</span> <span class="operator">=</span> StringUtils.collectionToCommaDelimitedString(argTypes);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;No matching factory method found: &quot;</span> +</span><br><span class="line">(mbd.getFactoryBeanName() != <span class="literal">null</span> ?</span><br><span class="line"><span class="string">&quot;factory bean &#x27;&quot;</span> + mbd.getFactoryBeanName() + <span class="string">&quot;&#x27;; &quot;</span> : <span class="string">&quot;&quot;</span>) +</span><br><span class="line"><span class="string">&quot;factory method &#x27;&quot;</span> + mbd.getFactoryMethodName() + <span class="string">&quot;(&quot;</span> + argDesc + <span class="string">&quot;)&#x27;. &quot;</span> +</span><br><span class="line"><span class="string">&quot;Check that a method with the specified name &quot;</span> +</span><br><span class="line">(minNrOfArgs &gt; <span class="number">0</span> ? <span class="string">&quot;and arguments &quot;</span> : <span class="string">&quot;&quot;</span>) +</span><br><span class="line"><span class="string">&quot;exists and that it is &quot;</span> +</span><br><span class="line">(isStatic ? <span class="string">&quot;static&quot;</span> : <span class="string">&quot;non-static&quot;</span>) + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">void</span>.class == factoryMethodToUse.getReturnType()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Invalid factory method &#x27;&quot;</span> + mbd.getFactoryMethodName() +</span><br><span class="line"><span class="string">&quot;&#x27;: needs to have a non-void return type!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ambiguousFactoryMethods != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Ambiguous factory method matches found in bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; &quot;</span> +</span><br><span class="line"><span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot;</span> +</span><br><span class="line">ambiguousFactoryMethods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (explicitArgs == <span class="literal">null</span> &amp;&amp; argsHolderToUse != <span class="literal">null</span>) &#123;</span><br><span class="line">mbd.factoryMethodToIntrospect = factoryMethodToUse;</span><br><span class="line">argsHolderToUse.storeCache(mbd, factoryMethodToUse);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建bean实例</span></span><br><span class="line">bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, factoryMethodToUse, argsToUse));</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法虽然庞大，整体的处理流程如下：</p><ol><li>获取 FactoryBeanName，如果 FactoryBeanName 不为空，说明创建 bean 的工厂也是一个 Spring 托管的 bean，否则就只能是一个静态工厂，且必须提供全类名。</li><li>获取工厂方法。<ol><li>首先同样是对重复创建 bean 的优化，从缓存中取。</li><li>参数类型转换。这里需要注意方法参数 <code>explicitArgs</code>，从 bean 创建流程上看，该参数是从最开始调用 <code>#getBean()</code> 方法时传的，则该参数必定为 null，此时还需要做参数解析，对于 <code>argToUse</code> 变量。<code>#resolvePreparedArguments()</code> 方法用于类型转换，具体的可能是将配置文件中的字面值转换成 Integer、Long 等类似的工作，更重要的是这里创建了构造函数所依赖的 bean。</li><li>和 factoryBeanName 同名的方法可能会有多个，通过参数个数、参数类型偏差等，决定使用哪个工厂方法进行 bean 创建。</li></ol></li><li>创建 bean 实例，这里是调用 <code>#instantiate()</code> 方法。</li></ol><h3 id="instantiate-方法"><a href="#instantiate-方法" class="headerlink" title="instantiate 方法"></a>instantiate 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">instantiate</span><span class="params">(String beanName, RootBeanDefinition mbd,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> Object factoryBean, Method factoryMethod, Object[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line"><span class="built_in">this</span>.beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">mbd, beanName, <span class="built_in">this</span>.beanFactory, factoryBean, factoryMethod, args),</span><br><span class="line"><span class="built_in">this</span>.beanFactory.getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">mbd, beanName, <span class="built_in">this</span>.beanFactory, factoryBean, factoryMethod, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Bean instantiation via factory method failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又是将实例化的工作委托给了 <code>InstantiationStrategy#instantiate(RootBeanDefinition,String,BeanFactory,Object,Method,Object...)</code> 方法。</p><p>InstantiationStrategy 有两个实现，但是只有 SimpleInstantiationStrategy 实现了该方法，而 CglibSubclassingInstantiationStrategy 实现类则是直接继承了 SimpleInstantiationStrategy。</p><pre><code class="highlight mermaid">classDiagramdirection BTclass CglibSubclassingInstantiationStrategyclass InstantiationStrategy &#123;&lt;&lt;Interface&gt;&gt;&#125;class SimpleInstantiationStrategyCglibSubclassingInstantiationStrategy  --&gt;  SimpleInstantiationStrategy SimpleInstantiationStrategy  ..&gt;  InstantiationStrategy</code></pre><p>而方案里面其实就是通过反射调用 FactoryMethod 得到 bean 实例了。</p><h2 id="构造函数创建-bean"><a href="#构造函数创建-bean" class="headerlink" title="构造函数创建 bean"></a>构造函数创建 bean</h2><p><code>#autowirdConstruct()</code> 方法和工厂方法创建 bean 有些类似，甚至依然是委托给了 ConstructorResolver 类处理，只不过这里是委托给了 <code>ConstructorResolver#autowireConstructor()</code> 方法。</p><blockquote><p>看到这里真的想骂人了，跟工厂方法那一块逻辑差不多，甚至一个方法里的代码都特别的长。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanWrapper <span class="title function_">autowireConstructor</span><span class="params">(String beanName, RootBeanDefinition mbd,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> Constructor&lt;?&gt;[] chosenCtors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">BeanWrapperImpl</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>();</span><br><span class="line"><span class="built_in">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt; constructorToUse = <span class="literal">null</span>;</span><br><span class="line"><span class="type">ArgumentsHolder</span> <span class="variable">argsHolderToUse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 使用的参数</span></span><br><span class="line">Object[] argsToUse = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 bean 时调用 getBean() 传入的 explicitArgs 一般都是 null</span></span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">argsToUse = explicitArgs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里是对有些 scope 存在重复创建 bean 的场景的优化</span></span><br><span class="line">Object[] argsToResolve = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="comment">// 如果构造函数的解析已经完成</span></span><br><span class="line"><span class="keyword">if</span> (constructorToUse != <span class="literal">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line"><span class="comment">// Found a cached constructor...</span></span><br><span class="line">argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line"><span class="keyword">if</span> (argsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (argsToResolve != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 参数类型转换，到这里主要是做类型转换，比如参数是 int 类型，那么在这里需要将 “1” 转换成 1</span></span><br><span class="line">argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以上代码说明在解析构造函数参数时，resolvedConstructorArguments 是经过了类型转换之后的，</span></span><br><span class="line"><span class="comment"> * preparedConstructorArguments 肯能还没有做类型转换，个人认为其实主要集中在基本类型的相互转换上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从逻辑上看，这里可用的构造函数引用和可用的构造函数参数列表是 null 的情况，说明其实还没有解析，</span></span><br><span class="line"><span class="comment"> * 即：该bean还是第一次创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (constructorToUse == <span class="literal">null</span> || argsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Take specified constructors, if any.</span></span><br><span class="line">Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line"><span class="comment">// 一般都是 null</span></span><br><span class="line"><span class="keyword">if</span> (candidates == <span class="literal">null</span>) &#123;</span><br><span class="line">Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 如果允许访问非 public 的方法，就返回所有的构造函数，不然就只取 public 的构造函数</span></span><br><span class="line">candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Resolution of declared constructors on bean Class [&quot;</span> + beanClass.getName() +</span><br><span class="line"><span class="string">&quot;] from ClassLoader [&quot;</span> + beanClass.getClassLoader() + <span class="string">&quot;] failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有一个构造函数，且传入的构造函数参数列表为 null，且 BeanDefinition 解析时就确定没有构造函数参数</span></span><br><span class="line"><span class="keyword">if</span> (candidates.length == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="literal">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">Constructor&lt;?&gt; uniqueCandidate = candidates[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 如果唯一的构造函数的参数列表长度也为 0，那就可以开始初始化实例了</span></span><br><span class="line"><span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">mbd.constructorArgumentsResolved = <span class="literal">true</span>;</span><br><span class="line">mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 instantiate() 方法构建实例, 因为前置判断决定了这里的构造方法是没有参数的，所以这里其实就是一个无参构造方法</span></span><br><span class="line">bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 到这里可以确定，对于这个 bean 初始化所需要的构造函数或者工厂方法、构造函数参数值的解析工作还没有进行</span></span><br><span class="line"><span class="comment"> * 所以，接下来需要进行解析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否需要解决构造器注入</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">autowiring</span> <span class="operator">=</span> (chosenCtors != <span class="literal">null</span> ||</span><br><span class="line">mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line"><span class="type">ConstructorArgumentValues</span> <span class="variable">resolvedValues</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 确定参数列表长度</span></span><br><span class="line"><span class="type">int</span> minNrOfArgs;</span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">minNrOfArgs = explicitArgs.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 从 BeanDefinition 中获取参数列表</span></span><br><span class="line"><span class="type">ConstructorArgumentValues</span> <span class="variable">cargs</span> <span class="operator">=</span> mbd.getConstructorArgumentValues();</span><br><span class="line">resolvedValues = <span class="keyword">new</span> <span class="title class_">ConstructorArgumentValues</span>();</span><br><span class="line"><span class="comment">// 在这里就会解决初始化以依赖的 bean，需要注意的是，这里是使用有参构造初始化 bean，</span></span><br><span class="line"><span class="comment">// 这就导致 如果 A 和 B 有相互的构造器注入，A 还没有初始化，正在寻找并初始化构造器参数时，会初始化 B，</span></span><br><span class="line"><span class="comment">// 而 B 又会尝试初始化 A, 但是从前序逻辑上看，此时 A 已经被标记为创建中，所有就会报循环依赖的异常</span></span><br><span class="line">minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数排序，先是 public 方法然后是非 public 的方法，同样的修饰符的方法，又以参数列表长度降序排序</span></span><br><span class="line">AutowireUtils.sortConstructors(candidates);</span><br><span class="line"><span class="type">int</span> <span class="variable">minTypeDiffWeight</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="literal">null</span>;</span><br><span class="line">Deque&lt;UnsatisfiedDependencyException&gt; causes = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">parameterCount</span> <span class="operator">=</span> candidate.getParameterCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (constructorToUse != <span class="literal">null</span> &amp;&amp; argsToUse != <span class="literal">null</span> &amp;&amp; argsToUse.length &gt; parameterCount) &#123;</span><br><span class="line"><span class="comment">// Already found greedy constructor that can be satisfied -&gt;</span></span><br><span class="line"><span class="comment">// do not look any further, there are only less greedy constructors left.</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于参数列表长度比 BeanDefinition 中定义的参数列表长度还小的，直接跳过</span></span><br><span class="line"><span class="keyword">if</span> (parameterCount &lt; minNrOfArgs) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArgumentsHolder argsHolder;</span><br><span class="line">Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line"><span class="keyword">if</span> (resolvedValues != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 获取参数名称数组</span></span><br><span class="line">String[] paramNames = getParamNames(candidate, parameterCount);</span><br><span class="line"><span class="comment">// 获取参数列表的 Holder</span></span><br><span class="line">argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span><br><span class="line">getUserDeclaredConstructor(candidate), autowiring, candidates.length == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Ignoring constructor [&quot;</span> + candidate + <span class="string">&quot;] of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Swallow and try next constructor.</span></span><br><span class="line"><span class="keyword">if</span> (causes == <span class="literal">null</span>) &#123;</span><br><span class="line">causes = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">causes.add(ex);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 从前面的逻辑看，到这里 explicitArgs 肯定不为 null, 如果长度不一致，直接忽略</span></span><br><span class="line"><span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span><br><span class="line"><span class="keyword">if</span> (parameterCount != explicitArgs.length) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接使用 explicitArgs 作为参数</span></span><br><span class="line">argsHolder = <span class="keyword">new</span> <span class="title class_">ArgumentsHolder</span>(explicitArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">typeDiffWeight</span> <span class="operator">=</span> (mbd.isLenientConstructorResolution() ?</span><br><span class="line">argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line"><span class="comment">// Choose this constructor if it represents the closest match.</span></span><br><span class="line"><span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">constructorToUse = candidate;</span><br><span class="line">argsHolderToUse = argsHolder;</span><br><span class="line">argsToUse = argsHolder.arguments;</span><br><span class="line">minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">ambiguousConstructors = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="literal">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line"><span class="keyword">if</span> (ambiguousConstructors == <span class="literal">null</span>) &#123;</span><br><span class="line">ambiguousConstructors = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">ambiguousConstructors.add(constructorToUse);</span><br><span class="line">&#125;</span><br><span class="line">ambiguousConstructors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数解析结束，如果此时可用的构造函数依然是 null ，那就没法初始化了，只能报错</span></span><br><span class="line"><span class="keyword">if</span> (constructorToUse == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (causes != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">UnsatisfiedDependencyException</span> <span class="variable">ex</span> <span class="operator">=</span> causes.removeLast();</span><br><span class="line"><span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line"><span class="built_in">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Could not resolve matching constructor &quot;</span> +</span><br><span class="line"><span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匹配上的构造函数有多个，而且不允许模糊匹配，那也只能报错</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != <span class="literal">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Ambiguous constructor matches found in bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; &quot;</span> +</span><br><span class="line"><span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot;</span> +</span><br><span class="line">ambiguousConstructors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (explicitArgs == <span class="literal">null</span> &amp;&amp; argsHolderToUse != <span class="literal">null</span>) &#123;</span><br><span class="line">argsHolderToUse.storeCache(mbd, constructorToUse);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Assert.state(argsToUse != <span class="literal">null</span>, <span class="string">&quot;Unresolved constructor arguments&quot;</span>);</span><br><span class="line"><span class="comment">// 终于找到了构造函数和参数，初始化对象</span></span><br><span class="line">bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不赘述，因为多个方法的情况下的选择、重复创建 bean 的处理方式和工厂方法创建 bean 基本是一样的思路。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>创建 bean 的方式有多种，但是从上述逻辑看，不同的方式存在优先级关系：</p><ol><li>通过 Supplier 接口创建。</li><li>通过工厂方法创建。</li><li>使用 BeanPostProcessor 决定的构造函数进行创建。</li><li>使用 BeanDefinition 中定义的优先使用的构造函数进行创建。</li><li>使用默认的无参构造函数进行创建。</li></ol></li><li><p>对于使用构造函数创建的，主要有 <code>#autowireConstructor()</code> 、<code>#instantiateBean()</code> 两个方法</p><ul><li>autowireConstructor 能够进行构造器注入的操作。</li><li>instantiateBean 方法则是使用无参构造进行创建。</li></ul></li><li><p>最后一点很重要，因为涉及到循环依赖的细节。当使用构造函数进行注入时，在创建 bean A 的实例之前，就已经在创建所依赖的 bean B 的实例了，在此之后，内存中才出现了 bean A 实例，任何其他 bean 想要依赖 A，那至少也得内存中有 A。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码解析：Bean加载（二）</title>
      <link href="posts/54dce9e15d4c.html"/>
      <url>posts/54dce9e15d4c.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-对-Scope-扩展的支持"><a href="#Spring-对-Scope-扩展的支持" class="headerlink" title="Spring 对 Scope 扩展的支持"></a>Spring 对 Scope 扩展的支持</h2><p>在<a href="/posts/dfcbfd4aee6c">Spring源码解析：Bean加载（一）</a>中，讲到了 <code>#doGetBean()</code> 方法中的 10 步，其中不同 Scope 创建 bean 的逻辑未深入解释，同时，也提到它们的区别主要在于 bean 实例的生命周期，但是创建 bean 都是调用的 <code>#createBean()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">// 9.1. 创建单例 bean</span></span><br><span class="line"><span class="comment">// 根据 beanName 获取单例 bean, 并传入一个 BeanFactory 函数时接口的回调</span></span><br><span class="line"><span class="comment">// 当 bean 不存在时，需要调用这个回调函数来创建 bean</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 当 bean 不存在时，最终会调用到这里的 creatBean 方法来创建单例 bean</span></span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// 9.2. 创建 prototype 模式 bean</span></span><br><span class="line"><span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 设置 bean 正在创建中</span></span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FactoryBean 处理</span></span><br><span class="line">beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 9.3. 其他自定义 Scope bean 创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 指定 Scope 进行初始化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScopeNotActiveException</span>(beanName, scopeName, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文将开始对 <code>#createBean()</code> 方法深入解析，但是该方法实现比较复杂，所以也需要分成几篇博文进行讲解。</p><h2 id="createBean"><a href="#createBean" class="headerlink" title="createBean()"></a>createBean()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"><span class="comment">// 1. 加载 class</span></span><br><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 2. 准备覆盖的方法，整理的 MethodOverride 是前面解析 BeanDefinition 时的 replaced-method、lookup-method 两个标签的解析结果</span></span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//3. 给BeanPostProcessor一个返回代理而不是目标 bean 实例的机会，AOP 就是在这一步实现</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 4. 通过 beanName BeanDefinition 创建 bean 实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要分为以下 4 步：</p><ol><li>加载 bean 对应的的 Class。</li><li>方法重写准备。</li><li>bean 实例化前处理，主要是调用 BeanPostProcessor。</li><li>调用 <code>#doCreateBean()</code> 方法创建 bean。</li></ol><h3 id="加载-bean-对应-Class"><a href="#加载-bean-对应-Class" class="headerlink" title="加载 bean 对应 Class"></a>加载 bean 对应 Class</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveBeanClass(RootBeanDefinition mbd, String beanName, Class&lt;?&gt;... typesToMatch)</span><br><span class="line"><span class="keyword">throws</span> CannotLoadBeanClassException &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 如果 BeanDefinition 中已经有了 bean 的 Class 类型，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (mbd.hasBeanClass()) &#123;</span><br><span class="line"><span class="keyword">return</span> mbd.getBeanClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> AccessController.doPrivileged((PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;)</span><br><span class="line">() -&gt; doResolveBeanClass(mbd, typesToMatch), getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 加载 bean Class</span></span><br><span class="line"><span class="keyword">return</span> doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="type">ClassNotFoundException</span> <span class="variable">ex</span> <span class="operator">=</span> (ClassNotFoundException) pae.getException();</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CannotLoadBeanClassException</span>(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CannotLoadBeanClassException</span>(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CannotLoadBeanClassException</span>(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 RootBeanDefinition 中已经指定了 Class，则直接返回，如果未指定，则加载相应的 Class，这个逻辑比较简单，其实也不用关心，不赘述。</p><h3 id="方法重写准备"><a href="#方法重写准备" class="headerlink" title="方法重写准备"></a>方法重写准备</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">MethodOverrides</span> <span class="variable">methodOverrides</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodOverrides</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepareMethodOverrides</span><span class="params">()</span> <span class="keyword">throws</span> BeanDefinitionValidationException &#123;</span><br><span class="line"><span class="comment">// Check that lookup methods exist and determine their overloaded status.</span></span><br><span class="line"><span class="keyword">if</span> (hasMethodOverrides()) &#123;</span><br><span class="line">getMethodOverrides().getOverrides().forEach(<span class="built_in">this</span>::prepareMethodOverride);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasMethodOverrides</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="built_in">this</span>.methodOverrides.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> MethodOverrides <span class="title function_">getMethodOverrides</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.methodOverrides;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现这里是针对 MethodOverride 的逻辑，这个接口在<a href="posts/d13dfeffc92a">Spring源码解析：BeanDefinition</a>中解析 <a href="/posts/d13dfeffc92a#%E8%A7%A3%E6%9E%90-lookup-method-%E6%A0%87%E7%AD%BE">lookup-method</a> 和 <a href="/posts/d13dfeffc92a#%E8%A7%A3%E6%9E%90-replaced-method-%E6%A0%87%E7%AD%BE">replaced-method</a> 两个标签时提到，解析完成后，分别生成了 LookupOverride、ReplaceOverride 两个类型的对象放到了 BeanDefinition 中，这里的 methodOverrides 其实就是这两个对象了。</p><p>然后再看看 <code>#prepareMethodPverride()</code> 方法的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareMethodOverride</span><span class="params">(MethodOverride mo)</span> <span class="keyword">throws</span> BeanDefinitionValidationException &#123;</span><br><span class="line"><span class="comment">// 获取 class 中指定方法名的方法个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionValidationException</span>(</span><br><span class="line"><span class="string">&quot;Invalid method override: no method with name &#x27;&quot;</span> + mo.getMethodName() +</span><br><span class="line"><span class="string">&quot;&#x27; on class [&quot;</span> + getBeanClassName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 标记为未 Overload，避免检查 arg 类型时多余的开销</span></span><br><span class="line"><span class="comment">// Mark override as not overloaded, to avoid the overhead of arg type checking.</span></span><br><span class="line">mo.setOverloaded(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现这里是拿到了 Class 中和要做 override 操作的方法同名的方法（即方法重载）的数量，如果为 0，说明方法名不存在，抛异常，如果数量为 1，则说明没有被重载，将 overloaded 置为 false，否则保持为默认的 true。</p><blockquote><p>这可以认为是一个前置的小优化。</p></blockquote><h3 id="bean-实例化前处理"><a href="#bean-实例化前处理" class="headerlink" title="bean 实例化前处理"></a>bean 实例化前处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//3. 给BeanPostProcessor一个返回代理而不是目标 bean 实例的机会，AOP 就是在这一步实现</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// ......</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line"><span class="keyword">if</span> (targetType != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 执行 BeanPostProcessor 的 before</span></span><br><span class="line">bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 执行 BeanPostProcessor 的 after 方法，到这里说明已经创建了 bean 实例，猜测这里拿到的是动态代理生成的 bean 实例</span></span><br><span class="line">bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mbd.beforeInstantiationResolved = (bean != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步处理得到的 bean 实例如果不为空，则整个 createBean() 方法就直接返回了，即这一步处理得到的非空结果就是最终的 bean 实例对象了。</p><p>其实这里就是做一些前置处理，如果 bean 需要代理，那么这里会返回 bean 的代理对象。</p><blockquote><p>先记住这里返回的是代理对象，后面讲循环依赖时，会再次讲到这里。</p></blockquote><h3 id="doCreateBean-方法"><a href="#doCreateBean-方法" class="headerlink" title="doCreateBean() 方法"></a>doCreateBean() 方法</h3><p>doCreateBean() 方法主要做 bean 实例化、属性填充、初始化，同时还有循环依赖的一些逻辑。</p><p>循环依赖问题的解决并不是在某一个地方的逻辑解决的，而是加载 bean 的很多个环节都有相关逻辑，各个地方相互配合才解决了循环依赖问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实例化 bean 对象</span></span><br><span class="line"><span class="comment">// BeanWrapper 提供的是操作 bean 实例的基础能力</span></span><br><span class="line"><span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 创建 bean 实例</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 2. mergeBeanDefinitionPostProcessor，@Autowired 注解的预解析就在这里</span></span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="comment">// 3. 解决循环依赖</span></span><br><span class="line"><span class="comment">// 是否支持单例 bean 实例提前暴露，用于解决循环依赖问题，Spring 目前只解决了单例 bean 的循环依赖</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为解决循环依赖做准备，在这里将 beanName 和 bean 的对象工厂放进缓存中</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 4. 填充 bean，注入各个属性值，如果要注入的 bean 没有初始化，那也会初始化要注入的 bean</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 5. 初始化</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 6. 这里只会从一级、二级缓存里面拿 bean 实例，但是因为本身就是还在创建，所以这里其实是从二级缓存里面拿，但是二级缓存里面不一定有</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 不为空，已经从三级缓存进入到了二级缓存</span></span><br><span class="line"><span class="comment">// 是同一个对象，说明拿到的是没有被增强的实例</span></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 到这里如果 actualDependentBeans 不为空，说明这个 bean 所依赖的 bean 还没有创建完，</span></span><br><span class="line"><span class="comment">// 存在初始化顺序上的循环依赖</span></span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line"><span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line"><span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line"><span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line"><span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 7. 根据 scope 注册 bean 的 destroy-method</span></span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#doCreateBean()</code> 方法分以下 6 步：</p><ol><li>实例化 bean 对象，这里实例化，其实就是使用构造函数构建一个对象，但是构建出来的对象的各个属性可能是 null。这取决于 bean 的注入方式，这一步会讲通过构造函数注入的依赖先完成，对于使用 set 方法注入和直接使用 @Autowired 注解注入的，则是后续填充属性时注入。</li><li>执行 mergeBeanDefinitionPostProcessor，一些前置处理，<code>@Autowired</code> 注解的解析就在这里。</li><li>解决循环依赖的逻辑，这俩主要是 beanName 和 ObjectFactory 方法第三级缓存中。循环依赖整体的解决方案，后面单独写博文讲解。</li><li>填充 bean 属性。这一步主要是将 @Autowired 注解和 set 方法进行注入依赖做填充操作。</li><li>执行 bean 初始化方法，执行 init-method 标签、@PostConstruct 标记的方法。</li><li>注册 bean 的销毁方法。</li></ol><p>需要注意的是，在第 5 步过后，调用了 <code>#getSingleton()</code> 方法，这里调用时，传入的第二个参数为 false，所以这里其实是尝试从二级缓存中获取 bean 实例，不会调用第三级缓存。因为在第 3 步时，将 beanName 和 ObjectFactory 的映射关系放到了第三级缓存中，此时 bean 加载还未完成，所以要从第三级缓存迁移到二级缓存，只能是在前面的步骤中，围绕当前创建的 bean 出现了循环依赖，所以如果此时从二级缓存中拿到了对象实例，那么极有可能是已经经过了 AOP 代理后的对象实例，具体原因参见后续单独讲解循环依赖的博文。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>本文只是一个流程梳理，每一步的具体细节，基本都会单独写一篇博文进行讲解。</p></blockquote><ol><li><p>整体过程最主要的有 3 步：</p><p>a. bean 对象实例化。</p><p>b. 填充对象属性。</p><p>c. 执行初始化方法。</p></li><li><p>流程中调用了一次 getSington() 方法，这次调用会从第一、二级缓存中拿对象实例，如果结果不为空，那么对象实例可能是已经被 AOP 代理后的对象实例。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码解析：Bean加载（一）</title>
      <link href="posts/dfcbfd4aee6c.html"/>
      <url>posts/dfcbfd4aee6c.html</url>
      
        <content type="html"><![CDATA[<p>当我们要从一个 BeanFactory 中拿到某个 bean 时，我们会调用 <code>#getBean()</code> 系列（之所以是系列，是因为方法重载了好几次）方法，而 <code>#getBean()</code> 方法会调用 <code>#doGetBean(String name, Class&lt;T&gt; requiredType, Object[] args, boolean typeCheckOnly)</code> 方法，该方法有 4 个参数：</p><ul><li><p>name</p><p>要获取的 bean 的名称。</p></li><li><p>requireType</p><p>要获取的 bean 的 Java 类型。</p></li><li><p>args </p><p>构造 bean 时需要的参数。</p></li><li><p>typeCheckOnly</p><p>是否仅仅只是做类型检查。</p></li></ul><p>虽然看方法名称，是用来获取 bean 实例对象的，但是在 Spring 初始化阶段，这个方法主要是用来做 bean 的初始化。</p><blockquote><p><strong>Q&amp;A</strong></p><p>Q: 初始化的入口在哪里？</p><p>A: 在 <code>DefaultListableBeanFactory#preInstantiateSingletons()</code> 方法中，虽然在加载了 BeanDefinition 后、调用该方法前， Spring 也做了很多事，但是都是为了支持一些扩展功能的，不影响对 bean 初始化的理解。</p></blockquote><h1 id="doGetBean-方法主流程"><a href="#doGetBean-方法主流程" class="headerlink" title="doGetBean() 方法主流程"></a>doGetBean() 方法主流程</h1><p>在容器初始化 bean 时，调用 doGetBean() 方法的参数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="comment">// 真正执行获取实例的方法</span></span><br><span class="line"><span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看 doGetBean() 方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line"><span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="comment">// 1. 处理别名或者传入的是 FactoryBean 的名字的情况</span></span><br><span class="line"><span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">Object beanInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line"><span class="comment">// 2. 尝试从缓存中加载单例 bean</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 对 FactoryBean 的处理</span></span><br><span class="line">beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line"><span class="comment">// 4. 从单例缓存中没有找到 bean，检查是不是还在创建中，如果是，抛异常</span></span><br><span class="line"><span class="comment">// 如果不是单例模式的 bean，但是又是在创建中，说明是二次创建，直接抛异常</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line"><span class="comment">// 5. 如果有父 BeanFactory，当前 BeanFactory 中又没有 beanName 对应的 BeanDefinition 对象，就尝试从父容器获取</span></span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// 当前 beanFactory 中未找到，从父 BeanFactory 中查找</span></span><br><span class="line"><span class="comment">// 获取 beanName</span></span><br><span class="line"><span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line"><span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6. 如果不是只检查 bean 类型，那说明是要创建 bean，这里标签为已创建</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line"><span class="comment">// 这里将 BeanDefinition 的 stale 属性设置为了 true</span></span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">StartupStep</span> <span class="variable">beanCreation</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.beans.instantiate&quot;</span>)</span><br><span class="line">.tag(<span class="string">&quot;beanName&quot;</span>, name);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line">beanCreation.tag(<span class="string">&quot;beanType&quot;</span>, requiredType::toString);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7. 获取 merge 之后的 BeanDefinition，在最开始加载的时候，都是 GenericBeanDefinition</span></span><br><span class="line"><span class="comment">// merge 其实就是转换成 RootBeanDefinition, 后续工作都基于 RootBeanDefinition 进行</span></span><br><span class="line"><span class="comment">// 合并的时候，其实主要就是将原来的 GenericBeanDefinition 内容转移到 RootBeanDefinition，</span></span><br><span class="line"><span class="comment">// 如果有父 BeanDefinition，也要合并到 RootBeanDefinition 中</span></span><br><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">// 如果当前 BeanDefinition 是抽象的 bean，抛异常</span></span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line"><span class="comment">// 8. 依赖  bean 处理</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="comment">// 这里是为了避免出现 A 和 B 得初始化顺寻互相依赖，和循环依赖得注入不一样</span></span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册依赖关系, 容器中维护了 dependentBeanMap, key 是 beanName，</span></span><br><span class="line"><span class="comment">// value 是依赖 key 所表示的 bean 的所有 bean 的集合</span></span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 递归调用，获取依赖的 bean，这里其实主要是为了在依赖的 bean 没有创建时进行创建</span></span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 创建 bean 实例</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">// 9.1. 创建单例 bean </span></span><br><span class="line"><span class="comment">// 根据 beanName 获取单例 bean, 并传入一个 BeanFactory 函数时接口的回调</span></span><br><span class="line"><span class="comment">// 当 bean 不存在时，需要调用这个回调函数来创建 bean</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 当 bean 不存在时，最终会调用到这里的 creatBean 方法来创建单例 bean</span></span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// 9.2. 创建 prototype 模式 bean</span></span><br><span class="line"><span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 设置 bean 正在创建中</span></span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FactoryBean 处理</span></span><br><span class="line">beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 9.3. 其他自定义 Scope bean 创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 指定 Scope 进行初始化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScopeNotActiveException</span>(beanName, scopeName, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">beanCreation.tag(<span class="string">&quot;exception&quot;</span>, ex.getClass().toString());</span><br><span class="line">beanCreation.tag(<span class="string">&quot;message&quot;</span>, String.valueOf(ex.getMessage()));</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">beanCreation.end();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10. 返回类型适配</span></span><br><span class="line"><span class="keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体上分为 10 步：</p><ol><li>beanName 处理。处理别名或者传入的是 FactoryBean 的名字的情况，拿到真实的 beanName。</li><li>尝试从缓存中加载单例 bean。</li><li>对 FactoryBean 的处理，如果拿到的 bean 是一个 FactoryBean，还需要通过 <code>#getObjectForBeanInstance()</code> 方法进一步处理，这虽然是低 3 步，但其实不管以怎样的方式拿到的 bean 实例，都需要有这一步处理，可以看见 doGetBean() 方法中多个地方都调用了 <code>#getObjectForBeanInstance()</code> 方法。</li><li>prototype 类型并发创建检查。</li><li>如果当前 BeanFactory 中找不到目标 beanName，则尝试从父 BeanFactory 中查找。</li><li>标识 beanName 对应的 bean 正在创建中。</li><li>组装并检查 RootBeanDefinition。</li><li>依赖 bean 处理，这里一般指使用 bean 标签的 <code>depends-on</code> 属性或 <code>@DependsOn</code> 注解指定的 bean，这种方式指定的依赖的 bean 必须比当前 bean 先创建。</li><li>创建 bean 实例，这里分了 singlton、prototype、自定义 scope 3 种情况，具体的差别单独写博文讲解，但是都调用了 <code>#creatBean()</code> 来创建 bean 实例。</li><li>返回 bean 类型适配。</li></ol><p>因为这 10 步，有些比较简单，有些很复杂，所以本文对每一步做一个或浅或深的解析，复杂的步骤会单独再出一篇文章进行解析。</p><h2 id="beanName-处理"><a href="#beanName-处理" class="headerlink" title="beanName 处理"></a>beanName 处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String <span class="title function_">transformedBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> canonicalName(BeanFactoryUtils.transformedBeanName(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">canonicalName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> name;</span><br><span class="line"><span class="comment">// 别名处理，这里要拿到最终的 beanName 而不是别名</span></span><br><span class="line">String resolvedName;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">resolvedName = <span class="built_in">this</span>.aliasMap.get(canonicalName);</span><br><span class="line"><span class="comment">// 如果从 aliasMap 拿到的结果不是 null 说明，依然是别名，直到 resolvedName 为 null 时，说明拿到的是真实的 beanName</span></span><br><span class="line"><span class="keyword">if</span> (resolvedName != <span class="literal">null</span>) &#123;</span><br><span class="line">canonicalName = resolvedName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (resolvedName != <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">return</span> canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>beanName 的处理，主要是要做两件事：</p><ol><li>参数传入的 beanName 可能是别名，而 singletonObjects 中保存的是真实的 beanName 和 bean 实例的关系，所以这里需要拿到真实的 beanName，这段逻辑就是 <code>#canonicalName()</code> 方法，不再赘述。</li><li>将 FactoryBean 的名称转换成最终生成的 bean 的名称，即去掉参数传入的 beanName 中的 <code>&amp;</code>，这段逻辑在 <code>BeanFactoryUtils#transformedBeanName()</code> 方法中实现。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">transformedBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">Assert.notNull(name, <span class="string">&quot;&#x27;name&#x27; must not be null&quot;</span>);</span><br><span class="line"><span class="comment">// 如果name不以 &amp; 开头，说明不是 FactoryBean,直接返回即可</span></span><br><span class="line"><span class="keyword">if</span> (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FactoryBean 的 beanName</span></span><br><span class="line"><span class="keyword">return</span> transformedBeanNameCache.computeIfAbsent(name, beanName -&gt; &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 要删除 &amp; 前缀</span></span><br><span class="line">beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));</span><br><span class="line"><span class="keyword">return</span> beanName;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>考虑到 beanName 中 <code>&amp;</code> 可能不止一个，这里是循环删除 beanName 中的 <code>&amp;</code>，直到 beanName 不再是以 <code>&amp;</code> 开始。</p><p>关于 FactoryBean 和 真实的 bean 之间的名称的关系，可以理解为名称为 <code>a</code> 的 bean，如果是通过 FactoryBean 生成，则对应的 FactoryBean 的名称为 <code>&amp;a</code>。</p><h2 id="从缓存中加载单例-bean-实例"><a href="#从缓存中加载单例-bean-实例" class="headerlink" title="从缓存中加载单例 bean 实例"></a>从缓存中加载单例 bean 实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line"><span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line"><span class="comment">// singletonObjects，一级缓存，存储 beanName 和 bean 实例对象的映射关系</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span></span><br><span class="line"><span class="comment">// 目标 bean 是否还在创建中</span></span><br><span class="line">&amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="comment">// 从二级缓存中获取 bean 实例，二级缓存中的 bean 实例一般都是还没创建完成的实例</span></span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span></span><br><span class="line"><span class="comment">// 二级缓存中依然没有，如果允许提前创建，就访问三级缓存</span></span><br><span class="line">&amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="comment">// 单例模式同步双重校验</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 从三级缓存中拿到 bean 的 ObjectFactory 对象，从而拿到 bean 的早期引用</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="comment">// 将 bean 实例放入二级缓存</span></span><br><span class="line"><span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="comment">// 将 beanName 和 ObjectFactory 的映射关系从三级缓存中删除</span></span><br><span class="line"><span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体逻辑不赘述，因为代码中注释已经说明了。</p><p>需要注意的是，这里终于出现了常说的 Spring 三级缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一级缓存，存储单例 bean 名称和对应的最终版的 Bean 实例对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二级缓存，存储单例 bean 名称和对应的 Bean 的最初版本 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 三级缓存，存储单例 bean 名称和对应的 Bean 的函数式工厂对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><ul><li><p>singletonObjects</p><p>一级缓存，保存了 beanName 和最终可用的 bean 实例对象的映射关系。</p></li><li><p>earlySingletonObjects</p><p>二级缓存，保存了 beanName 和实例化的 bean 对象的映射关系。</p><blockquote><p>这里暂且认为实例化阶段是指对象已经被 new 出来了，但是其依赖的 bean 还未注入，所以是个半成品。</p></blockquote></li><li><p>singletonFactories</p><p>三级缓存，保存的是 beanName 和 ObjectFactory 的映射关系，ObjectFactory 能拿到最终 bean 实例的引用，作用讲起来比较复杂，后面新博文讲三级缓存和循环依赖时，再来聊聊它的作用比较合适。</p></li></ul><p>从 <code>#getSingleton()</code> 方法逻辑可以知道，bean 实例一开始是在三级缓存的 ObjectFactory 中，调用方法时，会从三级缓存拿到 ObjectFactory，拿到 bean 实例对象，再放入二级缓存，同时将 singltonFactories 中 beanName 对应的缓存删除。</p><h2 id="FactoryBean-的处理"><a href="#FactoryBean-的处理" class="headerlink" title="FactoryBean 的处理"></a>FactoryBean 的处理</h2><p>在此之前，需要先了解一下 FactoryBean，Spring 对 FactoryBean 的定位是用来构建一些比较复杂的 bean，即通过简单的依赖注入并不能得到想要的对象实例时，可以使用 FactoryBean 来自定义实例化的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">OBJECT_TYPE_ATTRIBUTE</span> <span class="operator">=</span> <span class="string">&quot;factoryBeanObjectType&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 获取 bean 实例 */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 获取 bean 的 Java 类型 */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 是否为单例 bean */</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换言之，FactoryBean 本身并不是我们想要的 bean 实例，调用它的 getObject() 方法，才能拿到我们想要的 bean 实例。</p><p>然后，再看看 <code>#getObjectForBeanInstance()</code> 方法逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span></span><br><span class="line"><span class="comment">// 1. 如果 name 是有 &amp; 前缀的，说明要的就是 FactoryBean 的实例</span></span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name有&amp;前缀表示是 FactoryBean，但是获取到的 bean 并不是 FactoryBean 的实例，直接抛异常</span></span><br><span class="line"><span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanIsNotAFactoryException</span>(beanName, beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">mbd.isFactoryBean = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line"><span class="comment">// If it&#x27;s a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line"><span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line"><span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line"><span class="comment">// 2. name 不是以 &amp; 开头，所以要获取的是 FactoryBean 最终生成的 Bean 对象</span></span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">mbd.isFactoryBean = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 3. 从缓存中获取 bean 对象</span></span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 4. 从 FactoryBean 中获取 bean 实例</span></span><br><span class="line"><span class="comment">// Return bean instance from factory.</span></span><br><span class="line"><span class="comment">// 此时 beanInstance 肯定是 FactoryBean</span></span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line"><span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">synthetic</span> <span class="operator">=</span> (mbd != <span class="literal">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码逻辑主要分 4 步：</p><ol><li><p>对 name 参数有 <code>&amp;</code> 前缀时的处理。</p><p>如果 bean 实例是 FactoryBean 类型的，或者是 NullBean，直接返回，如果不是则 bean 实例和 name 实际想要的对象实例不符，直接抛异常。</p><p>回看一下前面对 beanName 的处理逻辑中，有提到 FactoryBean 的名称是实际的 beanName 前加上一个 <code>&amp;</code> 前缀，倒不是说容器中是这样存的，而是对 beanName 入参的规范是：如果要获取的是 FactoryBean 的实例，而不是最终构建出的 bean 实例，则 beanName 前需要加 <code>&amp;</code> 前缀。</p></li><li><p>如果 name 参数没有 <code>&amp;</code> 前缀，且 bean 实例不是 FactoryBean，直接返回。</p></li><li><p>这里是从 FactoryBean 的缓存中获取 bean 实例。如果前面两步都没能返回，那说明要拿的不是 FactoryBean，而是 FactoryBean 构建的 bean。</p></li><li><p>本质上就是要调用 <code>FactoryBean#getObject()</code> 方法获取 bean 实例。</p></li></ol><p>前面 3 步都比较简单，我们深入看看滴 4 步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="type">boolean</span> shouldPostProcess)</span> &#123;</span><br><span class="line"><span class="comment">// 如果构建的是单例 bean，且 singletonObjects 中已经有这个 bean</span></span><br><span class="line"><span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line"><span class="comment">// 尝试从缓存中获取 bean 实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 缓存中没有，则调用 FactoryBean.getObject() 获取</span></span><br><span class="line">object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"><span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line"><span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line"><span class="comment">// 再次从缓存中获取</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">alreadyThere</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (alreadyThere != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果缓存中有，则返回缓存中的 bean</span></span><br><span class="line">object = alreadyThere;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 是否需要进行后置处理</span></span><br><span class="line"><span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">beforeSingletonCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line"><span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterSingletonCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="comment">// 放入缓存</span></span><br><span class="line"><span class="built_in">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"><span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里同样是尝试从缓存里面拿，缓存中没有则直接创建。</p><p>这里的核心是 <code>#doGetObjectFromFactoryBean()</code> 方法创建 bean，逻辑比较简单，其实就是调用 <code>FactoryBean#getObject()</code> 方法。</p><h2 id="prototype-类型并发创建检查"><a href="#prototype-类型并发创建检查" class="headerlink" title="prototype 类型并发创建检查"></a>prototype 类型并发创建检查</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation =</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;Prototype beans currently in creation&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isPrototypeCurrentlyInCreation</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">curVal</span> <span class="operator">=</span> <span class="built_in">this</span>.prototypesCurrentlyInCreation.get();</span><br><span class="line"><span class="keyword">return</span> (curVal != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">(curVal.equals(beanName) || (curVal <span class="keyword">instanceof</span> Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prototypesCurrentlyInCreation 是一个记录正在创建中的 prototype 类型 beanName 的线程 ThreadLocal，如果当前要创建的 beanName 在 ThreadLocal 中，说明该 bean 已经在创建中了，创建时遇见这个情况，直接抛异常。</p><blockquote><p>这里会抛异常是因为 prototype 类型是说每次获取这个 bean，都会创建一个新的 bean 实例，prototypesCurrentlyInCreation 是一个线程上下文，线程内，代码是串行执行，会出现上面代码中的情况应是，同一个线程中，创建 prototype 类型 bean 时，和其他 bean 有循环依赖，导致循环创建 bean，所以才会报错，总结一下，其实就是，<strong>Spring 不能解决 prototype 类型的循环依赖。</strong></p></blockquote><h2 id="从父-BeanFactory-中查找-beanName"><a href="#从父-BeanFactory-中查找-beanName" class="headerlink" title="从父 BeanFactory 中查找 beanName"></a>从父 BeanFactory 中查找 beanName</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// 当前 beanFactory 中未找到，从父 BeanFactory 中查找</span></span><br><span class="line"><span class="comment">// 获取 beanName</span></span><br><span class="line"><span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line"><span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父 BeanFactory 是 AbstractBeanFactory 类型的，则调用其 doGetBean() 方法，如果不是，则调用其 getBean() 方法，只不过参数得按实际的情况传。</p><blockquote><p>是的，doGetBean() 方法是定义在 AbstractBeanFactory 类中，而不是在 BeanFactory 接口中。</p></blockquote><h2 id="标识-beanName-对应的-bean-正在创建中"><a href="#标识-beanName-对应的-bean-正在创建中" class="headerlink" title="标识 beanName 对应的 bean 正在创建中"></a>标识 beanName 对应的 bean 正在创建中</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">   <span class="comment">// 这里将 BeanDefinition 的 stale 属性设置为了 true</span></span><br><span class="line">   markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">markBeanAsCreated</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line"><span class="comment">// Let the bean definition get re-merged now that we&#x27;re actually creating</span></span><br><span class="line"><span class="comment">// the bean... just in case some of its metadata changed in the meantime.</span></span><br><span class="line">clearMergedBeanDefinition(beanName);</span><br><span class="line"><span class="built_in">this</span>.alreadyCreated.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>alreadyCreated 记录的是至少已经创建了一次的 beanName，这里是将当前的 beanName 也加入到 alreadyCreated 中。</p><h2 id="组装并检查-RootBeanDefinition"><a href="#组装并检查-RootBeanDefinition" class="headerlink" title="组装并检查 RootBeanDefinition"></a>组装并检查 RootBeanDefinition</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组装 RootBeanDefinition</span></span><br><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">// 如果当前 BeanDefinition 是抽象的 bean，抛异常</span></span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br></pre></td></tr></table></figure><p>这里之所以要组装 RootBeanDefinition，是因为 Spring 中 BeanDefinition 有多种，而后续流程是固定流程，所以需要有确定的统一的 BeanDefinition，所以这里需要把其他类型的 BeanDefinition 转换成 RootBeanDefinition。</p><p>在学习 Java 基础时，我们就知道抽象类型是不能实例化的，所以得到 RootBeanDefinition 后还得检查要创建的 bean 是否是一个抽象类型，如果是，则直接抛异常。</p><h2 id="依赖处理"><a href="#依赖处理" class="headerlink" title="依赖处理"></a>依赖处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="comment">// 这里是为了避免出现 A 和 B 得初始化顺寻互相依赖，和循环依赖得注入不一样</span></span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册依赖关系, 容器中维护了 dependentBeanMap, key 是 beanName，</span></span><br><span class="line"><span class="comment">// value 是依赖 key 所表示的 bean 的所有 bean 的集合</span></span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 递归调用，获取依赖的 bean，这里其实主要是为了在依赖的 bean 没有创建时进行创建</span></span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依赖处理这里，做了 3 件事：</p><ol><li><p>循环依赖检查</p><p>主要是避免 A depends on B，B depends on A 这样的循环依赖的情况。</p><p>Spring 维护了一个 <code>Map&lt;String, Set&lt;String&gt;&gt;</code> 类型的 <code>dependentBeanMap</code>，key 是 beanName，value 是依赖这个 bean 的 beanName 列表。 </p></li><li><p>注册依赖关系。</p></li><li><p>创建依赖的 bean，依然是调用 getBean() 方法进行创建，这就又回到了文章最开始的 doGetBean() 的地方了。</p></li></ol><h2 id="根据不同的-scope-创建-bean-实例"><a href="#根据不同的-scope-创建-bean-实例" class="headerlink" title="根据不同的 scope 创建 bean 实例"></a>根据不同的 scope 创建 bean 实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 9. 创建 bean 实例</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">// 9.1. 创建单例 bean</span></span><br><span class="line"><span class="comment">// 根据 beanName 获取单例 bean, 并传入一个 BeanFactory 函数时接口的回调</span></span><br><span class="line"><span class="comment">// 当 bean 不存在时，需要调用这个回调函数来创建 bean</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 当 bean 不存在时，最终会调用到这里的 creatBean 方法来创建单例 bean</span></span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// 9.2. 创建 prototype 模式 bean</span></span><br><span class="line"><span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 设置 bean 正在创建中</span></span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FactoryBean 处理</span></span><br><span class="line">beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 9.3. 其他自定义 Scope bean 创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 指定 Scope 进行初始化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScopeNotActiveException</span>(beanName, scopeName, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段逻辑比较简单，只不过从上面的代码可以看出，</p><ol><li><p>Spring 是原生的支持了 singleton、prototype 两种类型的 bean，其他类型都是通过扩展 Scope 接口来实现的，创建 bean 也是调用的 <code>#Scope.get()</code> 方法。</p></li><li><p>不管哪种 Scope，创建 bean 实例的逻辑一致，都是调用 <code>#createBean()</code> 方法进行创建，只是创建出的 bean 的生命周期不同。</p></li></ol><h2 id="返回值类型转换"><a href="#返回值类型转换" class="headerlink" title="返回值类型转换"></a>返回值类型转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">adaptBeanInstance</span><span class="params">(String name, Object bean, <span class="meta">@Nullable</span> Class&lt;?&gt; requiredType)</span> &#123;</span><br><span class="line"><span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line"><span class="comment">// 类型检查，检查得到的 bean 类型和期望的类型是否一致</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">convertedBean</span> <span class="operator">=</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line"><span class="keyword">if</span> (convertedBean == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) convertedBean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Spring 初始化阶段，requireType 是传的 null。</p></blockquote><ol><li>如果 requireType 为 null，或者 bean 实例类型和 requireType 一致，则直接使用 <code>(T)bean</code> 的方式进行强转。</li><li>如果类型不一致，则使用 TypeConverter 进行转换后返回。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>带 <code>&amp;</code> 前缀的 name，获取的是 FactoryBean 的实例对象，但是业务上一般不会这样做。</li><li>如果当前 BeanFactory 中不存在，则从父 BeanFactory 中查找。</li><li>所有 BeanDefinition 都会转换成 RootBeanDefinition 进行后续的创建流程。</li><li>depends-on 建立的依赖关系不允许出现循环依赖。</li><li>所有的 Scope 的 bean，虽然生命周期不同，但都是调用 <code>#createBean()</code> 方法进行创建。</li><li>如果获取的 bean 类型和预期的类型不一致，还可以通过实现 TypeConverter 接口来进行转换。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码解析：自定义标签</title>
      <link href="posts/163184d50150.html"/>
      <url>posts/163184d50150.html</url>
      
        <content type="html"><![CDATA[<p>在上一篇讲解 BeanDefinition 的解析过程中，不止一次遇见了自定义标签的解析，且都伴随着一个自定义的命名空间。</p><p>在 <code>DefaultBeanDefinitionDocumentReader#parseBeanDefinitions</code> 方法中，便有 spring 默认命名空间和自定义命名空间的区分处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line"><span class="comment">// 是否是 spring 默认的命名空间</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line"><span class="comment">// 获取子节点列表</span></span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line"><span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line"><span class="comment">// 子节点是否是默认命名空间中的标签</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line"><span class="comment">// 解析默认标签节点</span></span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 自定义标签解析</span></span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 解析自定义标签</span></span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的具体逻辑不再赘述，直接深入看看自定义标签的解析，即 <code>delegate#parseCustomElement()</code> 方法。深入方法实现，最终调用到同名的方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parseCustomElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取命名空间的 uri</span></span><br><span class="line"><span class="type">String</span> <span class="variable">namespaceUri</span> <span class="operator">=</span> getNamespaceURI(ele);</span><br><span class="line"><span class="comment">// 2.命名空间的 uri 不存在，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (namespaceUri == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.通过命名空间的 uri 获取对应的处理器</span></span><br><span class="line"><span class="type">NamespaceHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 4.如果没有相应的处理器，记录错误，并返回</span></span><br><span class="line">error(<span class="string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5.调用处理器的parse方法进行解析</span></span><br><span class="line"><span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> <span class="title class_">ParserContext</span>(<span class="built_in">this</span>.readerContext, <span class="built_in">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心逻辑就是，从 readerContext 中获取 NamespaceHandlerResolver，然后通过 namespaceUri 获取一个 NamespaceHandler，然后调用 <code>NamespaceHandler#parse</code> 方法对自定义标签进行解析。</p><h2 id="NamespaceHandlerResolver"><a href="#NamespaceHandlerResolver" class="headerlink" title="NamespaceHandlerResolver"></a>NamespaceHandlerResolver</h2><p>追溯代码会发现，readerContext 中的 NamespaceHandlerResolver 实例是 DefaultNamespaceHandlerResolver，再看看 <code>DefaultNamespaceHandlerResolver#resolve</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认 handlerMapping 配置文件地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_HANDLER_MAPPINGS_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;META-INF/spring.handlers&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> NamespaceHandler <span class="title function_">resolve</span><span class="params">(String namespaceUri)</span> &#123;</span><br><span class="line"><span class="comment">// 获取命名空间 uri 和对应解析器的 Map</span></span><br><span class="line">Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line"><span class="comment">// 获取解析器对象或者 class 名称</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">handlerOrClassName</span> <span class="operator">=</span> handlerMappings.get(namespaceUri);</span><br><span class="line"><span class="keyword">if</span> (handlerOrClassName == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) &#123;</span><br><span class="line"><span class="comment">// 如果是 NamespaceHandler 对象，直接返回</span></span><br><span class="line"><span class="keyword">return</span> (NamespaceHandler) handlerOrClassName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> (String) handlerOrClassName;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 加载 class</span></span><br><span class="line">Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="built_in">this</span>.classLoader);</span><br><span class="line"><span class="keyword">if</span> (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FatalBeanException</span>(<span class="string">&quot;Class [&quot;</span> + className + <span class="string">&quot;] for namespace [&quot;</span> + namespaceUri +</span><br><span class="line"><span class="string">&quot;] does not implement the [&quot;</span> + NamespaceHandler.class.getName() + <span class="string">&quot;] interface&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化对象</span></span><br><span class="line"><span class="type">NamespaceHandler</span> <span class="variable">namespaceHandler</span> <span class="operator">=</span> (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">namespaceHandler.init();</span><br><span class="line"><span class="comment">// 放入缓存的 map 中</span></span><br><span class="line">handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line"><span class="keyword">return</span> namespaceHandler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FatalBeanException</span>(<span class="string">&quot;Could not find NamespaceHandler class [&quot;</span> + className +</span><br><span class="line"><span class="string">&quot;] for namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FatalBeanException</span>(<span class="string">&quot;Unresolvable class definition for NamespaceHandler class [&quot;</span> +</span><br><span class="line">className + <span class="string">&quot;] for namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先获取了一个 handlerMappings 的 map，key 是 namespaceUri，value 是对应的 NameSpaceHandler 对象或 Class 名称。</li><li>通过 namespaceUri 从 map 中获取 NameSpaceHandler.</li><li>如果为空，直接结束。</li><li>如果不为空，且是 NamespaceHandler 对象，直接将对象返回。</li><li>如果不为空，且不是 NamespaceHandler 对象实例，则默认当成 Class name 处理，则加载对应的 Class，然后实例化，放到 handlerMappings 中，并返回实例化的对象。</li></ol><p>在第一步中，直接就获取了一个 handlerMappings，这东西是哪里来的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">getHandlerMappings</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 初始化 Map</span></span><br><span class="line">Map&lt;String, Object&gt; handlerMappings = <span class="built_in">this</span>.handlerMappings;</span><br><span class="line"><span class="keyword">if</span> (handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 同步代码块加锁，防止并发操作</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">handlerMappings = <span class="built_in">this</span>.handlerMappings;</span><br><span class="line"><span class="keyword">if</span> (handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Loading NamespaceHandler mappings from [&quot;</span> + <span class="built_in">this</span>.handlerMappingsLocation + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 加载 properties 文件</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">mappings</span> <span class="operator">=</span></span><br><span class="line">PropertiesLoaderUtils.loadAllProperties(<span class="built_in">this</span>.handlerMappingsLocation, <span class="built_in">this</span>.classLoader);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Loaded NamespaceHandler mappings: &quot;</span> + mappings);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将解析结果放到 map 中</span></span><br><span class="line">handlerMappings = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(mappings.size());</span><br><span class="line">CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);</span><br><span class="line"><span class="built_in">this</span>.handlerMappings = handlerMappings;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line"><span class="string">&quot;Unable to load NamespaceHandler mappings from location [&quot;</span> + <span class="built_in">this</span>.handlerMappingsLocation + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handlerMappings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心在于，handlerMappings 是从 hanlderMappingLocation 这个地方的资源文件中加载出来的。</p><p>DefaultNamespaceHandlerResolver 中的 handlerMappingLocation 默认是 <code>META-INF/spring.handlers</code>。</p><p>在 spring 源码中随便找一个 spring.handlers 文件一探究竟。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/jdbc=org.springframework.jdbc.config.JdbcNamespaceHandler</span><br></pre></td></tr></table></figure><p>上面是 spring-jdbc 模块的 spring.handlers，同时我们也可以知道，spring 家族本身原生的模块，其实也是以自定义标签的形式进行继承的。</p><h2 id="NamespaceHandler"><a href="#NamespaceHandler" class="headerlink" title="NamespaceHandler"></a>NamespaceHandler</h2><p>拿到嘞 NamespaceHandler 之后，就是自定义标签具体的解析流程了，就医 JdbcNamespaceHandler 为例。</p><p>JdbcNamespaceHandler 并非直接实现 NamespaceHandler 接口，而是继承了 <code>NamespaceHandlerSupport</code> 抽象类。</p><pre><code class="highlight mermaid">classDiagramdirection BTclass JdbcNamespaceHandlerclass NamespaceHandler &#123;&lt;&lt;Interface&gt;&gt;&#125;class NamespaceHandlerSupportJdbcNamespaceHandler  --&gt;  NamespaceHandlerSupport NamespaceHandlerSupport  ..&gt;  NamespaceHandler</code></pre><p>而 JdbcNamespaceHandler 本身也只是注册了不同标签的不同解析处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcNamespaceHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;embedded-database&quot;</span>, <span class="keyword">new</span> <span class="title class_">EmbeddedDatabaseBeanDefinitionParser</span>());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;initialize-database&quot;</span>, <span class="keyword">new</span> <span class="title class_">InitializeDatabaseBeanDefinitionParser</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">NamespaceHandlerSupport</span> <span class="keyword">implements</span> <span class="title class_">Namespacehandler</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinitionParser&gt; parsers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitionParser</span><span class="params">(String elementName, BeanDefinitionParser parser)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.parsers.put(elementName, parser);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注册了两个标签对应的解析处理器，是 BeanDefinitionParser 接口的不同实现。</p><p>再看看 NamespaceHandlerSupport 中的 parse 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line"><span class="comment">// 获取解析器</span></span><br><span class="line"><span class="type">BeanDefinitionParser</span> <span class="variable">parser</span> <span class="operator">=</span> findParserForElement(element, parserContext);</span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line"><span class="keyword">return</span> (parser != <span class="literal">null</span> ? parser.parse(element, parserContext) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BeanDefinitionParser <span class="title function_">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line"><span class="comment">// 比如 bean 配置文件中开启事务的注解支持时使用 &lt;tx:annotation-driven&gt;，在这里拿到的 localName 就是 annotation-driven</span></span><br><span class="line"><span class="type">String</span> <span class="variable">localName</span> <span class="operator">=</span> parserContext.getDelegate().getLocalName(element);</span><br><span class="line"><span class="comment">// 通过 localName 获取对应的解析器</span></span><br><span class="line"><span class="type">BeanDefinitionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="built_in">this</span>.parsers.get(localName);</span><br><span class="line"><span class="keyword">if</span> (parser == <span class="literal">null</span>) &#123;</span><br><span class="line">parserContext.getReaderContext().fatal(</span><br><span class="line"><span class="string">&quot;Cannot locate BeanDefinitionParser for element [&quot;</span> + localName + <span class="string">&quot;]&quot;</span>, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里其实就比较明了，其实就是解析出标签的标签名，然后得到标签名对应的处理器，然后直接进行解析得到 BeanDefinition 即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>NamespaceHandlerResolver 维护命名空间和对应的 NamespaceHandler 的映射关系，默认的映射关系配置文件在 <code>META-INF/spring.handlers</code>。</li><li>NamespaceHandler 负责名空间中的各个标签的具体解析逻辑。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码解析：BeanDefinition</title>
      <link href="posts/d13dfeffc92a.html"/>
      <url>posts/d13dfeffc92a.html</url>
      
        <content type="html"><![CDATA[<p>在上一讲中，已经知道了如何加载资源文件，但是事实上加载资源的时候更多的只是拿到资源文件的引用，并没做进一步的内容解析，所以还需要对资源文件进行解析。</p><p>以 ClassPathXmlApplicationContext 为例，从名称上就能知道，它加载的资源文件其实是 xml 配置文件。</p><p>那么具体是如何解析？解析完成之后得到的又是什么呢？</p><p>这就是本文的主题：BeanDefinition。</p><p>总体来讲，其实就是这样一个过程：</p><pre><code class="highlight mermaid">%% graph TD; commentgraph LRxml_file([Xml文件])xml_resource([Xml Resource])xml_document([Xml Document])bean_definition([BeanDefinition])xml_file--&gt;|ResourceLoader|xml_resource--&gt;|DocumentLoader|xml_document--&gt;|BeanDefinitionReader|bean_definition</code></pre><p>其中 ResourceLoader 将 xml 文件加载成为 xml resource 这一步，我们已经讲过。本章将关注 DocumentLoader 将 xml resource 转换为 xml document，以及 BeanDefinitionReader 再将 xml document 转换为 BeanDefinition。</p><p>BeanDefinition 包含了创建一个 bean 所需要的数据，它不是 bean，而是定义一个 bean 所需的数据就在其中。</p><h2 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions()"></a>loadBeanDefinitions()</h2><p>在 AbstractXmlApplicationContext 中，有 loadBeanDefinitions(XmlBeanDefinitionReader reader) 方法，接收一个 XmlBeanDefinitionReader 参数，用来获取 BeanDefinition。</p><blockquote><p>需要知道的是，AbstractXmlApplicationContext 是持有一个 BeanFactory 对象的，初始化时，需要先初始化一个 BeanFactory 的对象，然后才开始解析 BeanDefinition。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line"><span class="comment">// 这里其实是最开始穿配置文件的资源对象</span></span><br><span class="line"><span class="comment">// 这里会判断当前是否拿到了配置资源对象，</span></span><br><span class="line">Resource[] configResources = getConfigResources();</span><br><span class="line"><span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果有，就直接通过资源对象解析 BeanDefinition</span></span><br><span class="line">reader.loadBeanDefinitions(configResources); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否有配置文件的路径信息</span></span><br><span class="line">String[] configLocations = getConfigLocations();</span><br><span class="line"><span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果有，解析 Xml 为 BeanDefinition，这里最终依然会拿到配置文件的配置资源对象，</span></span><br><span class="line"><span class="comment">// 然后调用上面的 loadBeanDefinitions</span></span><br><span class="line"><span class="comment">// 注意这里有两个 loadBeanDefinitions() 方法，但是入参一个是 Resource 对象，</span></span><br><span class="line"><span class="comment">// 一个是配置文件的路径，后者最终依然会调到入参是 Resource 对象的 loadBeanDefinitions()</span></span><br><span class="line">reader.loadBeanDefinitions(configLocations); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会发现有两个地方调用了 reader.loadBeanDefinitions() 方法，只不过入参类型不一样：</p><ol><li><p>XmlBeanDefinitionReader#loadBeanDefinitions(Resource… resources)</p><p>直接传入 Resource 对象进行解析。</p></li><li><p>XmlBeanDefinitionReader#loadBeanDefinitions(String… locations)</p><p>传入的是资源的地址，深入查看会发现其实还是会加载成 Resource 对象后调用第一个方法。</p></li></ol><blockquote><p>当拿到 Resource 对象后，并不是直接就开始解析，而是还使用 EncodedResource 做了一层封装，看名称就知道是为了指定资源的字符编码的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从线程上下文中获取已经开始加载的 EncodingResource 对象</span></span><br><span class="line">Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试将 encodingResource 添加进线程上下文持有的 HashSet 中，如果添加失败，说明存在循环加载，就会直接报错。</span></span><br><span class="line"><span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line"><span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 Resource 对象的 InputStream 输入流，这里需要注意，Resource 接口是继承了 InputStream 接口</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line"><span class="comment">// 转换为 InputSource</span></span><br><span class="line"><span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line"><span class="comment">// 设置编码集</span></span><br><span class="line"><span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 真的加载 BeanDefinition</span></span><br><span class="line"><span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line"><span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 从线程上下文中的 encodingResources 的 HashSet 中移除 </span></span><br><span class="line">currentResources.remove(encodedResource);</span><br><span class="line"><span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line"><span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先会从线程上下文中获取一个用于记录已经开始加载的 EncodedResouce 对象的 HashSet，用于判断是否有循环加载。</li><li>然后获取资源的 InputStream，Resource 接口是继承了 InputStream 接口的，所以这里能直接调用 getInputStream() 方法获取 InputStream。</li><li>然后就是为 xml 的解析做准备，这里采用的是 sax 解析，所以首先将 InputStream 对象转换成了 sax 库的 InputSource 对象，并设置了字符编码集。</li><li>执行 doLoadBeanDefinition() 方法，做进一步处理。这里就是要开始解析 xml 文件，并将得到的 BeanDefnition 进行注册了。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line"><span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 解析 xml 为 Document 对象</span></span><br><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="comment">// 注册 BeanDefinition</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> registerBeanDefinitions(doc, resource);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// catch...异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 doLoadBeanDefinition() 方法中会先解析 InputSource，得到一个 Document 文档对象，再通过文档对象进行 BeanDefinition 的注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"><span class="comment">// 创建 BeanDefinitionDocumentReader</span></span><br><span class="line"><span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line"><span class="comment">// 获取当前已注册的 BeanDefinition 数量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line"><span class="comment">// 解析并注册 BeanDefinition</span></span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个 BeanDefinitionDocumentReader，用于从 Document 对象中读取 BeanDefinition。</p><p>最终会执行到 <code>DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions(Element root)</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line"><span class="comment">// 创建解析器的委托类，具体的解析操作由 BeanDefinitionParserDelegate 完成</span></span><br><span class="line"><span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line"><span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"><span class="comment">// 命名空间是否是默认命名空间：空或者 http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line"><span class="comment">// 获取配置的 profile 属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line"><span class="comment">// 如果有指定 profile, 对 profile 的字符串进行拆解，多个 profile 以英文逗号或分号分隔</span></span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="comment">// 检查是否有指定的 profile 被激活</span></span><br><span class="line"><span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line"><span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预留的 xml 处理前置逻辑，默认是不做任何操作</span></span><br><span class="line">preProcessXml(root);</span><br><span class="line"><span class="comment">// 解析 BeanDefinition</span></span><br><span class="line">parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line"><span class="comment">// 预留的 xml 处理后置逻辑，默认不做任何操作</span></span><br><span class="line">postProcessXml(root);</span><br><span class="line"><span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将解析 xml 的逻辑又委托到了 BeanDefinitionParserDelegate 类中，并且考虑到 <code>&lt;beans&gt;</code> 嵌套的情况，所以初始化 BeanDefinitionParserDelegate 时，还传入了父 BeanDefinitionParserDelegate。</p><p>对于多 profile 的支持，也是在上面获取 beans 标签的 profile 属性部分的逻辑进行支持的。</p><p>然后，再进一步看看 parseBeanDefinitions() 方法的逻辑。</p><h2 id="parseBeanDefinitions"><a href="#parseBeanDefinitions" class="headerlink" title="parseBeanDefinitions()"></a>parseBeanDefinitions()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line"><span class="comment">// 是否是 spring 默认的命名空间</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line"><span class="comment">// 获取子节点列表</span></span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line"><span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line"><span class="comment">// 子节点是否是默认命名空间中的标签</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line"><span class="comment">// 解析默认标签节点</span></span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 自定义标签解析</span></span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 解析自定义标签</span></span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断是否是默认的命名空间，如果是，就调用 spring 的解析逻辑，如果不是，那就证明是第三方集成的组件，需要走到 else 的逻辑，调用第三方自定义的标签解析逻辑。</p><p>而如果是 spring 的默认命名空间，但是子节点的所属命名空间又不在 spring 的命名空间中，依然会走自定义的解析逻辑。</p><p>这里我们首先就需要举个例子了解一下 xml 这个命名空间里命名空间。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-2.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop-2.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context-2.5.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.scheduling.annotation.AsyncAnnotationAdvisor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的 xml 中， 引入的命名空间都在 beans 标签的 xmlns 系列的属性中，除了第一个是默认的，其余的比如 aop、context 命名空间，在使用时，一般都会在标签名前加上所属的命名空间。</p><blockquote><p>这里会发现 spring 有单独的 aop、context 命名空间，也体现了 spring 设计上的解耦。</p></blockquote><p>这样，就能理解前面的关于命名空间的判断逻辑了。</p><p>那么，我们接下来需要看看以下两个方法：</p><ul><li>默认命名空间的标签解析：<code>DefaultBeanDefinitionDocumentReader#parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate)</code></li><li>自定义命名空间的标签解析：<code>BeanDefinitionParserDelegate#parseCustomElement(Element ele)</code></li></ul><p>这里暂时只看默认命名空间的标签解析，自定义标签的解析将在下一篇文章中讲解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line"><span class="comment">// 解析&lt;import&gt;标签</span></span><br><span class="line"><span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// 解析&lt;alias&gt;标签</span></span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// 解析&lt;bean&gt;标签</span></span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// beans 中嵌套了 beans 标签，这里需要递归调用 doRegisterBeanDefinitions 方法</span></span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里引入了 4 种标签的解析：</p><ul><li><p>import</p><p>导入其他的资源文件。</p></li><li><p>alias</p><p>别名。</p></li><li><p>bean</p><p>bean 标签，可解析成一个 BeanDefinition 对象。</p></li><li><p>beans</p><p>相当于在 beans 标签中嵌套了 beans 标签。</p></li></ul><h3 id="import-标签"><a href="#import-标签" class="headerlink" title="import 标签"></a>import 标签</h3><p>Import 标签使用的形式一般如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beanConfigurerTests-beans.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>resource 属性用来指定要导入的资源的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">importBeanDefinitionResource</span><span class="params">(Element ele)</span> &#123;</span><br><span class="line"><span class="comment">// 获取  resource 属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(location)) &#123;</span><br><span class="line"><span class="comment">// resource 属性为空，记录错误，返回</span></span><br><span class="line">getReaderContext().error(<span class="string">&quot;Resource location must not be empty&quot;</span>, ele);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理 resource 属性值中类似 $&#123;user.dir&#125; 这样的变量占位</span></span><br><span class="line">location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);</span><br><span class="line"></span><br><span class="line">Set&lt;Resource&gt; actualResources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Discover whether the location is an absolute or relative URI</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">absoluteLocation</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 判断 resource 配置的是绝对位置还是相对位置</span></span><br><span class="line">absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line"><span class="comment">// cannot convert to an URI, considering the location relative</span></span><br><span class="line"><span class="comment">// unless it is the well-known Spring prefix &quot;classpath*:&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Absolute or relative?</span></span><br><span class="line"><span class="keyword">if</span> (absoluteLocation) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 如果是绝对位置，又回到最初的入参为资源的 location 的 loadBeanDefinitions 方法进行 BeanDefinition 的加载注册</span></span><br><span class="line"><span class="type">int</span> <span class="variable">importCount</span> <span class="operator">=</span> getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Imported &quot;</span> + importCount + <span class="string">&quot; bean definitions from URL location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(</span><br><span class="line"><span class="string">&quot;Failed to import bean definitions from URL location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No URL -&gt; considering resource location as relative to the current file.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 尝试当成相对位置处理</span></span><br><span class="line"><span class="type">int</span> importCount;</span><br><span class="line"><span class="comment">// 通过相对位置加载 Resource，这是 Resource 接口提供的能力，用于创建当前 Resource 相对路径下某资源的 Resource 对象</span></span><br><span class="line"><span class="type">Resource</span> <span class="variable">relativeResource</span> <span class="operator">=</span> getReaderContext().getResource().createRelative(location);</span><br><span class="line"><span class="keyword">if</span> (relativeResource.exists()) &#123;</span><br><span class="line"><span class="comment">// 如果资源对应文件是存在的，就开始加载资源中的 BeanDefinition</span></span><br><span class="line">importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">actualResources.add(relativeResource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果不存在，则直接将资源的绝对路径传到 loadBeanDefinition 方法中，由其内部逻辑进行加载。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">baseLocation</span> <span class="operator">=</span> getReaderContext().getResource().getURL().toString();</span><br><span class="line">importCount = getReaderContext().getReader().loadBeanDefinitions(</span><br><span class="line">StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Imported &quot;</span> + importCount + <span class="string">&quot; bean definitions from relative location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">&quot;Failed to resolve current resource location&quot;</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(</span><br><span class="line"><span class="string">&quot;Failed to import bean definitions from relative location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Resource[] actResArray = actualResources.toArray(<span class="keyword">new</span> <span class="title class_">Resource</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 发布触发导入处理事件</span></span><br><span class="line">getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对 import 标签的解析首先判断了标签的 resource 属性是否有值，如果没有值，会记录错误并解析结束。</li><li>对于 resource 属性的值存在 <code>$&#123;user.dir&#125;</code> 这种情况，需要提前进行处理。</li><li>定义了一个叫做 actualResources 的 Set，用于记录当前这个 import 标签导入的 Resource 对象。</li><li>需要判断 resource 的地址是相对路径还是绝对路径。</li><li>如果是绝对路径，直接调用参数为资源路径字符串的 loadBeanDefinitions 方法进行加载，其实就回到了最开始通过一个资源文件位置来加载 BeanDefinition 的时候了。</li><li>如果不是绝对路径，就当成是相对路径处理，先根据相对路径创建一个 Resource 对象，然后使用 Resource 接口提供的 exists() 方法判断资源文件是否存在，如果存在，则调用 loadBeanDefinitions() 方法，通过 Resource 对象加载 BeanDefinition，如果资源文件不存在，那就是可能是 Resource 类型不对，那就拼接处完整的绝对路径，调用 loadBeanDefinitions() 方法，通过资源文件路径加载 BeanDefinition。</li></ol><p>综上所述，其实最终都还是加载了 resource 对应的 Resource 对象，然后再解析出 BeanDefinition。</p><h3 id="alias-标签"><a href="#alias-标签" class="headerlink" title="alias 标签"></a>alias 标签</h3><p>Alias 标签使用一般如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;testBean&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;testBeanAlias1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>name 属性为要起别名的 bean 的名字，alias 为别名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processAliasRegistration</span><span class="params">(Element ele)</span> &#123;</span><br><span class="line"><span class="comment">// 获取 name 属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"><span class="comment">// 获取 alias 属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">alias</span> <span class="operator">=</span> ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 检查 name 是否有效</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(name)) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">&quot;Name must not be empty&quot;</span>, ele);</span><br><span class="line">valid = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查 alias 是否有效</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(alias)) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">&quot;Alias must not be empty&quot;</span>, ele);</span><br><span class="line">valid = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (valid) &#123;</span><br><span class="line"><span class="comment">// name、alias 都有效</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 注册别名到 BeanFactory 中</span></span><br><span class="line">getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">&quot;Failed to register alias &#x27;&quot;</span> + alias +</span><br><span class="line"><span class="string">&quot;&#x27; for bean with name &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布 alias 标签处理事件</span></span><br><span class="line">getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先获取 <code>&lt;alias&gt;</code> 标签的 name、alias 属性，然后检查是否为空，只要其中有一个为空，解析就结束了。</li><li>name、alias 属性都不为空，则将别名注册到 BeanFactory 中，这里只需要知道在 BeanFactory 中哟一个 Map 专门用来记录每个 bean 的别名，其 key 为别名，value 为真正 bean 的名称。</li><li>发布 alias 标签处理事件。</li></ol><h3 id="beans-标签解析"><a href="#beans-标签解析" class="headerlink" title="beans 标签解析"></a>beans 标签解析</h3><p>其实就是递归调用了 doRegisterBeanDefinitions() 方法而已。</p><h3 id="bean-标签解析"><a href="#bean-标签解析" class="headerlink" title="bean 标签解析"></a>bean 标签解析</h3><p>bean 标签是相当常用的标签了，一般用法示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderedBeforeTransaction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.autoproxy.OrderedTxCheckAdvisor&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>9<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;requireTransactionContext&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解析 bean 标签的逻辑位于 <code>DefaultBeanDefinitionDocumentReader#processBeanDefinition(...) </code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line"><span class="comment">// BeanDefinitionHolder 中保存了 BeanDefinition 和 bean 名称以及别名</span></span><br><span class="line"><span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 解析 xml 中的自定义命名空间（如果有的话）</span></span><br><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Register the final decorated instance.</span></span><br><span class="line"><span class="comment">// 将 BeanDefinition 注册到 BeanFactory 的 beanDefinitionMap</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send registration event. 发送 BeanDefinition 注册完成事件</span></span><br><span class="line">getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 BeanDefinitionParserDelegate#parseBeandDefinition(Element ele) 方法解析标签，得到 BeanDefinitionHolder。</li><li>自定义标签装饰逻辑。</li><li>调用 BeanDefinitionReaderUtils 注册 BeanDefinition，总体来讲就是建立 beanName 和 BeanDefinition 的映射关系，以及 alias 和 beanName 的映射关系。</li></ol><p>会发现这里将解析 BeandDefinition 的逻辑又放到了 <code>BeanDefinitionParserDelegate#parseBeandDefinition(Element ele)</code> 方法中，而且返回的也不是 BeanDefinition，而是 BeanDefinitionHolder 对象，BeanDefinitionHoldern 对象持有一个 BeanDefinition 对象，bean 名称，以及 bean 的别名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinitionHolder</span> <span class="keyword">implements</span> <span class="title class_">BeanMetadataElement</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] aliases;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是针对标签属性的命名空间的自定义解析逻辑，这部分对于自定义命名空间的使用，后文单独讲解。</p><p>这里我们先深入看看 <code>BeanDefinitionParserDelegate#parseBeandDefinition(Element ele)</code> 是如何拿到 BeanDefinitionHolder 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * containingBean 其实是父 bean 的 BeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 id 属性值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 name 属性值，解析成 bean 的别名，多个别名用英文逗号分割</span></span><br><span class="line"><span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line"><span class="comment">// 将多个别名按英文逗号或分号分割</span></span><br><span class="line">String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 id 为空，则取 name 属性中的第一个别名作为默认的 beanName</span></span><br><span class="line"><span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析一个 AbstractBeanDefinition 对象，其实是一个 GenericBeanDefinition 对象</span></span><br><span class="line"><span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"><span class="comment">// 生成默认的 beanName</span></span><br><span class="line"><span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"><span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line"><span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line"><span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line"><span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">!<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">aliases.add(beanClassName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line"><span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">error(ex.getMessage(), ele);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先获取了 bean 标签的 id、name 属性，对于 name 属性存在多个名字的情况，以英文逗号或者分号进行分割。</li><li>默认 beanName 为 id 属性的值，如果 id 属性未配置，则以 name 属性解析出的第一个名称为 beanName，并从 alias 别名列表中移除。</li><li>检查别名和 beanName 是否已经被注册过了，如果是，就会抛出 beanName 冲突异常。</li><li>调用 <code>parseBeanDefinitionElement(...)</code> 方法解析得到 BeanDefinition 对象。</li><li>如果 beanName 为空，则由 BeanFactory 生成一个 beanName。</li><li>最后生成一个 BeanDefinitionHolder 对象并返回。</li></ol><p>然后看看 <code>parseBeanDefinitionElement(...)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractBeanDefinition <span class="title function_">parseBeanDefinitionElement</span><span class="params">(</span></span><br><span class="line"><span class="params">Element ele, String beanName, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">BeanEntry</span>(beanName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 class 属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析 parent 属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建 AbstractBeanDefinition 的子类 GenericBeanDefinition</span></span><br><span class="line"><span class="type">AbstractBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> createBeanDefinition(className, parent);</span><br><span class="line"><span class="comment">// 解析 bean 标签属性</span></span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line"><span class="comment">// 设置 description，通过 &lt;description&gt; 子标签获取</span></span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"><span class="comment">// 解析元数据</span></span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line"><span class="comment">// 解析 lookup-method 子标签</span></span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"><span class="comment">// 解析 replaced-method 子标签</span></span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"><span class="comment">// 解析 constructor-arg 子标签</span></span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line"><span class="comment">// 解析 property 子标签</span></span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line"><span class="comment">// 解析 Qualifier 子节点</span></span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">bd.setResource(<span class="built_in">this</span>.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">error(<span class="string">&quot;Bean class [&quot;</span> + className + <span class="string">&quot;] not found&quot;</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">error(<span class="string">&quot;Class that bean class [&quot;</span> + className + <span class="string">&quot;] depends on not found&quot;</span>, ele, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">error(<span class="string">&quot;Unexpected failure during bean definition parsing&quot;</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先就拿到了 class 属性和 parent 属性的值，然后创建了一个 BeanDefinition。</p></li><li><p>解析 bean 标签的属性。</p></li><li><p>bean 标签的一系列子标签的解析，包括：</p><ol><li>description</li><li>meta</li><li>lookup-method</li><li>replaced-method</li><li>constructor-arg</li><li>property</li><li>qualifier</li></ol></li></ol><p>接下来，会逐步进行分析。</p><h4 id="创建-BeanDefinition"><a href="#创建-BeanDefinition" class="headerlink" title="创建 BeanDefinition"></a>创建 BeanDefinition</h4><p>对应 createBeanDefinition() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title function_">createBeanDefinition</span><span class="params">(<span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> String parentName)</span></span><br><span class="line"><span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">parentName, className, <span class="built_in">this</span>.readerContext.getBeanClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>委托给了 BeanDefinitionReaderUtils 进行创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title function_">createBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> String parentName, <span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">GenericBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">bd.setParentName(parentName);</span><br><span class="line"><span class="keyword">if</span> (className != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">bd.setBeanClassName(className);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时可以得到结论，那就是一开始创建的 BeanDefinition 都是 GenericBeanDefinition。</p><p>这里将 bean 对应的 Class 或者 ClassName 设置了进去。</p><h4 id="解析-bean-标签属性"><a href="#解析-bean-标签属性" class="headerlink" title="解析 bean 标签属性"></a>解析 bean 标签属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractBeanDefinition <span class="title function_">parseBeanDefinitionAttributes</span><span class="params">(Element ele, String beanName,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> BeanDefinition containingBean, AbstractBeanDefinition bd)</span> &#123;</span><br><span class="line"><span class="comment">// singleton 属性已经过时，需要使用 scope 属性</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123;</span><br><span class="line">error(<span class="string">&quot;Old 1.x &#x27;singleton&#x27; attribute in use - upgrade to &#x27;scope&#x27; declaration&quot;</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123;</span><br><span class="line"><span class="comment">// 如果有 scope 属性，就设置 scope</span></span><br><span class="line">bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果没有 scope 属性，但是有父 bean，则使用父 bean 的 scope 值。</span></span><br><span class="line"><span class="comment">// Take default from containing bean in case of an inner bean definition.</span></span><br><span class="line">bd.setScope(containingBean.getScope());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123;</span><br><span class="line"><span class="comment">// 设置是否为抽象，即不会实例化，而只是作为其他 bean 的父类，默认为 false</span></span><br><span class="line">bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">lazyInit</span> <span class="operator">=</span> ele.getAttribute(LAZY_INIT_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (isDefaultValue(lazyInit)) &#123;</span><br><span class="line"><span class="comment">// 是否懒加载，如果设置为 true，则 bean 将会在第一次使用到时由工厂初始化，默认为 false</span></span><br><span class="line">lazyInit = <span class="built_in">this</span>.defaults.getLazyInit();</span><br><span class="line">&#125;</span><br><span class="line">bd.setLazyInit(TRUE_VALUE.equals(lazyInit));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">autowire</span> <span class="operator">=</span> ele.getAttribute(AUTOWIRE_ATTRIBUTE);</span><br><span class="line"><span class="comment">// 设置自动注入模式</span></span><br><span class="line">bd.setAutowireMode(getAutowireMode(autowire));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置依赖的 bean 名称</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">dependsOn</span> <span class="operator">=</span> ele.getAttribute(DEPENDS_ON_ATTRIBUTE);</span><br><span class="line">bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">autowireCandidate</span> <span class="operator">=</span> ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (isDefaultValue(autowireCandidate)) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">candidatePattern</span> <span class="operator">=</span> <span class="built_in">this</span>.defaults.getAutowireCandidates();</span><br><span class="line"><span class="keyword">if</span> (candidatePattern != <span class="literal">null</span>) &#123;</span><br><span class="line">String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);</span><br><span class="line">bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 primary</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(PRIMARY_ATTRIBUTE)) &#123;</span><br><span class="line">bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置初始化方法名</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">initMethodName</span> <span class="operator">=</span> ele.getAttribute(INIT_METHOD_ATTRIBUTE);</span><br><span class="line">bd.setInitMethodName(initMethodName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.defaults.getInitMethod() != <span class="literal">null</span>) &#123;</span><br><span class="line">bd.setInitMethodName(<span class="built_in">this</span>.defaults.getInitMethod());</span><br><span class="line">bd.setEnforceInitMethod(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置销毁 bean 的方法名</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">destroyMethodName</span> <span class="operator">=</span> ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);</span><br><span class="line">bd.setDestroyMethodName(destroyMethodName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.defaults.getDestroyMethod() != <span class="literal">null</span>) &#123;</span><br><span class="line">bd.setDestroyMethodName(<span class="built_in">this</span>.defaults.getDestroyMethod());</span><br><span class="line">bd.setEnforceDestroyMethod(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置工厂方法名称</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置工厂 bean</span></span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) &#123;</span><br><span class="line">bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段是对 <code>&lt;bean&gt;</code> 的各项属性进行解析，并放进 BeanDefinition 中，比较简单，不细说。</p><h4 id="解析-description-标签"><a href="#解析-description-标签" class="headerlink" title="解析 description 标签"></a>解析 description 标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getChildElementValueByTagName</span><span class="params">(Element ele, String childEleName)</span> &#123;</span><br><span class="line"><span class="type">Element</span> <span class="variable">child</span> <span class="operator">=</span> getChildElementByTagName(ele, childEleName);</span><br><span class="line"><span class="keyword">return</span> (child != <span class="literal">null</span> ? getTextValue(child) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title function_">getChildElementByTagName</span><span class="params">(Element ele, String childEleName)</span> &#123;</span><br><span class="line">Assert.notNull(ele, <span class="string">&quot;Element must not be null&quot;</span>);</span><br><span class="line">Assert.notNull(childEleName, <span class="string">&quot;Element name must not be null&quot;</span>);</span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> ele.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; nodeNameMatch(node, childEleName)) &#123;</span><br><span class="line"><span class="keyword">return</span> (Element) node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是找了一个 bean 标签下名为 <code>description</code> 的子标签，然后拿了标签中的值设置到了 BeanDefinition 中。</p><h4 id="解析-meta-标签"><a href="#解析-meta-标签" class="headerlink" title="解析 meta 标签"></a>解析 meta 标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMetaElements</span><span class="params">(Element ele, BeanMetadataAttributeAccessor attributeAccessor)</span> &#123;</span><br><span class="line">   <span class="comment">// ele 是 meta 的父标签</span></span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> ele.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line"><span class="comment">// 是 Spring 默认标签体系中的标签，且为 &lt;meta&gt; 标签</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line"><span class="type">Element</span> <span class="variable">metaElement</span> <span class="operator">=</span> (Element) node;</span><br><span class="line"><span class="comment">// 获取 key 属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> metaElement.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line"><span class="comment">// 获取 value 属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> metaElement.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line"><span class="type">BeanMetadataAttribute</span> <span class="variable">attribute</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanMetadataAttribute</span>(key, value);</span><br><span class="line">attribute.setSource(extractSource(metaElement));</span><br><span class="line">attributeAccessor.addMetadataAttribute(attribute);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>meta 标签使用一般如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">&quot;priority&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再对照上面的代码。</p><ol><li>ele 是 meta 的父标签，首先获取了 ele 的子标签的列表；</li><li>然后再进行遍历，遍历时，判断了是否是 meta 标签；</li><li>如果是 meta 标签，则获取 meta 标签的 key、value 属性，并构建一个 BeanMetadataAttribute，放到 BeanDefinition 中。</li></ol><p>需要注意的是，第 3 步说的是放到 BeanDefinition 中，但实际又是调用的 BeanMetadataAttributeAccessor 实例的方法，其实是因为前面构建的 GenericBeanDefinition 继承自 AbstractBeanDefinition，而 AbstractBeanDefinition 又实现了 BeanMetadataAttributeAccessor 接口。</p><pre><code class="highlight mermaid">classDiagramdirection BTclass AbstractBeanDefinitionclass AttributeAccessorSupportclass BeanDefinition &#123;&lt;&lt;Interface&gt;&gt;&#125;class BeanMetadataAttributeAccessorclass GenericBeanDefinitionclass Serializable &#123;&lt;&lt;Interface&gt;&gt;&#125;AbstractBeanDefinition  ..&gt;  BeanDefinition AbstractBeanDefinition  --&gt;  BeanMetadataAttributeAccessor AttributeAccessorSupport  ..&gt;  Serializable BeanMetadataAttributeAccessor  --&gt;  AttributeAccessorSupport GenericBeanDefinition  --&gt;  AbstractBeanDefinition </code></pre><p>BeanMetadataAttributeAccessor 提供的是访问 bean 元数据的能力，而最终实现时，其实就是将各种元数据记录了下来，就如同上面讲 meta 标签的 key、value 封装成一个 BeanMetadataAttribute 对象，然后放到了 BeanMetadataAttributeAccessor 中，换言之，对元数据的访问能力不是 BeanDefinition 接口提供的，而是 BeanMetadataAttributeAccessor 提供的。</p><h4 id="解析-lookup-method-标签"><a href="#解析-lookup-method-标签" class="headerlink" title="解析 lookup-method 标签"></a>解析 lookup-method 标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseLookupOverrideSubElements</span><span class="params">(Element beanEle, MethodOverrides overrides)</span> &#123;</span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> beanEle.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line"><span class="comment">// lookup-method 标签解析</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) &#123;</span><br><span class="line"><span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line"><span class="comment">// lookup 的方法名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"><span class="comment">// lookup 返回的 bean</span></span><br><span class="line"><span class="type">String</span> <span class="variable">beanRef</span> <span class="operator">=</span> ele.getAttribute(BEAN_ELEMENT);</span><br><span class="line"><span class="type">LookupOverride</span> <span class="variable">override</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LookupOverride</span>(methodName, beanRef);</span><br><span class="line">override.setSource(extractSource(ele));</span><br><span class="line">overrides.addOverride(override);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>lookup-method 平时用的比较少，也是查了资料才知道是干嘛的。</p></blockquote><p>lookup-mthod 一般用法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;overrideInheritedMethod&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.xml.OverrideOneMethodSubclass&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">&quot;getPrototypeDependency&quot;</span> <span class="attr">bean</span>=<span class="string">&quot;jenny&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这样用，其实就是使得 overrideInheritedMethod 这个 bean 的 getPrototypeDependency 方法最终返回 jenny 这个 bean，意思是，哪怕 getPrototypeDependency 方法的实现逻辑上是构建了一个和 jenny 这个 bean 同类型的对象返回，但调用 overrideInheritedMethod 的 getPrototypeDependency 方法最终还是会返回 jenny 这个实例 bean。</p><blockquote><p>就有点强行修改 bean 方法的返回对象的意思。</p></blockquote><p>和解析 meta 标签类似，这里也是将 lookup-method 的key、value 封装之后，又放到了一个 BeaDefinition 的对象中，只不过依然不是调用的 BeanDefinition 接口的能力，而是 MethodOverrides 接口的能力，这个接口用来记录 bean 中的方法覆盖。</p><p>注意 lookup-method 对应的方法覆盖的记录使用的是 LookupOverride 对象。</p><pre><code class="highlight mermaid">classDiagramdirection BTclass BeanMetadataElement &#123;&lt;&lt;Interface&gt;&gt;&#125;class LookupOverrideclass MethodOverrideclass ReplaceOverrideLookupOverride  --&gt;  MethodOverride MethodOverride  ..&gt;  BeanMetadataElement ReplaceOverride  --&gt;  MethodOverride </code></pre><p>然后就会发现它实现的是 MethodOverride 接口，而这个接口只有 LookupOverride、ReplaceOverride 两个实现类，接下里的 replaced-method 标签就和 ReplaceOverride 有关。</p><h4 id="解析-replaced-method-标签"><a href="#解析-replaced-method-标签" class="headerlink" title="解析 replaced-method 标签"></a>解析 replaced-method 标签</h4><p>replaced-method 标签和 lookup-method 标签类似，不过 replaced-method 标签的切入更加彻底。</p><p>一般使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;overrideOneMethodByAttribute&quot;</span> class=<span class="string">&quot;org.springframework.beans.factory.xml.OverrideOneMethod&quot;</span>&gt;</span><br><span class="line">&lt;replaced-method name=<span class="string">&quot;replaceMe&quot;</span> replacer=<span class="string">&quot;reverseReplacer&quot;</span>&gt;&lt;/replaced-method&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;overrideOneMethodByElement&quot;</span> class=<span class="string">&quot;org.springframework.beans.factory.xml.OverrideOneMethod&quot;</span>&gt;</span><br><span class="line">&lt;replaced-method name=<span class="string">&quot;replaceMe&quot;</span> replacer=<span class="string">&quot;reverseReplacer&quot;</span>&gt;</span><br><span class="line">&lt;arg-type&gt;String&lt;/arg-type&gt;</span><br><span class="line">&lt;/replaced-method&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>第一个 bean 中的 replaced-method 表示将 overrideOneMethodByAttribute 这个 bean 的 replaceMe 方法的实现直接替换成 reverseReplacer 中的方法，而对于 reverseReplacer 方法的要求是，必须实现 MethodReplacer 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodReplacer</span> &#123;</span><br><span class="line">Object <span class="title function_">reimplement</span><span class="params">(Object obj, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析-constructor-arg-标签"><a href="#解析-constructor-arg-标签" class="headerlink" title="解析 constructor-arg 标签"></a>解析 constructor-arg 标签</h4><p>constructor-arg 见名知意，这个标签是用来配置 bean 初始化时的构造函数参数的。</p><p>需要知道 constructor-arg 标签的用法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;parentWithMapInConstructor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.testfixture.beans.TestBean&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span> <span class="attr">...</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;Rob&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Sall&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;Juergen&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Eva&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;b&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要分两种方式，一种是直接指定 index 属性，以表明是配置的构造函数的第几个参数，另一种则是不指定 index，而制定参数名称、值等。</p><p>Spring 在解析时，也是分成了这两种情况进行解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseConstructorArgElement</span><span class="params">(Element ele, BeanDefinition bd)</span> &#123;</span><br><span class="line"><span class="comment">// 参数索引下标</span></span><br><span class="line"><span class="type">String</span> <span class="variable">indexAttr</span> <span class="operator">=</span> ele.getAttribute(INDEX_ATTRIBUTE);</span><br><span class="line"><span class="comment">// 参数类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">typeAttr</span> <span class="operator">=</span> ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line"><span class="comment">// 参数名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"><span class="comment">// 如果指定了 index</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(indexAttr)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.parseInt(indexAttr);</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">error(<span class="string">&quot;&#x27;index&#x27; cannot be lower than 0&quot;</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">ConstructorArgumentEntry</span>(index));</span><br><span class="line"><span class="comment">// 解析属性值对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> parsePropertyValue(ele, bd, <span class="literal">null</span>);</span><br><span class="line">ConstructorArgumentValues.<span class="type">ValueHolder</span> <span class="variable">valueHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstructorArgumentValues</span>.ValueHolder(value);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">valueHolder.setType(typeAttr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">valueHolder.setName(nameAttr);</span><br><span class="line">&#125;</span><br><span class="line">valueHolder.setSource(extractSource(ele));</span><br><span class="line"><span class="keyword">if</span> (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) &#123;</span><br><span class="line">error(<span class="string">&quot;Ambiguous constructor-arg entries for index &quot;</span> + index, ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 将值记录到 BeanDefinition 的构造函数参数列表中</span></span><br><span class="line">bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">error(<span class="string">&quot;Attribute &#x27;index&#x27; of tag &#x27;constructor-arg&#x27; must be an integer&quot;</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 对于标签没有指定 index 的情况</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">ConstructorArgumentEntry</span>());</span><br><span class="line"><span class="comment">// 解析标签中的值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> parsePropertyValue(ele, bd, <span class="literal">null</span>);</span><br><span class="line">ConstructorArgumentValues.<span class="type">ValueHolder</span> <span class="variable">valueHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstructorArgumentValues</span>.ValueHolder(value);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">valueHolder.setType(typeAttr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">valueHolder.setName(nameAttr);</span><br><span class="line">&#125;</span><br><span class="line">valueHolder.setSource(extractSource(ele));</span><br><span class="line">bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取了标签的 index、type、name 三个属性，对于有 index 和没有 index 属性两种情况分开处理，可以看见有没有 index 属性，其实解析逻辑差别不大，只不过有 index 时，记录了 index 和参数值的对应关系。</p><p>不管有没有 index，都会调用 parsePropertyValue 方法解析出值，然后使用 ConstructorArgumentValues.ValueHolder 进行封装。</p><p>然后看看具体的参数值的解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">parsePropertyValue</span><span class="params">(Element ele, BeanDefinition bd, <span class="meta">@Nullable</span> String propertyName)</span> &#123;</span><br><span class="line"><span class="comment">// 如果是解析 constructor-arg 标签，则不会传入 propertyName 参数，如果传了表示是解析的 property 标签</span></span><br><span class="line"><span class="type">String</span> <span class="variable">elementName</span> <span class="operator">=</span> (propertyName != <span class="literal">null</span> ?</span><br><span class="line"><span class="string">&quot;&lt;property&gt; element for property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span> :</span><br><span class="line"><span class="string">&quot;&lt;constructor-arg&gt; element&quot;</span>);</span><br><span class="line"><span class="comment">// 获取子标签</span></span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> ele.getChildNodes();</span><br><span class="line"><span class="type">Element</span> <span class="variable">subElement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line"><span class="comment">// 除了 description、meta 子标签，其他子标签总数不能超过一个</span></span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;</span><br><span class="line">!nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// Child element is what we&#x27;re looking for.</span></span><br><span class="line"><span class="keyword">if</span> (subElement != <span class="literal">null</span>) &#123;</span><br><span class="line">error(elementName + <span class="string">&quot; must not contain more than one sub-element&quot;</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">subElement = (Element) node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否有 ref 属性</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasRefAttribute</span> <span class="operator">=</span> ele.hasAttribute(REF_ATTRIBUTE);</span><br><span class="line"><span class="comment">// 是否有 value 属性</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasValueAttribute</span> <span class="operator">=</span> ele.hasAttribute(VALUE_ATTRIBUTE);</span><br><span class="line"><span class="comment">// 不能同时有 ref 和 value 两个属性，这两个属性只有其中一个时不能有子节点</span></span><br><span class="line"><span class="keyword">if</span> ((hasRefAttribute &amp;&amp; hasValueAttribute) ||</span><br><span class="line">((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != <span class="literal">null</span>)) &#123;</span><br><span class="line">error(elementName +</span><br><span class="line"><span class="string">&quot; is only allowed to contain either &#x27;ref&#x27; attribute OR &#x27;value&#x27; attribute OR sub-element&quot;</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hasRefAttribute) &#123;</span><br><span class="line"><span class="comment">// 获取 ref 属性值。有 ref 属性，一般是指向其他的 bean</span></span><br><span class="line"><span class="type">String</span> <span class="variable">refName</span> <span class="operator">=</span> ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">error(elementName + <span class="string">&quot; contains empty &#x27;ref&#x27; attribute&quot;</span>, ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先将这个 bean 的引用记录起来</span></span><br><span class="line"><span class="type">RuntimeBeanReference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(refName);</span><br><span class="line">ref.setSource(extractSource(ele));</span><br><span class="line"><span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (hasValueAttribute) &#123;</span><br><span class="line"><span class="comment">// 创建一个 String 值</span></span><br><span class="line"><span class="type">TypedStringValue</span> <span class="variable">valueHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypedStringValue</span>(ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">valueHolder.setSource(extractSource(ele));</span><br><span class="line"><span class="keyword">return</span> valueHolder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (subElement != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 当 constructor-arg 标签没有 value、ref 属性时，又会有子标签</span></span><br><span class="line"><span class="comment">// 开始解析子标签</span></span><br><span class="line"><span class="keyword">return</span> parsePropertySubElement(subElement, bd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found.</span></span><br><span class="line">error(elementName + <span class="string">&quot; must specify a ref or value&quot;</span>, ele);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先判断了 peopertyName 参数是否是 null，如果是 null 说明是解析的 constructor-arg 参数，不然就是 property 参数。</li></ol><blockquote><p>这里是框架的代码，到时情有可原，毕竟每个方法调用都是一次进出栈操作。如果是业务代码的话，个人不是很赞同这种实现方式，直接将 constructor-arg 和 property 标签的解析逻辑分开，公共部分抽一个方法就好了啊。</p></blockquote><ol start="2"><li><p>遍历了所有子标签，需要保证 constructor-arg 标签的子标签除了 description 和 meta 标签之外，其他子标签最多只有一个。</p></li><li><p>解析标签。</p><p>如果 constructor-arg 标签有 ref 属性或 value 属性，则进行对应的封装，且 ref、value 属性只能有其中一个。</p><p>如果配置了 ref 属性，则封装成 RuntimeBeanReference，如果配置的是 value 属性，则封装成 TypedStringValue。</p><p>对于 ref、value 都未配置的情况，需要检查是否有既不是 description，又不是 meta 标签的子标签，如果没有，则报错，如果有，则解析子标签。</p></li></ol><p>解析子标签，和对 ref、value 两个属性的解析目的一致，都是为了得到构造函数的属性值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">parsePropertySubElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition bd, <span class="meta">@Nullable</span> String defaultValueType)</span> &#123;</span><br><span class="line"><span class="comment">// 如果不是默认的命名空间的标签，则进行自定义标签解析</span></span><br><span class="line"><span class="keyword">if</span> (!isDefaultNamespace(ele)) &#123;</span><br><span class="line"><span class="keyword">return</span> parseNestedCustomElement(ele, bd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// 如果是 bean 标签，则递归调用解析 BeanDefinition</span></span><br><span class="line"><span class="type">BeanDefinitionHolder</span> <span class="variable">nestedBd</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, bd);</span><br><span class="line"><span class="keyword">if</span> (nestedBd != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 修饰 BeanDefinition</span></span><br><span class="line">nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nestedBd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, REF_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// 解析 ref 标签</span></span><br><span class="line"><span class="comment">// 获取 ref 标签的 bean 属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">refName</span> <span class="operator">=</span> ele.getAttribute(BEAN_REF_ATTRIBUTE);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">toParent</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line"><span class="comment">// A reference to the id of another bean in a parent context.</span></span><br><span class="line"><span class="comment">// 如果没配置 bean 属性，则尝试从读取 parent 属性，然后从父 context 中获取 bean</span></span><br><span class="line">refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);</span><br><span class="line">toParent = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line"><span class="comment">// 如果 bean、parent 两个属性都没配置，报错</span></span><br><span class="line">error(<span class="string">&quot;&#x27;bean&#x27; or &#x27;parent&#x27; is required for &lt;ref&gt; element&quot;</span>, ele);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里我理解是为了检查 bean 或者 parent 的值是空格的情况</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">error(<span class="string">&quot;&lt;ref&gt; element contains empty target attribute&quot;</span>, ele);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">RuntimeBeanReference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(refName, toParent);</span><br><span class="line">ref.setSource(extractSource(ele));</span><br><span class="line"><span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// 解析 &lt;idref&gt; 标签</span></span><br><span class="line"><span class="keyword">return</span> parseIdRefElement(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// 解析 value 标签</span></span><br><span class="line"><span class="keyword">return</span> parseValueElement(ele, defaultValueType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, NULL_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// It&#x27;s a distinguished null value. Let&#x27;s wrap it in a TypedStringValue</span></span><br><span class="line"><span class="comment">// object in order to preserve the source location.</span></span><br><span class="line"><span class="comment">// 用于占位的 null 值</span></span><br><span class="line"><span class="type">TypedStringValue</span> <span class="variable">nullHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypedStringValue</span>(<span class="literal">null</span>);</span><br><span class="line">nullHolder.setSource(extractSource(ele));</span><br><span class="line"><span class="keyword">return</span> nullHolder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// 解析 array 子标签</span></span><br><span class="line"><span class="keyword">return</span> parseArrayElement(ele, bd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, LIST_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// 解析 list 标签，和 array 一样</span></span><br><span class="line"><span class="keyword">return</span> parseListElement(ele, bd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, SET_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// 解析 set 标签</span></span><br><span class="line"><span class="keyword">return</span> parseSetElement(ele, bd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, MAP_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// 解析 map 标签</span></span><br><span class="line"><span class="keyword">return</span> parseMapElement(ele, bd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// 解析 props 标签, 这里是对 property 标签的支持</span></span><br><span class="line"><span class="keyword">return</span> parsePropsElement(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">error(<span class="string">&quot;Unknown property sub-element: [&quot;</span> + ele.getNodeName() + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从解析子标签的逻辑上看，子标签可以是自定义标签，如果是自定义标签，就会调用自定义标签的解析逻辑。对于 spring 默认支持的标签有：</p><ul><li>ref</li><li>idref</li><li>value</li><li>null</li><li>array</li><li>list</li><li>set</li><li>map</li><li>props</li></ul><p>具体每个标签的解析就不展开了，其实也是比较简单的。</p><h4 id="解析-property-标签"><a href="#解析-property-标签" class="headerlink" title="解析 property 标签"></a>解析 property 标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parsePropertyElements</span><span class="params">(Element beanEle, BeanDefinition bd)</span> &#123;</span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> beanEle.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;</span><br><span class="line">parsePropertyElement((Element) node, bd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先遍历了 bean 标签的所有子标签，找到 property 标签，并调用 parsePropertyElement 方法进行解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parsePropertyElement</span><span class="params">(Element ele, BeanDefinition bd)</span> &#123;</span><br><span class="line"><span class="comment">// 获取 property 的 name 属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(propertyName)) &#123;</span><br><span class="line">error(<span class="string">&quot;Tag &#x27;property&#x27; must have a &#x27;name&#x27; attribute&quot;</span>, ele);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">PropertyEntry</span>(propertyName));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bd.getPropertyValues().contains(propertyName)) &#123;</span><br><span class="line">error(<span class="string">&quot;Multiple &#x27;property&#x27; definitions for property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span>, ele);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析属性值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> parsePropertyValue(ele, bd, propertyName);</span><br><span class="line"><span class="type">PropertyValue</span> <span class="variable">pv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyValue</span>(propertyName, val);</span><br><span class="line">parseMetaElements(ele, pv);</span><br><span class="line">pv.setSource(extractSource(ele));</span><br><span class="line">bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先获取 property 标签的 name 属性，该属性必须配置且不能为空。</li><li>调用 parsePropertyValue 方法解析，这里和解析 constructor-arg 标签时使用的是同一个方法，不同的是这里将 propertyName 传了进去，但也只是用来打了错误日志而已，逻辑上没有区别。</li><li>得到 property 的值之后，封装为 PropertyValue 并放到 Beanefinition 中。</li></ol><h4 id="解析-qualifier-标签"><a href="#解析-qualifier-标签" class="headerlink" title="解析 qualifier 标签"></a>解析 qualifier 标签</h4><p>qualifier 标签和 @Qualifier 注解一样，用于根据 bean 名称指定要注入的 bean。</p><p>解析逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseQualifierElement</span><span class="params">(Element ele, AbstractBeanDefinition bd)</span> &#123;</span><br><span class="line"><span class="comment">// 获取 qualifier 标签的 type 属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(typeName)) &#123;</span><br><span class="line">error(<span class="string">&quot;Tag &#x27;qualifier&#x27; must have a &#x27;type&#x27; attribute&quot;</span>, ele);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">QualifierEntry</span>(typeName));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">AutowireCandidateQualifier</span> <span class="variable">qualifier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowireCandidateQualifier</span>(typeName);</span><br><span class="line">qualifier.setSource(extractSource(ele));</span><br><span class="line"><span class="comment">// 获取 value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> ele.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(value)) &#123;</span><br><span class="line">qualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> ele.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) &#123;</span><br><span class="line"><span class="type">Element</span> <span class="variable">attributeEle</span> <span class="operator">=</span> (Element) node;</span><br><span class="line"><span class="comment">// 获取 attribute 子标签的 key、value 属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">attributeName</span> <span class="operator">=</span> attributeEle.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line"><span class="type">String</span> <span class="variable">attributeValue</span> <span class="operator">=</span> attributeEle.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(attributeName) &amp;&amp; StringUtils.hasLength(attributeValue)) &#123;</span><br><span class="line"><span class="type">BeanMetadataAttribute</span> <span class="variable">attribute</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanMetadataAttribute</span>(attributeName, attributeValue);</span><br><span class="line">attribute.setSource(extractSource(attributeEle));</span><br><span class="line">qualifier.addMetadataAttribute(attribute);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">error(<span class="string">&quot;Qualifier &#x27;attribute&#x27; tag must have a &#x27;name&#x27; and &#x27;value&#x27;&quot;</span>, attributeEle);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bd.addQualifier(qualifier);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Qualifier 标签解析后，得到 AutowiredCandidateQualifier 对象，并通过  AbstractBeanDefinition.addQualifier 方法放到 BeanDefinition 中。</p><ol><li><p>首先检查了 type 属性，该属性必须配置，且不能为空。</p></li><li><p>获取 value 属性值，如果值不为空，则将 AutowiredCandidateQualifier 的 value 设置为标签的 value 值。</p></li><li><p>解析 attribute 子标签。</p><p>attribute 子标签有 key、value 属性，两个属性都是必填项，解析后封装成 BeanMetadataAttribute 对象，并通过 AutowiredCandidateQualifier 的 addMetadataAttribute 方法放到 AutowiredCandidateQualifier 中。</p></li></ol><p>到这里，BeanDefinition 的解析基本就结束了，下一篇将讲解自定义标签的解析。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码解析：资源加载</title>
      <link href="posts/1a1a583d59ee.html"/>
      <url>posts/1a1a583d59ee.html</url>
      
        <content type="html"><![CDATA[<p>Spring 中的资源抽象为 Resource 接口，对应的加载器为 ResourceLoader 接口。</p><h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Resource</span> <span class="keyword">extends</span> <span class="title class_">InputStreamSource</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断文件是否存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示资源是否可以通过 getInputStream() 读取非空内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isReadable</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> exists();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示资源是否能获取一个 open 流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源是否为文件系统中的文件类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回资源的 URL 句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">URL <span class="title function_">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回资源的 URI 句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">URI <span class="title function_">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取资源的文件句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">File <span class="title function_">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个 ReadableByteChannel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> ReadableByteChannel <span class="title function_">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="keyword">return</span> Channels.newChannel(getInputStream());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine the content length for this resource.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if the resource cannot be resolved</span></span><br><span class="line"><span class="comment"> * (in the file system or as some other known physical resource type)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取最后一次修改的时间戳</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据资源相对路径创建资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Resource <span class="title function_">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文件名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">String <span class="title function_">getFilename</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取资源描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Resource 类图如下：</p><pre><code class="highlight mermaid">classDiagramdirection BTclass AbstractResourceclass ByteArrayResourceclass ClassPathResourceclass FileSystemResourceclass FileUrlResourceclass InputStreamResourceclass InputStreamSource &#123;&lt;&lt;Interface&gt;&gt;&#125;class Resource &#123;&lt;&lt;Interface&gt;&gt;&#125;class UrlResourceAbstractResource  ..&gt;  Resource ByteArrayResource  --&gt;  AbstractResource ClassPathResource  --&gt;  AbstractResource FileSystemResource  --&gt;  AbstractResource FileSystemResource  ..&gt;  Resource FileUrlResource  ..&gt;  Resource FileUrlResource  --&gt;  UrlResource InputStreamResource  --&gt;  AbstractResource Resource  --&gt;  InputStreamSource UrlResource  --&gt;  AbstractResource </code></pre><p>Resource 根据不同的资源类型，提供了不同的资源实现类。</p><ul><li><p>AbstractResource</p><p>Resource 接口默认的抽象实现，实现了大部分的 Resource 中的方法，如果要新增新的资源类型，需要实现 AbstractResource 类，而不是实现 Resource 接口。</p></li><li><p>FileSystemResource</p><p>对 File 类型资源的封装，且实现了 WritableResource 接口。在 Spring 5.0 开始，通过 NIO.2 的 API 进行读写交互，在 Spring 5.1 开始，可能是使用 java.mio.file.Path 进行构造，这种情况下，都是通过 NIO.2 进行交互，除了通过 getFile() 方法获取 File 对象。</p></li><li><p>ByteArrayResource</p><p>对字节数组的资源进行封装。</p></li><li><p>UrlResource</p><p>对 java.net.URL 类型资源进行封装。</p></li><li><p>ClassPathResource</p><p>对 classpath 类型的资源进行封装，使用给定的 Classloader 或者给定的 Class 加载资源。</p></li><li><p>InputStreamResource</p><p>对给定的 InputStream 进行封装。</p></li></ul><h2 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Pseudo URL prefix for loading from the class path: &quot;classpath:&quot;. */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">CLASSPATH_URL_PREFIX</span> <span class="operator">=</span> ResourceUtils.CLASSPATH_URL_PREFIX;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据文件位置获取对应的 Resource 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Resource <span class="title function_">getResource</span><span class="params">(String location)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回该 ResourceLoader 所使用的 ClassLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code class="highlight mermaid">classDiagramdirection BTclass ClassRelativeResourceLoaderclass DefaultResourceLoaderclass FileSystemResourceLoaderclass PathMatchingResourcePatternResolverclass ResourceLoader &#123;&lt;&lt;Interface&gt;&gt;&#125;class ResourcePatternResolver &#123;&lt;&lt;Interface&gt;&gt;&#125;class ServletContextResourceLoaderClassRelativeResourceLoader  --&gt;  DefaultResourceLoader DefaultResourceLoader  ..&gt;  ResourceLoader FileSystemResourceLoader  --&gt;  DefaultResourceLoader PathMatchingResourcePatternResolver  ..&gt;  ResourcePatternResolver ResourcePatternResolver  --&gt;  ResourceLoader ServletContextResourceLoader  --&gt;  DefaultResourceLoader </code></pre><p>先前已经讲过，ResourceLoader 接口提供了加载资源的能力，不同的资源类型对应不同的 ResourceLoader 实现类。</p><h3 id="DefaultResourceLoader"><a href="#DefaultResourceLoader" class="headerlink" title="DefaultResourceLoader"></a>DefaultResourceLoader</h3><p>ResourceLoader 接口有默认实现类 DefaultResourceLoader。</p><p>先看看 DefaultResourceLoader.getResource() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Resource <span class="title function_">getResource</span><span class="params">(String location)</span> &#123;</span><br><span class="line">Assert.notNull(location, <span class="string">&quot;Location must not be null&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 提供 ProtocolResolver 接口进行扩展，自定义获取资源的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123;</span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> protocolResolver.resolve(location, <span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">if</span> (resource != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对于以 / 开头的文件地址，返回 ClassPathContextResource</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (location.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对于以 classpath: 开头的文件地址，返回 ClassPathResource</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Try to parse the location as a URL...</span></span><br><span class="line"><span class="comment">/* 尝试将地址当成 URL 进行处理 */</span></span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(location);</span><br><span class="line"><span class="comment">/* 如果是文件协议，则返回 FileUrlResource，否则返回 UrlResource */</span></span><br><span class="line"><span class="keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="keyword">new</span> <span class="title class_">FileUrlResource</span>(url) : <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line"><span class="comment">// No URL -&gt; resolve as resource path.</span></span><br><span class="line"><span class="comment">// 如果当成 url 也无法解析，则默认返回 ClassPathContextResource</span></span><br><span class="line"><span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultResourceLoader 是默认的 ResourceLoader 实现类，同时也支持了多种地址格式的加载。</p><p>需要注意的是对于想要自定义 Resource 加载逻辑的情况，并不需要再去实现 ResourceLoader 接口，而是实现 <code>ProtocolResolver</code> 接口来进行扩展，然后调用<code>DefaultResourceLoader.addProtocolResolver(ProtocolResolver resolver)</code> 方法进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProtocolResolver</span> &#123;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Resource <span class="title function_">resolve</span><span class="params">(String location, ResourceLoader resourceLoader)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及，比较奇怪的点是当路径以 <code>/</code> 开头时，返回的是 ClassPathContextResource，这个时候难道不应该是一个 FileSystemContextResource 吗？</p><p>所以，还提供了 FileSystemResourceLoader 类。</p><h3 id="FileSystemResourceLoader"><a href="#FileSystemResourceLoader" class="headerlink" title="FileSystemResourceLoader"></a>FileSystemResourceLoader</h3><p>FileSystemResourceLoader 继承 DefaultResourceLoader 类，重写了 getResourceByPath() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Resource <span class="title function_">getResourceByPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (path.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">path = path.substring(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileSystemContextResource</span>(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的不是 FileSystemResource，而是其子类 FileSystemContextResource，因为 FileSystemContextResource 实现了 ContextResource 的 getPathWithinContext() 方法用来返回资源位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPathWithinContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getPath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说实话我不知道实现这个有啥用。</p></blockquote><h3 id="PathMatchingResourcePatternResolver"><a href="#PathMatchingResourcePatternResolver" class="headerlink" title="PathMatchingResourcePatternResolver"></a>PathMatchingResourcePatternResolver</h3><p>我们查看 ClassPathXmlApplicationContext 的源码会发现，它初始化的时候，并不是直接使用了 DefaultResourceLoader 类，而是初始化的 <code>PathMatchingResourcePatternResolver</code> 类，在构建 PathMatchingResourcePatternResolver 时又直接初始化了一个 DefaultResourceLoader：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PathMatchingResourcePatternResolver</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.resourceLoader = <span class="keyword">new</span> <span class="title class_">DefaultResourceLoader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 PathMatchingResourcePatternResolver 实现了 ResourcePatternResolver 接口，ResourcePatternResolver 接口继承了 ResourceLoader 接口，只是在 ResourceLoader 接口基础上增加了返回一个 Resource 数组的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourcePatternResolver</span> <span class="keyword">extends</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从这里就可以知道对 classpath*: 这种写法的支持，就是由 ResourcePatternResolver 提供的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">CLASSPATH_ALL_URL_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 locationPattern 进行匹配获取 Resource 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再看看 PathMatchingResourcePatternResolver 如何实现 getResources(String locationPattern) 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">Assert.notNull(locationPattern, <span class="string">&quot;Location pattern must not be null&quot;</span>);</span><br><span class="line"><span class="comment">// 判断 locationPattern 是否以 classpath*: 开头</span></span><br><span class="line"><span class="keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;</span><br><span class="line"><span class="comment">// 判断是否为 classpath resource（也可能存在多个同名文件）</span></span><br><span class="line"><span class="comment">// PathMatcher 默认为 AntPathMatcher，支持 ant 风格</span></span><br><span class="line"><span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;</span><br><span class="line"><span class="comment">// a class path resource pattern</span></span><br><span class="line"><span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// all class path resources with the given name</span></span><br><span class="line"><span class="keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Generally only look for a pattern after a prefix here,</span></span><br><span class="line"><span class="comment">// and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol.</span></span><br><span class="line"><span class="type">int</span> <span class="variable">prefixEnd</span> <span class="operator">=</span> (locationPattern.startsWith(<span class="string">&quot;war:&quot;</span>) ? locationPattern.indexOf(<span class="string">&quot;*/&quot;</span>) + <span class="number">1</span> :</span><br><span class="line">locationPattern.indexOf(<span class="string">&#x27;:&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line"><span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 对于不是 classpath*: 开头且不以 war 开头，还不包含 * 和 &#123;&#125; 的路径，采直接使用默认加载器加载单个资源文件</span></span><br><span class="line"><span class="comment">// 这里的默认加载器是初始化PathMatchingResourcePatternResolver时指定的，如果未指定则是 DefaultResourceLoader</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Resource</span>[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 getPathMatcher() 默认返回的是 AntPathMatcher，也是通过 AntPathMatcher 支持 ant 风格的路径。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码解析：IOC 容器概述</title>
      <link href="posts/7eab7c70d847.html"/>
      <url>posts/7eab7c70d847.html</url>
      
        <content type="html"><![CDATA[<h2 id="IOC-容器"><a href="#IOC-容器" class="headerlink" title="IOC 容器"></a>IOC 容器</h2><p>IOC 全程 Inversion Of Control，可翻译控制反转，其最显著的功能是依赖注入。</p><p>在没有 IOC 的情况下，在对象 A 中要使用对象 B，那对象 A 就必须要显示的运行一次 B 的实例化过程，换句话讲 A 必须知道要如何实例化一个对象 B。</p><p>有了 IOC 之后，A 对象只需要告诉 IOC 容器，需要一个 B 对象，而 B 的实例化过程交给 IOC 容器去做，换言之，IOC 控制了对象的生命周期。</p><p>那么，IOC 所谓的<strong>控制反转</strong>，其实就是指在使用 IOC 容器之后，对象都交由 IOC 容器去控制，进一步，对象的创建不再是在依赖的地方自己去创建，而是需要的时候从 IOC 容器中获取。</p><p>而依赖注入，其实就是将从 IOC 获取对象这一步也进行简化。以上面的例子来讲，如果 A、B 都是交由 IOC 容器管理的对象，A 获取 B 对象并不是在自己的代码中显式调用一个 IocContainer.get(B.class) 来获取，而只需要在自己的类中声明自己需要一个属性，类型是 B，而这个属性的赋值，也交给了 IOC 容器做。</p><blockquote><p>这样讲，是不是就发现和日常使用 Spring 的操作模式很像了，毕竟 Spring 本身就维护了一个 IOC 容器。</p></blockquote><h2 id="初始化流程的抽象设计"><a href="#初始化流程的抽象设计" class="headerlink" title="初始化流程的抽象设计"></a>初始化流程的抽象设计</h2><blockquote><p>这里不会很细节的讲整个流程，而只是梳理流程都有哪些节点，每个节点会有一篇单独的讲解。</p></blockquote><p>下面是摘自 spring 源码中的测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PATH</span> <span class="operator">=</span> <span class="string">&quot;/org/springframework/context/support/&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FQ_SIMPLE_CONTEXT</span> <span class="operator">=</span> PATH + <span class="string">&quot;simpleContext.xml&quot;</span>;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSingleConfigLocation</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(FQ_SIMPLE_CONTEXT);</span><br><span class="line">ctx.getBean(<span class="string">&quot;someMessageSource&quot;</span>);</span><br><span class="line">assertThat(ctx.containsBean(<span class="string">&quot;someMessageSource&quot;</span>)).isTrue();</span><br><span class="line">ctx.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见这里初始化 ClassPathXmlApplicationContext 时是传入的一个 xml 配置文件。</p><p>那么，按照一般理解，得到 xml 配置文件之后，需要做的事至少有以下 3 步：</p><ol><li>加载配置文件</li><li>解析配置文件</li><li>根据配置实例化对象</li></ol><p>而众所周知，Spring 还维护了一个 IOC 容器，所以除了上面 3 步以外，还需要一个 IOC 容器来管理实例化的对象。</p><p>上述这些加载、解析配置，实例化对象，将对象交由 IOC 管理等一系列我们知道或不知道的操作，还需要一个统一的地方来进行编排，而这在 Spring 中对应的就是 ClassPathXmlApplicationContext 等一系列的 ApplicationContext。</p><p>加载配置，因为配置文件不一定非得是 xml 格式的，甚至不一定是本地的资源文件，所以 Spring 对资源进行抽象，形成 Resource 接口，而 Resource 只是配置资源，每种资源又对应了不同的 Resourceloader 接口实现类来加载。</p><p>解析配置，同样也是因为资源类型的不同，所以又有了 BeanDefinitionReader 接口来定义不同资源的解析过程。</p><p>实例化对象，和想象就有点不一样了，因为按照一般的流水账式的设计，肯定是边解析配置，就一边将对象实例化了，但是 Spring 需要考虑的情况太多了，所以需要一个更具扩展性的设计，比如要实现 AOP，如果要变解析边实例化，那 AOP 代理时就直接乱套了。所以 Spring 在解析配置时，只是解析出了 Bean 的定义描述信息，即 BeanDefinition。所以，当解析完文件，实例化对象的过程应是：</p><ol><li>根据 BeanDefinition 先初始化一个 bean 的对象</li><li>填充依赖对象</li></ol><p>那么上述过程设计的基本接口有：</p><p>配置资源加载：</p><ul><li>Resource</li><li>Resourceloader</li></ul><p>配置资源解析：</p><ul><li>BeanDefinitionReader</li></ul><p>IOC 容器：</p><ul><li>BeanFactory</li></ul><p>初始化流程编排，应用上下文：</p><ul><li>ApplicationContext</li></ul><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><pre><code class="highlight mermaid">classDiagramdirection BTclass AbstractApplicationContextclass AbstractRefreshableApplicationContextclass AbstractRefreshableConfigApplicationContextclass AbstractRefreshableWebApplicationContextclass AbstractXmlApplicationContextclass AnnotationConfigApplicationContextclass AnnotationConfigWebApplicationContextclass ApplicationContext &#123;&lt;&lt;Interface&gt;&gt;&#125;class ApplicationEventPublisher &#123;&lt;&lt;Interface&gt;&gt;&#125;class AutoCloseable &#123;&lt;&lt;Interface&gt;&gt;&#125;class Aware &#123;&lt;&lt;Interface&gt;&gt;&#125;class BeanFactory &#123;&lt;&lt;Interface&gt;&gt;&#125;class BeanNameAware &#123;&lt;&lt;Interface&gt;&gt;&#125;class ClassPathXmlApplicationContextclass Closeable &#123;&lt;&lt;Interface&gt;&gt;&#125;class ConfigurableApplicationContext &#123;&lt;&lt;Interface&gt;&gt;&#125;class DefaultResourceLoaderclass EnvironmentCapable &#123;&lt;&lt;Interface&gt;&gt;&#125;class FileSystemXmlApplicationContextclass FunctionalInterfaceclass HierarchicalBeanFactory &#123;&lt;&lt;Interface&gt;&gt;&#125;class InitializingBean &#123;&lt;&lt;Interface&gt;&gt;&#125;class Lifecycle &#123;&lt;&lt;Interface&gt;&gt;&#125;class ListableBeanFactory &#123;&lt;&lt;Interface&gt;&gt;&#125;class MessageSource &#123;&lt;&lt;Interface&gt;&gt;&#125;class ResourceLoader &#123;&lt;&lt;Interface&gt;&gt;&#125;class ResourcePatternResolver &#123;&lt;&lt;Interface&gt;&gt;&#125;class XmlWebApplicationContextAbstractApplicationContext  ..&gt;  ConfigurableApplicationContext AbstractApplicationContext  --&gt;  DefaultResourceLoader AbstractRefreshableApplicationContext  --&gt;  AbstractApplicationContext AbstractRefreshableConfigApplicationContext  --&gt;  AbstractRefreshableApplicationContext AbstractRefreshableConfigApplicationContext  ..&gt;  BeanNameAware AbstractRefreshableConfigApplicationContext  ..&gt;  InitializingBean AbstractRefreshableWebApplicationContext  --&gt;  AbstractRefreshableConfigApplicationContext AbstractRefreshableWebApplicationContext  ..&gt;  ApplicationContext AbstractRefreshableWebApplicationContext  ..&gt;  ConfigurableApplicationContext AbstractXmlApplicationContext  --&gt;  AbstractRefreshableConfigApplicationContext AnnotationConfigApplicationContext  --&gt;  AbstractApplicationContext AnnotationConfigWebApplicationContext  --&gt;  AbstractRefreshableWebApplicationContext ApplicationContext  --&gt;  ApplicationEventPublisher ApplicationContext  --&gt;  EnvironmentCapable ApplicationContext  --&gt;  HierarchicalBeanFactory ApplicationContext  --&gt;  ListableBeanFactory ApplicationContext  --&gt;  MessageSource ApplicationContext  --&gt;  ResourcePatternResolver FunctionalInterface  ..  ApplicationEventPublisher BeanNameAware  --&gt;  Aware ClassPathXmlApplicationContext  --&gt;  AbstractXmlApplicationContext Closeable  --&gt;  AutoCloseable ConfigurableApplicationContext  --&gt;  ApplicationContext ConfigurableApplicationContext  --&gt;  Closeable ConfigurableApplicationContext  --&gt;  Lifecycle DefaultResourceLoader  ..&gt;  ResourceLoader FileSystemXmlApplicationContext  --&gt;  AbstractXmlApplicationContext HierarchicalBeanFactory  --&gt;  BeanFactory ListableBeanFactory  --&gt;  BeanFactory ResourcePatternResolver  --&gt;  ResourceLoader XmlWebApplicationContext  --&gt;  AbstractRefreshableWebApplicationContext</code></pre><p>上面是 ApplicationContext 的类图，会发现它还继承了 BeanFactory 接口和 ResourceLoader 接口。</p><p>其实 ApplicationContext 本身就是一个 IOC 容器，但是又不只是一个 IOC 容器，它还具备以下能力：</p><ol><li>实现 ResourceLoader 接口，具备加载资源的能力。</li><li>实现 MessageSource 接口，提供了国际化访问的能力。</li><li>实现 ApplicationEventPublisher 接口，提供了事件发布的能力。</li><li>从类图中也能发现，对 web 应用的支持，并不是 IOC 原生的能力，也是 ApplicationContext 扩展实现的能力。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-generator代码生成和自定义逻辑隔离</title>
      <link href="posts/2f0045576148.html"/>
      <url>posts/2f0045576148.html</url>
      
        <content type="html"><![CDATA[<p>最近使用 mybatis-generator 时，发现很多时候会有一些更加个性化的 select 或者 update 的场景，这时，如何更优雅使用 mybatis-generator 就是一个问题。</p><h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h2><p>现在有一张 user 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `<span class="keyword">user</span>`(</span><br><span class="line">    `id` <span class="type">bigint</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">    `age` <span class="type">int</span>,</span><br><span class="line">    `sex` <span class="type">varchar</span>(<span class="number">2</span>),</span><br><span class="line">    `city` <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    `country` <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最后使用 mybatis-generator 生成的 UserMapper 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User row)</span>;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">selectByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateByPrimaryKey</span><span class="params">(User row)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此基础上，如果现有有一个根据年龄查询 User 的场景，就需要在 UserMapper 中加上 selectByAge 的方法，解决了燃眉之急，但是如果有一天 user 表变了，需要重新生成 UserMapper，这个时候，selectByAge 就会被删掉，就需要开发人员手动做一次备份。</p><p>要如何解决这个问题？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>就像平日做代码设计时，会常常强调将变和不变分离。</p><p>上述场景下，变的是自定义场景下的增删改查，不变的是 mybatis-generator 生成的代码，那么我们就得在不改变 UserMapper 的情况下解决问题。</p><p>我们可以使用一个新的接口，承载自定义的增删改查的能力，并继承 UserMapper，针对新接口也单独建立 mapper 的 xml 映射文件。</p><p>为了对业务代码更友好，编写自动生成 mapper 接口文件的配置时，指定 user 表对应的自动生成得 mapper 接口文件名为 UserBaseMapper，后面手动创建的自定义增删改查的接口为 UserMapper。</p><p>生成代码的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;simple&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressDate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC<span class="symbol">&amp;amp;</span>nullCatalogMeansCurrent=true&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;*VyvofI^dhl_:Y<span class="symbol">&amp;amp;</span>?/19M0vhr#3hU4151&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.hanelalo.mybatis.entity&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;mappers&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.hanelalo.mybatis.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;user&quot;</span> <span class="attr">mapperName</span>=<span class="string">&quot;UserBaseMapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>生成的 UserBaseMapper：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserBaseMapper</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User row)</span>;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">selectByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateByPrimaryKey</span><span class="params">(User row)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 UserBaseMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hanelalo.mybatis.mapper.UserBaseMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hanelalo.mybatis.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;city&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;city&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;country&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;country&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="line">    delete from user</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.hanelalo.mybatis.entity.User&quot;</span>&gt;</span></span><br><span class="line">    insert into user (id, name, age, </span><br><span class="line">      sex, city, country)</span><br><span class="line">    values (#&#123;id,jdbcType=BIGINT&#125;, #&#123;name,jdbcType=VARCHAR&#125;, #&#123;age,jdbcType=INTEGER&#125;, </span><br><span class="line">      #&#123;sex,jdbcType=VARCHAR&#125;, #&#123;city,jdbcType=VARCHAR&#125;, #&#123;country,jdbcType=VARCHAR&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.hanelalo.mybatis.entity.User&quot;</span>&gt;</span></span><br><span class="line">    update user</span><br><span class="line">    set name = #&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">      age = #&#123;age,jdbcType=INTEGER&#125;,</span><br><span class="line">      sex = #&#123;sex,jdbcType=VARCHAR&#125;,</span><br><span class="line">      city = #&#123;city,jdbcType=VARCHAR&#125;,</span><br><span class="line">      country = #&#123;country,jdbcType=VARCHAR&#125;</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select id, name, age, sex, city, country</span><br><span class="line">    from user</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select id, name, age, sex, city, country</span><br><span class="line">    from user</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在新建一个 UserMapper 接口继承 UserBaseMapper：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">UserBaseMapper</span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectByAge</span><span class="params">(<span class="meta">@Param(&quot;age&quot;)</span> <span class="type">int</span> age)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 xml 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hanelalo.mybatis.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hanelalo.mybatis.entity.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;city&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;city&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;country&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;country&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByAge&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hanelalo.mybatis.entity.User&quot;</span>&gt;</span></span><br><span class="line">        select id,</span><br><span class="line">               name,</span><br><span class="line">               age,</span><br><span class="line">               sex,</span><br><span class="line">               city,</span><br><span class="line">               country</span><br><span class="line">        from user</span><br><span class="line">        where age = #&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在使用的时候，直接注入 UserMapper 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryByAge</span><span class="params">(<span class="meta">@PathVariable(&quot;age&quot;)</span> <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectByAge(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp; curl -X GET http://localhost:8080/users          </span><br><span class="line">[&#123;<span class="string">&quot;id&quot;</span>:1,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;hanelalo&quot;</span>,<span class="string">&quot;age&quot;</span>:25,<span class="string">&quot;sex&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;city&quot;</span>:<span class="string">&quot;cq&quot;</span>,<span class="string">&quot;country&quot;</span>:<span class="string">&quot;CN&quot;</span>&#125;,&#123;<span class="string">&quot;id&quot;</span>:2,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;killer&quot;</span>,<span class="string">&quot;age&quot;</span>:22,<span class="string">&quot;sex&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;city&quot;</span>:<span class="string">&quot;cq&quot;</span>,<span class="string">&quot;country&quot;</span>:<span class="string">&quot;CN&quot;</span>&#125;,&#123;<span class="string">&quot;id&quot;</span>:3,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;driftwood&quot;</span>,<span class="string">&quot;age&quot;</span>:23,<span class="string">&quot;sex&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;city&quot;</span>:<span class="string">&quot;cq&quot;</span>,<span class="string">&quot;country&quot;</span>:<span class="string">&quot;CN&quot;</span>&#125;,&#123;<span class="string">&quot;id&quot;</span>:4,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;king&quot;</span>,<span class="string">&quot;age&quot;</span>:27,<span class="string">&quot;sex&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;city&quot;</span>:<span class="string">&quot;cq&quot;</span>,<span class="string">&quot;country&quot;</span>:<span class="string">&quot;CN&quot;</span>&#125;]%</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp; curl -X GET http://localhost:8080/users/22</span><br><span class="line">[&#123;<span class="string">&quot;id&quot;</span>:2,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;killer&quot;</span>,<span class="string">&quot;age&quot;</span>:22,<span class="string">&quot;sex&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;city&quot;</span>:<span class="string">&quot;cq&quot;</span>,<span class="string">&quot;country&quot;</span>:<span class="string">&quot;CN&quot;</span>&#125;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Https、CA、TLS</title>
      <link href="posts/b29da75c96a8.html"/>
      <url>posts/b29da75c96a8.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/image/202209032234002.jpg'/><span id="more"></span><h2 id="Http-和-Https"><a href="#Http-和-Https" class="headerlink" title="Http 和 Https"></a>Http 和 Https</h2><p>我们都知道 https 比 http 更加安全，主要是因为 https 的数据传输比 http 更加安全，所以 https 中的 s 其实是 Secure 的意思。</p><p>可理解为 http 是明文传输，而 https 是加密传输，所以更加安全。</p><h2 id="为什么需要加密？"><a href="#为什么需要加密？" class="headerlink" title="为什么需要加密？"></a>为什么需要加密？</h2><p>在网络世界中，存在着黑客，他们盗取用户的信息，进而做一些非法的行为，如果传输的数据不进行加密，说不定你在某个网站上输入的密码就会不知不觉中落入黑客手中。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>在早期的网络世界中，使用的都是对称加密。</p><p>比如客户端要将一个数字 M 传送给服务端，为了防止黑客抓包后知道传输的内容，客户端和服务端约定了一个秘钥 key，所以就引入了一个加密函数 f1(key, M)，客户端发送数字 M 时，通过 f1(key, M) 将 M 转换成密文 S，网络中传输的是密文 S，服务端拿到密文 S 之后，使用一个 f2(key, S) 函数，就能得到原文 M。</p><p><img src="http://image.hanelalo.cn/image/202208282217233.svg"></p><p>但是，存在一个问题，这个 key 要怎么做到两边统一？</p><p>如果不管哪个客户端的 key 都是一样的，那肯定不安全，因为如果黑客破解了一个客户端的 key，就破解了整个服务，所以每个客户端的 key 不一样，需要客户端和服务端交互才能完成约定，而这个过程，因为没有任何安全措施，所以和明文传输没区别，有心的黑客很容易就能截获 key，所以对称加密这种方式并不安全。</p><p>而且，只要获得的加密数据样本够多，黑客可能也可以暴力枚举出 key。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>从对称加密的方式来看，客户端和服务端始终还是要约定一个加密方式。那要如何保证哪怕黑客拿到传输的加密 key 和密文依然无法得到原文呢？</p><p>我们可以使用一个密钥对，一个公钥，一个私钥。公钥可以公开，私钥只能服务端持有，使用公钥加密后的密文，只有使用私钥才能解密。</p><p>如何做到的呢？</p><p>这不得不感叹数学的伟大。</p><h2 id="RSA-加密算法"><a href="#RSA-加密算法" class="headerlink" title="RSA 加密算法"></a>RSA 加密算法</h2><p>RSA 加密算法是一种比较常见的非对称加密算法，基本原理如下：</p><ol><li><p>找出两个<a href="https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515">质数</a> p、q.</p></li><li><p>找到一个 n，使得 n = p * q，n 一般都会很大，常用的是 1024 位二进制数.</p></li><li><p>找到一个函数 φ(n) = (p-1)(q-1)，即欧拉函数.</p></li><li><p>公钥 e 是满足 1 &lt; e &lt; φ(n) 的整数，且 e 和 φ(n) 互质.</p></li><li><p>私钥 d，满足 (e * d) % φ(n) = 1.</p></li><li><p>公钥加密：如果要传输的数字为 m，则加密算法为 c = (m^e)%n，得到的 c 就是密文.</p></li><li><p>私钥解密：得到密文 c，则 m = (c^d%n)，完成解密.</p></li></ol><p>现在如果是客户端和服务端通信，那么一开始需要传输用于加密算法的必须有公钥 e 和第二步的到的大数 n。如果黑客也拿到了这两个数字，以及客户端加密后的密文 c，因为加密算法使用了取余的操作，所以并不能反算出加密前的明文，而要解密，就必须要知道私钥 d，但是私钥 d 在服务端保存不公开，也就没法解密。</p><p>那黑客是否可以根据现有信息计算出私钥 d 呢？</p><p>黑客现在知道公钥 e 和一个大数 n，要得到 e，需要先通过 n 反算出 p、q，反算出 p、q 之后，就知道了 φ(n)，但是，在上面的第五步，又使用到了取余的操作，所以反算出的 d，肯定不止一个数。</p><p>虽然，如果 n = 21，能很简单的算出 21 = 3 * 7，这叫质因数分解。但是前面讲到 n 是一个一般有 1024 位的二进制数的大数，现代的计算机要通过这样一个 n 进行质因数分解计算出 p、q 就已经很难了，因为 n 太大了，更何况得到 p、q 之后还要面对计算出的不止多少个 d。</p><p>所以，RSA 这种非对称加密算法才会被认为是安全的。</p><h2 id="Http-RSA-非对称加密是否安全？"><a href="#Http-RSA-非对称加密是否安全？" class="headerlink" title="Http + RSA 非对称加密是否安全？"></a>Http + RSA 非对称加密是否安全？</h2><p>如果是单纯的 Http + RSA，交互流程大致应是如下：</p><pre><code class="highlight mermaid">sequenceDiagramparticipant client as 客户端participant server as 服务端client-&gt;&gt;server:1.第一次请求server-&gt;&gt;client:2.返回公钥e、大数nclient-&gt;&gt;server:3.使用e、n加密后密文</code></pre><p>上面的交互模式没问题，但是，如果有一个中间人，挡在了客户端和服务端中间：</p><pre><code class="highlight mermaid">sequenceDiagramparticipant client as 客户端participant hacker as 中间人participant server as 服务端client-&gt;&gt;hacker:1.第一次请求hacker-&gt;&gt;server:2.中间人转发客户端请求server-&gt;&gt;hacker:3.返回公钥e、大数nhacker-&gt;&gt;client:4.返回自己生成的公钥e&#x27;和大数n&#x27;client-&gt;&gt;hacker:5.客户端使用中间人的公钥和大数进行加密hacker-&gt;&gt;server:6.中间用自己的私钥将客户端密文解密后得到明文，再用e、n加密</code></pre><p>这时，就能发现，虽然客户端和服务端依然正常通信，但是整个过程中，数据对中间人都相当于是明文可见的，这就是中间人攻击。</p><p>那么，要如何解决这种问题？</p><p>因为客户端本身无法判断得到的公钥是中间人的还是服务端的，所以，只能依靠外部协助来判断，所以就有了 CA 机构。</p><h2 id="CA-机构"><a href="#CA-机构" class="headerlink" title="CA 机构"></a>CA 机构</h2><p>为了解决传递公钥时的中间人攻击问题，建立了数字证书认证机构（英语：Certificate Authority，缩写为CA），承担公钥体系中公钥的合法性检验的责任。</p><p>回到上一节提出的问题，中间人攻击的根本原因，在于公钥的传输过程是公开的，黑客一旦从中作梗，就跟明文传输没有区别，所以我们需要保证的是，公钥还得传输，而且客户端拿到的公钥一定是正确的，CA 机构就是做这个保证工作的。</p><p>CA 机构的工作原理大致如下：</p><ol><li>网站向 CA 机构提交申请，需要提供自己的公钥和身份信息。</li><li>CA 机构进行线上、线下认证之后，最终会生成证书给网站运营方。</li><li>当客户端发起连接时，得到的就不是网站的公钥，而是网站的认证证书（证书中有公钥）。</li><li>客户端得到证书后，再通过 CA 机构的公钥对证书进行验证，验证通过，证书有效，拿到的公钥正确有效。</li></ol><p>这里会发现需要用到 CA 机构的公钥，这个公钥，是直接写死在了操作系统中的，而不是通过网络传输到客户端。</p><pre><code class="highlight mermaid">sequenceDiagramparticipant client as 客户端participant server as 服务端participant ca as CA机构server-&gt;&gt;ca: 1.服务端向CA机构提供自己的公钥、网站身份信息，比如域名等ca-&gt;&gt;server: 2.CA机构使用CA机构的私钥对上一步的信息进行加密，得到的密文就是证书，并返回给服务端client-&gt;&gt;server: 3.客户端和服务端通信server-&gt;&gt;client: 4.在建立连接前，网站向客户端发送证书，同时还会告知颁发证书的CA机构client--&gt;client: 4.1.使用CA机构公钥验证证书</code></pre><p>可是黑客也能拿到操作系统中的公钥？</p><p>其实 CA 机构的作用不在于保证服务端公钥传输的隐蔽性，而是要防篡改。所以当客户端拿到服务端的证书后，用操作系统中的 CA 机构公钥验证，只要验证通过，那就证明公钥是没有被中间人篡改的。</p><h2 id="SSL-和-TLS"><a href="#SSL-和-TLS" class="headerlink" title="SSL 和 TLS"></a>SSL 和 TLS</h2><p>SSL 全称 Secure Socket Layer，最初由网景公司开发，1.0 版本从未发布。</p><p>1995 年，SSL 2.0 版本随网景浏览器 1.1 发布，同年，网景又发布了 3.0 版本，以解决一些安全问题。</p><p>1999 年，网景和微软的浏览器战争打响，网景将 SSL 协议控制权交给了 IETF（Internet Engineering Task Force），在 1999年结束前，IETF 发布了 TLS 1.0 版本，这是其实称为 SSL 3.1 更合适，SSL 也更名为 TLS，全称 Transport Layer Secure。</p><p>2006 年，TLS 1.1 发布。</p><p>2008 年，TLS 1.2 发布，解决了一些安全问题，但是直到 2013 年，浏览器才开始支持 TLS 1.2。</p><p>2015 年，SSL 3.0 被正式弃用。</p><p>2018 年，TLS 1.3 正式审批通过，TLS 1.3 带来了极大的安全改进。</p><h2 id="客户端、服务端双向通信问题"><a href="#客户端、服务端双向通信问题" class="headerlink" title="客户端、服务端双向通信问题"></a>客户端、服务端双向通信问题</h2><p>我们知道 http 是全双工协议，全双工也就意味着通信的两端，都是既可以发送信息，也可以接受信息。</p><p>前文讲到 https 需要使用客户端使用公钥加密，服务端使用私钥对密文进行解密，且公钥加密后的数据，只有私钥能够解密。</p><p>所以使用一个非对称加密的密钥对，只能实现单向传输的安全性。如果要实现双向传输，是否是需要另一个密钥对，来保证服务端传输数据到客户端的安全？</p><p>思考一下，业界肯定不是这样做的，不然服务端将会存储无数个客户端的公钥，这对服务端的存储要求大大提高。</p><p>所以，Https 采用的其实是非对称加密 + 对称加密的方式。非对称加密通信用来获取对称加密的秘钥，而正常的用户请求，则是使用这个秘钥进行加密。因为非对称加密过程中，能保证秘钥不泄露，所以后续使用秘钥进行对称加密传输也是安全的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://howhttps.works/https-ssl-tls-differences/">The differences between HTTPS, SSL, and TLS</a></p><p><a href="https://www.youtube.com/watch?v=D_kMadCtKp8">【Youtube 视频】银行密码系统安全吗？质数到底有啥用？</a></p><p><a href="https://web.okjike.com/originalPost/62fe1df2e30b105ebd8bbc59">【即刻】王建硕的分享</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO：同步、异步、阻塞、非阻塞、多路复用</title>
      <link href="posts/b65430830d20.html"/>
      <url>posts/b65430830d20.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/image/202206121200343.png'/><span id="more"></span><h2 id="从线程状态说起"><a href="#从线程状态说起" class="headerlink" title="从线程状态说起"></a>从线程状态说起</h2><p>在操作系统层面，线程状态分为 5 种。</p><ol><li>初始状态</li><li>可运行状态</li><li>休眠状态</li><li>运行状态</li><li>终止状态</li></ol><p>状态流转图如下：</p><p><img src="http://image.hanelalo.cn/image/202206121336730.png" alt="操作系统线程状态流转"></p><p>而对于 Java 来讲，线程在整个生命周期中有如下 6 种状态：</p><ul><li><p>New</p><p>新创建的线程，还未被执行。</p></li><li><p>Runnable</p><p>线程内的逻辑正在被执行，或等待调度，所以可以细分为两种状态：</p><ul><li><p>Ready</p><p>线程可执行，只不过当前 CPU 时间片并未被调度（CPU 在多线程环境下，并非一个线程执行到底，而是分时间片执行，当前时间片在执行线程 A，可能下一个时间片就执行线程 B），线程被挂起。</p></li><li><p>Running</p><p>当前线程正在被调度执行。</p></li></ul><p>总之，在 Runnable 状态下，线程要么被调度，使用 CPU，要么等待 CPU 调度，CPU 正在被其他线程使用。简而言之，CPU 没有空闲着浪费资源。</p></li><li><p>Blocked</p><p>正在等待获取监视器锁，以进入或重新进入同步代码块。此时不会分配 CPU 时间片。</p></li><li><p>Waiting</p><p>无时间限制地等待其他线程执行唤醒操作。此时不会分配 CPU 时间片。</p></li><li><p>TIMED_WAITING</p><p>有时间限制地等待其他线程执行唤醒操作。此时不会分配 CPU 时间片。</p></li><li><p>TERMINATED</p><p>线程执行完毕。</p></li></ul><p>状态流转图如下：</p><p><img src="http://image.hanelalo.cn/image/202206121349663.png" alt="Java线程状态流转"></p><p>Java 中，将操作系统的运行中、可运行状态合并为 Runnable 状态，而操作系统的休眠状态，在 Java 中又根据调用不同的 api 分为 WAITING、TIMED_WAITING、BLOCKED 3 种状态。</p><p>除此之外，像下面的代码，线程 t 的状态是 Runnable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">          () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              System.in.read();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">  t.start();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(t.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure><p>按理说，这里调用 t 调用了 System.in.read() 这种会阻塞线程的 api，线程应是阻塞的，但是实际的 state 却是 RUNNABLE。</p><p>从操作系统的层面看，<code>System.in.read()</code> 确实会阻塞线程，因为需要等待外部设备输入并将数据拷贝到内核，再拷贝到用户态，而对于 Java 来讲，等待内核的数据到达和等待 CPU 调度没区别，一样都是等待。</p><p>所以，调用阻塞式 api （比如 IO）时，因为“视角”不同，从操作系统层面看，线程是处于休眠状态，不分配 CPU 时间片，而对于 Java 来讲，虽然此时本质上也没分配 CPU 时间片，但同样都是等待，所以归为 RUNNABLE 状态，形成了一种在等待调度 CPU 时间片的假象。</p><p>那么，同步阻塞 IO、同步非阻塞 IO 中的阻塞是指什么呢？</p><h2 id="阻塞到底是什么？"><a href="#阻塞到底是什么？" class="headerlink" title="阻塞到底是什么？"></a>阻塞到底是什么？</h2><p>前文讲到，调用 IO 时，从操作系统视角看，线程实质上是处于休眠状态，Java 的视角看，线程处于等待 CPU 资源调度的状态，这是本质，从本质反推到现象则是，调用了 IO 的 api 之后，线程“卡”住了，换言之，在当前线程里，CPU 不继续执行指令。一直到 IO 操作结束，数据已经从内核空间复制到用户空间，线程才恢复运行，又有了被分配 CPU 时间片的可能，等到被调度的时候，线程内的逻辑又可以继续往下执行。</p><blockquote><p>关于内核空间和用户空间，简而言之就是为了操作系统的安全，应用程序并不是什么函数都能调用，有些函数的调用是需要权限的，调用普通函数时，处于用户态，而当需要调用这种特权函数时，就需要进入到内核态。</p></blockquote><p>以网络 IO 为例，用户线程调用 recv() 函数，陷入内核态，但是内核中没数据。针对内核没数据的情况，有 2 种解决方案：</p><ol><li>调用 io 函数后，线程置为休眠状态。当数据从物理链路到达网卡之后，由 DMA 将数据从网卡拷贝到内核缓冲区，然后再由 CPU 从内核缓冲区将数据复制到用户空间，这里有 2 次复制，在第二次复制完成之前，用户线程都是处于休眠状态的。</li><li>调用 io 函数后，不管内核有没有数据，都立即返回。用户线程或通过轮训的方式一直查询内核数据是否到达，或者当内核数据到达后发出信号，然后 CPU 复制数据到用户空间。</li></ol><blockquote><p>没深入了解操作系统的 api，所以具体做 IO 的 api 是什么，我也不知道，等哪天把书看完了应该就知道了。</p></blockquote><p>而阻塞，指的就是这 2 种处理方案。第一种，一直等着数据到达内核再返回，这个过程中不会占用 CPU 时间片，线程处于休眠状态，就是阻塞；第二种，不管内核有没有数据都直接返回，线程不会一直处于休眠状态，就是非阻塞。</p><p>换言之，<strong>阻塞</strong>是指用户线程是否一直等着复制数据，如果是，那线程就一直处于休眠状态，即为阻塞，如果不是，那线程就不是一直处于休眠状态，就是非阻塞。</p><h2 id="同步和异步-IO"><a href="#同步和异步-IO" class="headerlink" title="同步和异步 IO"></a>同步和异步 IO</h2><p>IO 模型主要分为：</p><ul><li>同步阻塞 IO。</li><li>同步非阻塞 IO。</li><li>IO 多路复用。</li><li>事件驱动 IO。</li><li>异步 IO。</li></ul><p><img src="http://image.hanelalo.cn/image/202206121720984.png" alt="IO模型"></p><p>将整个 IO 过程分为两阶段，一阶段在用户态，二阶段在内核态。</p><ul><li>同步阻塞，线程从用户态到内核态，两阶段都在阻塞。</li><li>同步非阻塞，用户态不会阻塞，一阶段一直在轮训检查数据是否到达，当数据到达内核后进入二阶段，复制数据到用户态，发生在内核空间，这个过程是阻塞的。</li><li>IO 多路复用，可以简单理解为一个线程负责监听多个 IO，当有一个 IO 完成后，通知用户线程处理 IO 结束后的数据，从内核拷贝数据到用户态的过程，用户线程依然是阻塞（详见后文 Reactor 线程模型）。</li><li>信号驱动 IO，告知内核，当某个信号到达时，通知用户线程。</li><li>异步 IO，发起 IO 请求，等 IO 数据到达并复制到用户空间后，这个过程和用户线程没关系，复制完后，要么通知，要么回调的方式通知用户线程处理数据。</li></ul><blockquote><p>信号驱动 IO 和异步 IO 的区别在于，前者是通知用户进程可以复制数据，后者是通知用户进程数据复制完成。</p></blockquote><p>同步和异步的区别在于，二阶段从内核空间复制数据到用户空间时，用户线程是否阻塞，阻塞就是同步，不阻塞就是异步。</p><h2 id="同步、阻塞小结"><a href="#同步、阻塞小结" class="headerlink" title="同步、阻塞小结"></a>同步、阻塞小结</h2><p>介绍完了阻塞和同\异步概念，结合前文 5 中 IO 模型再总结一下：</p><p><strong>同步</strong>，关注第二阶段，是指用户线程是否一定要等到数据到达内核，然后复制到用户空间，这个过程，用户线程是否阻塞。</p><p><strong>阻塞</strong>，关注第一阶段，是指用户线程是否一直等着复制数据，如果是，那线程就一直处于休眠状态，即为阻塞，如果不是，那线程就不是一直处于休眠状态，就是非阻塞。</p><p>理解这两个概念之后，关于同步阻塞 IO、同步非阻塞 IO、异步 IO 是否就清晰了呢？</p><blockquote><p>所以，我感觉其实相对同步阻塞 IO，同步非阻塞 IO 本身有点不明显，因为对于用户线程来说，等内核数据到达，跟一直循环询问内核数据是否到达，没什么区别，只不过同步阻塞少用了 CPU，同步非阻塞 提高了 CPU 利用率，用来轮询。</p><p>而 IO 多路复用，则是基于同步非阻塞 IO 的一次大改进，如果有一天我发现我理解错了再改。</p><p>我发现理解了阻塞和同步的概念之后，我依然不是很理解 IO 多路复用的概念。</p></blockquote><h2 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h2><p>提到 IO 多路复用，网上一大片文章就是什么 select、poll、epoll 来了，IO 多路复用到底是什么？我也没见几篇文章回归到这个问题上。</p><p>在前文给到 5 种 IO 模型对比图中，看见 IO 多路复用在用户态依然会阻塞，在内核态也会阻塞，似乎和同步阻塞 IO 没啥区别，不过 IO 多路复用又比同步非阻塞 IO 多了一个“就绪”通知，具体的区别又是什么呢？</p><p>在同步阻塞 IO 中，每一个 IO 都会阻塞一个线程，这样十分耗费线程资源，极端情况下甚至可能出现应用开了一大堆线程，大部分线程都因为 IO 处于休眠状态，这本身是一种资源浪费。</p><p>所以，就想，不然就让专门的一个线程来负责 IO 事件的监听，当某个 IO 请求从内核返回后，立马找一个线程来处理数据，这样的话，阻塞的线程就只有 1 个，至于其他线程，则可以处理其他事。</p><blockquote><p>以服务器网络 IO 的场景举例，当客户端发起一个网络连接时，服务端处理这个连接肯定需要开一个线程，如果同时 10000 个连接请求到来，那岂不是需要开 10000 个线程，Java 的线程一般需要 512K 到 1M 内存空间，10000 个线程，那就是接近 10G。所以这种一个连接一个线程的处理方式，不可控性太强了，服务器容易炸。</p><p>那么，如果有一种技术，可以同时监听多个网络 IO 请求呢？那么就只需要一个线程来实现这种技术，进行监听，然后再创建一个线程池，用来处理业务逻辑、建立连接的逻辑，线程池本身是有可控性的，来 10000 个请求，我也不会开 10000 个线程，可以扔线程池里面慢慢处理。</p></blockquote><p>所以 IO 多路复用，其实本身是 select、poll、epoll 这些技术的底层原理，它的关注点很单纯的就是我不能让每次 IO 都“卡”死一个线程。</p><blockquote><p>select、poll、epoll 的原理和区别见 6 号参考资料。</p></blockquote><p>那么 IO 多路复用的实际使用场景是怎样的？</p><h3 id="Reactor-线程模型"><a href="#Reactor-线程模型" class="headerlink" title="Reactor 线程模型"></a>Reactor 线程模型</h3><p>Reactor 线程模型便是基于 IO 多路复用来实现的。</p><p>Reactor 的核心组件有 3 个：</p><ul><li>Reactor，负责监听请求事件，并分发事件，如果是连接事件，则分发给 Acceptor，</li><li>Acceptor，获取网络连接。</li><li>Handler，业务处理器。</li></ul><p>可以分为 3 种 Reactor 模型：</p><ul><li><p>单 Reactor 单线程模型</p><p>只有一个线程，可以理解为，只是在代码层级上将组件做了区分，本质上接受事件、分发事件、处理事件其实就在一个线程中，本身的资源开销自然不大。</p><ol><li>客户端请求建立连接；</li><li>Reactor 监听到连接事件，交由 Acceptor 处理；</li><li>Acceptor 对象调用 accept() 方法，建立连接，并创建 Handler，由于响应后续的请求事件；</li><li>上一步建立的连接中发来请求，Reactor 监听到请求事件，发现不是连接事件，就交由该连接对应的 Handler 处理；</li><li>Handler 通过 read() 读取数据，执行业务逻辑之后，通过 send() 方法发送响应。</li></ol><p>问题在于因为只有一个线程，所以当 Handler 还没处理完请求，新来的请求只能先等着，不适用于请求量比较大的场景。</p><p>单 Reactor 单线程模型适用业务处理很快的场景，比如 Redis 就是使用的这种模型。</p><p><img src="http://image.hanelalo.cn/image/202206122045576.png" alt="单Reactor单线程"></p></li><li><p>单 Reactor 多线程模型</p><ol><li>客户端请求建立连接；</li><li>Reactor 监听到连接事件，分发给 Acceptor 处理；</li><li>Acceptor 调用 accept() 方法，建立连接，并创建一个 Handler 用户响应连接上的后续请求。</li><li>客户端发来请求，Reactor 发现不是连接事件，交由连接对应的 Handler 处理；</li><li>Handler 调用 read() 方法读取数据，然后交由线程池里处理；</li><li>线程池处理完成后，将响应数据返回给 Handler；</li><li>Handler 接收到响应数据，调用 send() 方法发送响应数据。</li></ol><p>在这种模型下，Handler 就不负责业务逻辑了，而只负责数据接受和发送，业务逻辑交由线程池处理，提高了资源利用率。也提高了并发能力。 </p><p>但是，因为只有一个 Reactor 来监听事件，所以对于瞬间的高并发场景，会存在性能瓶颈。</p><p><img src="http://image.hanelalo.cn/image/202206122051222.png" alt="单Reactor多线程"></p></li><li><p>多 Reactor 多线程模型</p><p>多 Reactor 多线程模型下，定义了 MainReactor 和 SubReactor 的概念，MainReactor 负责监听连接事件，然后交由 Acceptor 处理，Acceptor 调用 accept 方法获取连接，然后交由 SubReactor，SubReactor 将连接注册到 select 进行监听，在这个连接上后续的请求就不需要 MainReactor 处理，而是有 SubReactor 处理。</p><ol><li>客户端请求建立连接。</li><li>MainReactor 监听到连接事件，交由 Acceptor 处理；</li><li>Acceptor 调用 accept() 方法建立连接，并交由 SubReactor；</li><li>SubReactor 拿到连接后，注册到 select 中继续监听，并创建一个 Handler 用于响应该连接后续的请求；</li><li>客户端发来请求，SubReactor 监听到请求事件，分发到该连接的 Handler 中进行处理；</li><li>Handler 调用 read() 方法读取数据，然后扔到线程池中进行业务逻辑的处理；</li><li>线程池处理完之后，将响应数据数据返回给 Handler；</li><li>Handler 接收到响应数据后，调用 send() 方法发送数据；</li></ol><p>这样的好处在于 MainReactor 和 SubReactor 分工合作，能更好的的提高并发能力和资源，且相对于单 Reactor 多线程模型，因为采用多 Reactor，MainReactor 和 SubReactor 各司其职，对于瞬间的高并发也有了足够的应对能力。</p><blockquote><p>值得一提的是，Java 中大名鼎鼎的网络框架 Netty，就是使用的多 Reactor 多线程模型，这从初始化时需要区分 bossGroup 和 workGroup 就可以看出来。</p></blockquote><p><img src="http://image.hanelalo.cn/image/202206122239809.png" alt="多Reactor多线程"></p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.baeldung.com/java-thread-lifecycle">Life Cycle of a Thread in Java</a></li><li><a href="https://time.geekbang.org/column/article/86366">极客时间《Java 并发编程实战》专栏：《09 | Java线程（上）：Java线程的生命周期》</a></li><li><a href="https://mp.weixin.qq.com/s/2_-ot3t9Yaws7bOqEhv78Q">DMA和零拷贝</a></li><li><a href="https://www.itzhai.com/articles/it-seems-not-so-perfect-signal-driven-io.html">三分钟短文快速了解信号驱动式IO，似乎没那么完美</a></li><li><a href="https://static.kancloud.cn/luoyoub/network-programming/2234088">信号驱动I/O</a></li><li><a href="https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/">LINUX – IO MULTIPLEXING – SELECT VS POLL VS EPOLL</a></li><li><a href="https://cloud.tencent.com/developer/article/1488120">彻底搞懂Reactor模型和Proactor模型</a></li><li><a href="https://www.zhihu.com/question/26943938/answer/1856426252">如何深刻理解Reactor和Proactor？</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="posts/e6cbc17382b5.html"/>
      <url>posts/e6cbc17382b5.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/image/20220401111755.jpg'/><span id="more"></span><blockquote><p>发现我的博客竟没有专门将整个的文章，不得不当一次缝合怪，结合《Java并发编程的艺术》和网络大神的文章做总结。</p><p>JMM 也就是 Java 内存模型，和 JVM 内存区域划分是两回事，这是容易搞混的概念。</p></blockquote><h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><h2 id="Java-内存模型抽象结构"><a href="#Java-内存模型抽象结构" class="headerlink" title="Java 内存模型抽象结构"></a>Java 内存模型抽象结构</h2><p>为了屏蔽不同处理器、平台之间的差异，Java 建立了一套抽象的内存模型。</p><p><img src="http://image.hanelalo.cn/image/202204011406467.svg" alt="Java内存抽象结构"></p><p>每个线程都有一个自己的本地内存，当一个线程 A 访问共享变量时，会将共享变量复制一份副本到自己的本地内存中，如果要修改，也是修改的本地内存中的副本的值，当另一个线程 B 也要读取这个共享变量时，又会将 A 的本地内存中的值同步到主内存中，以保证 B 读到的是最新的值。</p><p>如果没有 JMM 的控制，就会出现 A 线程修改了本地内存的副本，但是没有同步到主内存，此时 B 线程有去主内存读取了共享变量，导致 B 拿到的不是最新的值。</p><h2 id="Java-并发编程必须解决的问题"><a href="#Java-并发编程必须解决的问题" class="headerlink" title="Java 并发编程必须解决的问题"></a>Java 并发编程必须解决的问题</h2><p>Java 并发编程要解决的 3 大问题是：</p><ol><li>线程切换导致的原子性问题；</li><li>处理器缓存导致了内存可见性问题；</li><li>指令优化导致重排序问题；</li></ol><h3 id="线程切换导致的原子性问题"><a href="#线程切换导致的原子性问题" class="headerlink" title="线程切换导致的原子性问题"></a>线程切换导致的原子性问题</h3><p>比如大家熟知的 <code>i++</code> 操作，代码只有一行，实际上分了 3 步：</p><ol><li>从内存取 i 的值；</li><li>执行 +1 得到新值；</li><li>将新值赋值给 i；</li></ol><p>在多线程环境下，如果这个 i 是共享变量，因为线程切换问题，就会有问题。</p><blockquote><p>这里的 i 既然是共享变量，那就肯定不是方法内定义的局部变量，而是类的成员变量。</p></blockquote><p>下面举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MainTest</span>().i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后，用 javap 查看字节码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c MainTest.class</span><br><span class="line">Compiled from <span class="string">&quot;MainTest.java&quot;</span></span><br><span class="line">public class org.hanelalo.MainTest &#123;</span><br><span class="line">  public org.hanelalo.MainTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       4: aload_0</span><br><span class="line">       5: iconst_0</span><br><span class="line">       6: putfield      <span class="comment">#2                  // Field i:I</span></span><br><span class="line">       9: <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           <span class="comment">#3                  // class org/hanelalo/MainTest</span></span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial <span class="comment">#4                  // Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       7: dup</span><br><span class="line">       8: getfield      <span class="comment">#2                  // Field i:I</span></span><br><span class="line">      11: iconst_1</span><br><span class="line">      12: iadd</span><br><span class="line">      13: putfield      <span class="comment">#2                  // Field i:I</span></span><br><span class="line">      16: <span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要关注 <code>main</code> 方法对应的字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  Code:</span><br><span class="line">     0: new           #3                  // class org/hanelalo/MainTest</span><br><span class="line">     3: dup</span><br><span class="line">     4: invokespecial #4                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">     7: dup</span><br><span class="line">     8: getfield      #2                  // Field i:I</span><br><span class="line">    11: iconst_1</span><br><span class="line">    12: iadd</span><br><span class="line">    13: putfield      #2                  // Field i:I</span><br><span class="line">    16: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>new</p><p>创建一个新对象。</p></li><li><p>dup</p><p>复制顶部操作堆栈值。</p></li><li><p>invokespecial</p><p>调用实例化方法。</p></li><li><p>getfield</p><p>获取对象的字段。</p></li><li><p>iconst_1</p><p>后面的 1 是指令参数，将参数值 push 到操作数栈顶部。</p></li><li><p>iadd</p><p><code>加</code>操作。</p></li><li><p>putfield</p><p>设置对象字段。</p></li><li><p>return</p><p>从方法返回 void。</p></li></ul><p>可以看出，一个单纯的将累的属性值加 1 的操作，其实从获取属性值到结束一共执行了 4 条指令，这个过程中，多线程环境下，执行到中间某个指令时发生线程切换也是有可能的。</p><p>比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    System.out.println(count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">142862</span><br></pre></td></tr></table></figure><p>此时就有可能出现问题：A、B 两个线程对 i 字段进行加 1 操作，初始值为 1，当 A 线程对 i 进行 i已经执行了 iadd，但是还没执行 putfield，切换到了 B 线程，B 线程直接完成了所有字节码操作，此时 i 等于 2，然后 A 线程继续执行，因为 iadd 之后也等于 2，所以执行 putfield 之后，i 还是等于 2，但是两个线程各加 1，最后期望的结果应该是 3 才对，所以上面的代码执行后的实际结果并不是 200000。</p><p>这就是线程切换带来的原子性问题。</p><h3 id="处理器缓存导致了内存可见性问题"><a href="#处理器缓存导致了内存可见性问题" class="headerlink" title="处理器缓存导致了内存可见性问题"></a>处理器缓存导致了内存可见性问题</h3><p>现代的处理器，在 CPU 核心跟内存之间还隔了 L1、L2、L3 一共 3 级的缓存，这三个越往后，离处理器核心越远，缓存空间越大（相对来讲比较大，和内存、硬盘等硬件比起来，不管哪一级缓存都小的可怜），访问速度越慢，但肯定比内存快很多倍。</p><p>这里的 L1、L2、L3 可以理解为 JMM 抽象模型中的本地内存，每个线程访问共享变量时，都会复制到缓存中，修改时，也是修改的缓存中的副本，然后再同步到主内存。</p><p>在单个 CPU 的机器上自然是没问题的，因为所有线程用的都是同一个 CPU 缓存，但是在拥有多个 CPU 的机器上，难免发生多个线程分布在多个不同的 CPU 上执行，每个线程只能看见自己 CPU 的缓存内容，其他 CPU 缓存中的改动是看不见的，这就是多线程情况下的内存可见性的问题。</p><p>其实上一节举的<code>i++</code> 的例子，最终结果不是 200000，也有可能是这个原因。</p><h3 id="指令优化导致重排序问题"><a href="#指令优化导致重排序问题" class="headerlink" title="指令优化导致重排序问题"></a>指令优化导致重排序问题</h3><p>现代的编译器和处理器，为了提升程序性能，会允许指令不按照源代码的顺序执行，甚至有些还会并行执行，这便是指令优化，也就是指令重排序。</p><p>指令重排序，分为 2 大类，3小类：</p><ul><li><p>编译器指令重排序</p><p>编译器在保证不影响单线程执行结果的情况下，允许改变指令执行顺序。</p></li><li><p>处理器指令重排序</p><ul><li><p>指令集并行重排序</p><p>现代处理器采用了指令并行执行技术，在没有数据依赖时，允许多条指令并行执行。</p></li><li><p>内存级重排序</p><p>因为有些处理器使用了写缓冲区，导致读/写操作看起来像是乱序执行。</p></li></ul></li></ul><p>下面举一个简单地例子说明一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> value;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> flag;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">         value=<span class="number">8</span>;</span><br><span class="line">         flag=<span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">             System.out.println(value);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试想现在有两个线程，分别调用 init() 方法和 getValue() 方法，正常来讲，如果 getValue() 有输出值，那就应该是 8，但其实有可能依然是 0，为什么呢？</p><p>因为 <code>value=8</code> 和 <code>flag=true</code> 可能会发生指令重排序，先执行 <code>flag=true</code> 然后执行 <code>value=8</code>，此时对调用 getValue() 的线程来讲，就可能会出现 <code>flag=true</code> 但是 <code>value=0</code> 的情况。</p><blockquote><p>经典的有双重检测机制的单例写法中，就考虑到了指令重排序带来空指针问题，使用 volatile 关键字解决。</p></blockquote><h2 id="原子性问题解决方案"><a href="#原子性问题解决方案" class="headerlink" title="原子性问题解决方案"></a>原子性问题解决方案</h2><p>为了解决多线程切换带来的原子操作问题，Java 提供了一系列原子操作类，比如 AtomicInteger，原理上，都是基于 CAS（Compare And Swap）来解决问题。</p><h2 id="CPU-缓存带来的内存可见性问题解决方案"><a href="#CPU-缓存带来的内存可见性问题解决方案" class="headerlink" title="CPU 缓存带来的内存可见性问题解决方案"></a>CPU 缓存带来的内存可见性问题解决方案</h2><h3 id="基于总线的一致性解决方案"><a href="#基于总线的一致性解决方案" class="headerlink" title="基于总线的一致性解决方案"></a>基于总线的一致性解决方案</h3><p><img src="http://image.hanelalo.cn/image/202204041026988.svg" alt="总线解决方案"></p><p>CPU 都通过总线和内存进行通信，CPU 想要读写数据，就必须发起一个总线事务来从内存读写。</p><h4 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h4><p>当有一个 CPU 通过总线修改了共享数据时，如何保证其他的 CPU 缓存中的缓存失效呢？</p><p>只需要在一个 CPU 修改共享数据时，通知其他 CPU 将自己缓存中的目标缓存行失效即可，后续再读取数据，因为缓存中数据已经过期，就得从内存中获取最新的数据，这种机制就是总线嗅探。</p><ol><li>CPU1 修改缓存数据后发起总线事务，想要同步数据到主内存。</li><li>其他 CPU 收到缓存行失效的消息，将对应的缓存行标记为失效后响应。</li><li>同步新的数据到内存。</li></ol><p>这样，就保证了可见性，即当 CPU1 修改了某个数据后，CPU2 读取到的是最新的修改后的值。</p><h4 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h4><p>前面的总线嗅探是基于两个 CPU 一读一写的情况，那如果多个 CPU 都要写呢？或者说，如果多个 CPU 同时发起总线事务时，要如何应对？</p><p>如果多个 CPU 之间对共享变量的操作顺序不可控，还会导致一致性问题问题。对于这种并发操作，要保证正确性，最容易想到的就是加锁，也确实是这样，只有当前面一个总线事务释放了锁，后面的总线事务才能获取到锁。</p><p>这种机制就是总线仲裁，当发起多个总线事务发起时，由总线仲裁决定谁获得总线使用权。</p><h4 id="总线的性能问题及优化"><a href="#总线的性能问题及优化" class="headerlink" title="总线的性能问题及优化"></a>总线的性能问题及优化</h4><p>通过前面的讲解，不难发现，不过多少个线程，总线仲裁在一个时刻最终只会允许一个总线事务执行，这并发度就不高了，也就是说如果 8 个 CPU，每个时刻其实都有 7 个 CPU 闲着的，因为总线不让跑（经典的 1 核有难，7 核围观）。</p><p>这里的性能问题就在于 CPU 要通过总线和内存进行交互，保证 CPU 之间的可见性。</p><p>那如果减少总线和内存的交互呢？那就少了很多总线仲，性能不就提升了，这种优化主要分读写两方面：一方面要减少对主内存的读操作；一方面减少 CPU 写缓存之后同步到内存的操作。</p><h5 id="减少总线对主内存的读操作"><a href="#减少总线对主内存的读操作" class="headerlink" title="减少总线对主内存的读操作"></a>减少总线对主内存的读操作</h5><ol><li>当一个 CPU1 发起读操作时，如果自己的缓存里没有有效的缓存，就发起一个总线事务读取数据。</li><li>总线首先不直接和内存交互，而是给其他 CPU 发送消息询问是否有相应的有效的缓存。</li><li>其他 CPU 如果有，那就直接复制该缓存行，通过总线传给 CPU1。</li><li>如果没有，总线再和内存交互读取数据。</li></ol><h5 id="减少修改数据后同步缓存到内存的写操作"><a href="#减少修改数据后同步缓存到内存的写操作" class="headerlink" title="减少修改数据后同步缓存到内存的写操作"></a>减少修改数据后同步缓存到内存的写操作</h5><p>如果只有一个线程，其实没必要做这次同步，因为不管内存还是缓存中的数据都只有自己一个线程使用。</p><p>如果是多线程情况下，也没必要每次修改都立马同步到内存，因为可能后面还会修改，而且可能在 n 次修改后，才会有其他线程会读取同一个共享变量，那么就会有 n-1 次的同步都是没必要的。</p><p>所以解决方案是：修改缓存后，不立马同步到内存，而是等到其他线程也发起了该共享变量的读取时，才同步，数据也从独占变成共享。</p><h4 id="MESI-缓存一致性协议"><a href="#MESI-缓存一致性协议" class="headerlink" title="MESI 缓存一致性协议"></a>MESI 缓存一致性协议</h4><p>对于上面的总线解决方案，业界已经有很多实现，比如 MESI、MESOI、MSI，其实都是通过给缓存行设置不同状态标识来实现的。</p><p>MESI 协议为 CPU 缓存中的数据规定了 4 中标识：</p><ul><li>M：Modified，已被修改，该缓存有效，缓存中的数据已经被修改，和其他 CPU 的缓存中数据不一致。</li><li>E：Exclusive，独占，该缓存有效，且不存在于其他 CPU 的缓存中。</li><li>S：Shared，共享，该缓存有效，且和其他 CPU 缓存数据一致。</li><li>I：Invalid，该缓存无效。</li></ul><p>一个简单地状态流转例子：</p><ol><li><p>当 CPU1 先读取了变量 A 到自己的缓存中时，该缓存行是 E 状态，因为只有 CPU1 的缓存中有 A；</p></li><li><p>当 CPU2 也读取了变量 A 到自己的缓存中时，CPU1、CPU2 中缓存行状态都变为 S；</p></li><li><p>当 CPU1 修改了缓存中的 A 变量时，CPU1 中缓存行状态从 S 变为 M，CPU2 收到缓存无效化的消息后，CPU2 中相应的缓存行状态从 S 变为 I；</p></li><li><p>当 CPU2 再次发起 A 的读取请求，自己的缓存无效，需要发起总线事务，CPU1 中的缓存同步到内存，状态从 M 变为 S，CPU2 拿到新值，缓存行状态从 I 变为 S；</p></li></ol><h4 id="MESI-协议优化"><a href="#MESI-协议优化" class="headerlink" title="MESI 协议优化"></a>MESI 协议优化</h4><h5 id="写缓冲区-Store-Buffer"><a href="#写缓冲区-Store-Buffer" class="headerlink" title="写缓冲区 Store Buffer"></a>写缓冲区 Store Buffer</h5><p>在上一节的状态流转的例子中，当 CPU1 修改变量 A 时，因为 A 处于共享状态，所以不能直接修改，还需要通知 CPU2 将自己的缓存失效，当 CPU1 收到 CPU2 已经将缓存失效的 ACK 之后，才会真的修改自己缓存中的数据。</p><p>那么，当 CPU2 还没响应的这段时间，CPU1 就只能等着，CPU 是很快的，这一点点时间也是一种浪费，所以有些处理器增加了写缓冲区，先把新的数据放在写缓冲区中，在 CPU2 还没响应的这段时间继续执行其他指令，等收到 CPU2 的响应后再将写缓冲区的改动同步到缓存中。</p><blockquote><p>这也是在指令重排序中写缓冲区会导致内存指令重排序的原因。</p></blockquote><h5 id="存储转发-Store-Forward"><a href="#存储转发-Store-Forward" class="headerlink" title="存储转发 Store Forward"></a>存储转发 Store Forward</h5><p>当 CPU1 将变量 A 的改动写到写缓冲区后，继续执行后续的指令，如果在 CPU2 响应之前，CPU1 又执行了指令读取 A，这时就会先读取写缓冲区中的值，而不是直接读缓存，这就是存储转发。</p><h5 id="无效化队列-Invalidate-Queue"><a href="#无效化队列-Invalidate-Queue" class="headerlink" title="无效化队列 Invalidate Queue"></a>无效化队列 Invalidate Queue</h5><p>还是前面讲的例子，如果 CPU2 正在执行指令，突然收到缓存失效的消息，如果立马就处理该消息，将缓存行标记为 I，然后响应，那么当这种操作比较频繁时，也是比较耗费性能的，因为可能这个缓存是否失效短期内并不影响，为何不等空闲时再处理呢？</p><p>所以，CPU2 选择收到消息后，将消息扔到一个队列中，然后立马响应，等到空闲时，再来处理队列中的缓存失效的消息，这个队列，就是无效化队列。</p><h4 id="MESI-性能优化带来的问题"><a href="#MESI-性能优化带来的问题" class="headerlink" title="MESI 性能优化带来的问题"></a>MESI 性能优化带来的问题</h4><p>MESI 性能优化加入了写缓冲区和无效化队列两种技术，在没引入之前，虽然有性能问题，但 CPU 之间的缓存数据还是能保持一致的，而引入之后，有些步骤变成异步操作，就变成了弱一致性。</p><p>这也是 JMM 要解决的并发问题。</p><h2 id="重排序问题解决方案"><a href="#重排序问题解决方案" class="headerlink" title="重排序问题解决方案"></a>重排序问题解决方案</h2><p>为了保证多线程环境下的正确性，通过内存屏障指令来禁止指令重排序，在 Java 这种语言里面，为了方便开发人员使用内存屏障，又指定了一些 happen-before 规则来供开发人员参考，而这些规则，则可以通过 volatile、synchronized、final 关键字来使用。</p><blockquote><p>需要知道，内存级重排序的原因是使用了写缓冲区，而内存屏障也是用来弥补写缓冲区带来的问题的。</p></blockquote><h3 id="happen-before-规则"><a href="#happen-before-规则" class="headerlink" title="happen-before 规则"></a>happen-before 规则</h3><p>JMM 制定了一系列隐式的和需要显式使用的 happen-before 规则。</p><ul><li><p>程序顺序规则</p><p>一个线程的任意操作，happen-before 于该线程中的任意后续操作。</p></li><li><p>监视器锁规则</p><p>对于一个锁的解锁，happen-before 于对这个锁的加锁。</p></li><li><p>volatile 变量规则</p><p>对一个 volatile 域的写，happen-before 于对 volatile 域的读。</p></li><li><p>传递性</p><p> A happen-before 于 B，B happen-before 于 C，那么 A happen-before 于 C。</p></li><li><p>start() 规则</p><p>线程的 Thread.start() happen-before 于线程中的任意操作。</p></li><li><p>join() 规则</p><p>如果线程 A 执行 ThreadB.join() 成功返回，那么 ThreadB 中的任意操作 happen-before 于 A 中执行 ThreadB.join() 之后的任意操作。</p></li></ul><p>happen-before 规则为了方便开发者理解而制定的，每一个 happen-before 规则后面可能是通过编译器和处理器禁止多种重排序的规则实现的。</p><p>参考《Java并发编程的艺术》中的图：</p><p><img src="http://image.hanelalo.cn/image/202204041144789.svg" alt="happen-before"></p><h3 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h3><p>保证单线程下不会影响程序执行结果，才会进行指令重排序，比如上面的例子，因为执行 init() 方法的进程认为重排序不会影响当前线程的执行结果，所以就进行了重排序。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障是为了禁止一些指定位置的重排序而采用的技术，分为 Load Barrier 和 Store Barrier，同时也保证了 CPU 修改了共享数据能被其他线程及时感知到数据变动。</p><p>下面结合前面讲到的无效化队列和写缓冲区讲解。</p><h3 id="Load-Barrier"><a href="#Load-Barrier" class="headerlink" title="Load Barrier"></a>Load Barrier</h3><p>读屏障，强制所有在 load barrier 之后的 load 指令，都在 load barrier 指令后执行，并一直等到 load 缓冲区被该 CPU 读完才能执行该 load 指令。</p><p>也就是说，读屏障指令和 load 指令不会重排序，且读屏障会强制 CPU 将无效化队列中的消息处理完之后再执行 load 指令。</p><h3 id="Store-Barrier"><a href="#Store-Barrier" class="headerlink" title="Store Barrier"></a>Store Barrier</h3><p>写屏障，强制所有在写屏障指令之前的 store 指令都在写屏障指令之前执行，并把写缓冲区的数据强制写入 CPU 缓存。</p><p>也就是说，写屏障指令不会和前面的 store 指令重排序，且执行写屏障之后， CPU 写缓冲区的数据都已经同步到缓存。</p><h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>可见性，对一个 volatile 变量的读，总是能看见在此之前任意线程对这个 volatile 变量的最后写入。</li><li>原子性，对单个 volatile 变量的读/写操作具有原子性，而对于 volatile++ 这种复合操作不具有原子性。</li></ul><h3 id="volatile-原理"><a href="#volatile-原理" class="headerlink" title="volatile 原理"></a>volatile 原理</h3><p>volatile 解决的问题是：CPU1 修改了共享变量 A 到自己的写缓冲区，紧接着 CPU2 又去读变量 A 时，因为无效化队列还没处理导致 B 线程读取的是原来的值。</p><p>这种处理方式，其实是使用了内存屏障来禁止一些重排序，并强制操作写缓冲区和无效化队列实现的。</p><p>首先看看 volatile 关键字重排序的规则：</p><table><thead><tr><th align="center">第一个操作</th><th align="center">第二个操作</th><th align="center">是否能重排序</th></tr></thead><tbody><tr><td align="center">普通读/写</td><td align="center">普通读/写</td><td align="center">Y</td></tr><tr><td align="center">普通读/写</td><td align="center">volatile 读</td><td align="center">Y</td></tr><tr><td align="center">普通读/写</td><td align="center">volatile 写</td><td align="center">N</td></tr><tr><td align="center">volatile 读</td><td align="center">普通读/写</td><td align="center">N</td></tr><tr><td align="center">volatile 读</td><td align="center">volatile 读</td><td align="center">N</td></tr><tr><td align="center">volatile 读</td><td align="center">volatile 写</td><td align="center">N</td></tr><tr><td align="center">volatile 写</td><td align="center">普通读/写</td><td align="center">Y</td></tr><tr><td align="center">volatile 写</td><td align="center">volatile 读</td><td align="center">N</td></tr><tr><td align="center">volatile 写</td><td align="center">volatile 写</td><td align="center">N</td></tr></tbody></table><p>可以看出：</p><ul><li>当第二个操作是 volatile 写时，第一个操作不管是什么，都不允许重排序，该规则保证 volatile 写之前的操作不会被重排序到 volatile 写之后。</li><li>当第一个操作是 volatile 读时，第二个操作不管是什么，都不允许重排序，改规则保证 volatile 读之后的操作不会重排序到 volatile 读之前。</li><li>当第一个操作为 volatile 写，第二个操作为 volatile 读时，不允许重排序。</li></ul><p>具体实现时，JMM 是通过插入内存屏障来实现上述的规则：</p><ul><li>在每个 volatile 写之前插入一个 Store-Store 屏障。</li><li>在每个 volatile 写之后插入一个 Store-Load 屏障。</li><li>在每个 volatile 读后面插入一个 Load-Load 屏障。</li><li>在每个 volatile 读后面插入一个 Load-Store 屏障。</li></ul><p>volatile 写之前加入一个 Store-Store 屏障是为了保证之前的共享变量写入已经对其他所有线程可见。</p><p>volatile 写之后加入一个 Store-Load 屏障是为了保证不会和后面的 volatile 读写重排序。</p><p>volatile 读之后加一个 Load-Load 屏障也是为了保证其他线程的写入操作对当前线程可见，也禁止 volatile 读和后面的普通读重排序。</p><p>volatile 读之后加一个 Load-Store 屏障禁止后面的普通读写重排序。</p><p>实际编译时，也会根据实际的情况选择不插入一些没必要的内存屏障。</p><h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><h3 id="happen-before-关系"><a href="#happen-before-关系" class="headerlink" title="happen-before 关系"></a>happen-before 关系</h3><p>首先看一段代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123; <span class="comment">// 1</span></span><br><span class="line">        a++; <span class="comment">// 2</span></span><br><span class="line">    &#125; <span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123; <span class="comment">// 4</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a; <span class="comment">// 5</span></span><br><span class="line">    &#125; <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有两个线程 A、B 分别执行 writer()、reader。</p><p>结果都知道，因为 synchronized 使用锁对象就是当前的对象，也就是 this，所以不会有问题。</p><p>但是结合前面讲到的内存模型来讲，为什么不会出现执行 a++ 之后，reader() 方法的线程缓冲区依然是 a=0 的情况？ </p><p>在前面讲 happen-before 时提到，锁的释放肯定 happen-before 于其他线程获取到锁，基于锁的互斥性，假设 writer() 线程先拿到锁，那么，1 happen-before 2 happen-before 3 happen-before 4 happen-before 5 happen-before 6。</p><p>也就是 2 happen-before 5，所以 2 对共享变量的修改是对 5 可见的。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>简单来讲其实就是，writer() 线程释放锁时，会将改动的数据刷新到主内存中，reader() 线程获取到锁时会将自己的缓存置为无效，后面就只能从内存读取新数据。</p><p>另外，Java 中的 AQS 系列的锁实现，其实核心是基于一个 volatile 修饰的 state 字段实现的，自然也就有了 volatile 相关的保证。</p><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><h3 id="final-关键字重排序规则"><a href="#final-关键字重排序规则" class="headerlink" title="final 关键字重排序规则"></a>final 关键字重排序规则</h3><ul><li>在构造一个对象时，在对象的构造函数对一个 final 域的写入，跟随后将被构造对象赋值给一个变量的操作，这两者不能重排序，比如 A 对象中 b 字段是 final 修改，那么在 A 的构造函数中为 b 字段赋值的操作，跟后续将 A 的对象赋值给另一个变量 a 的操作不能重排序（毕竟先初始化 A 对象，在对 b 赋值也挺奇怪）。</li><li>初次读一个包含 final 域的对象引用，和随后初次读这个 final 域，这两者不能重排序，也就是说 A 对象中有 final 修饰的 b 字段，那么当要访问 <code>A.b</code> 时，肯定是先访问 A，再通过 A 访问 b，这两者不能重排序，编译器在写 final 域之后，构造函数 return 之前，会插入一个 Store-Store 屏障，保证处理器不会把 final 域的写重排序到构造函数外。。</li></ul><blockquote><p>个人感觉这两个规则好像很理所当然，但是计算机是机器，不是有思考的人类。</p></blockquote><blockquote><p>所以普通成员变量可能就会被重排序到构造函数 return 之后。</p></blockquote><h3 id="引用类型-final-域"><a href="#引用类型-final-域" class="headerlink" title="引用类型 final 域"></a>引用类型 final 域</h3><p>对于 final 域的引用类型，增加了如下约束：</p><p>在构造函数内对一个 final 引用对象的成员域的写入，跟随后在构造函数外将被构造对象赋值给一个变量，这两者不能重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalReferenceExample</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] arrays;</span><br><span class="line">    <span class="keyword">static</span> FinalReferenceExample obj;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> FinalReferenceExample &#123;</span><br><span class="line">        arrays = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>]; <span class="comment">// 1</span></span><br><span class="line">        arrays[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writerOne</span><span class="params">()</span> &#123; <span class="comment">// 线程 A</span></span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">FinalReferenceExample</span>(); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writerTwo</span><span class="params">()</span> &#123; <span class="comment">// 线程 B</span></span><br><span class="line">        obj.arrays[<span class="number">0</span>] = <span class="number">2</span>; <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123; <span class="comment">// 线程 C</span></span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="literal">null</span>) &#123; <span class="comment">// 5</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> obj.arrays[<span class="number">0</span>]; <span class="comment">// 6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在如果一个线程 A 先执行 writerOne()，然后 B 在致辞那个 writerTwo()，最后 C 执行 reader()。</p><p>最终 reader() 中的 tmp 变量可能依然是 1 而不是 2。</p><p>整个过程中，因为 final 域的重排序规则，所以 1 happen-before 3，2 happen-before 3，所以 C 线程中如果 obj 不为 null，那么肯定能看见 arrays[0] 的初始值，而线程 B 虽然将 arrays[0] 改成了 2，但因内存可见性问题，可能并没有来得及同步到内存。 </p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li>《Java 并发编程的艺术》方腾飞  魏鹏  程晓明  著</li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/84500221">并发基础理论：缓存可见性、MESI协议、内存屏障、JMM</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Kubernetes中的Pod</title>
      <link href="posts/08137c989969.html"/>
      <url>posts/08137c989969.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/image/202203282124366.jpg'><span id="more"></span><h1 id="K8s-Pod-浅析"><a href="#K8s-Pod-浅析" class="headerlink" title="K8s Pod 浅析"></a>K8s Pod 浅析</h1><h2 id="从-Kubernetes-的架构讲起：为什么需要-Pod？"><a href="#从-Kubernetes-的架构讲起：为什么需要-Pod？" class="headerlink" title="从 Kubernetes 的架构讲起：为什么需要 Pod？"></a>从 Kubernetes 的架构讲起：为什么需要 Pod？</h2><p>在 Docker 中，常常提到的名词是容器，试着想一下 K8s 的架构。</p><p><img src="http://image.hanelalo.cn/image/202203282132359.svg" alt="kubernetes 架构"></p><blockquote><p>取自 <a href="https://kubernetes.io/docs/concepts/overview/components/">kubernetes 官网</a>。</p></blockquote><ul><li>Control Plane，控制面板，在集群的 master 节点上，一般情况下，master 节点也不会被调度运行应用 Pod，控制面板上的组件有 <code>api-server</code>、<code>etcd</code>、<code>scheduler</code>、<code>controller-manager</code>。<ul><li>api-server，是 k8s 对外暴露的api。</li><li>etcd，k8s 集群的后端存储，高可用的 KV 数据库。</li><li>scheduler，调度器，当要创建一个 Pod 的时候，调度器会负责选择一个节点来运行这个 Pod。</li><li>controller-maneger，负责一些诸如节点故障通知、监控节点状态、为 Pod 填充 Endpoints 新的等工作。</li></ul></li><li>Node，其实就是 Kubernetes 的工作节点，Pod 都在这些工作节点上运行。</li></ul><p>假如现在又两个应用 A、B，A 和 B 之前经常发生数据交互，网络交互、文件交互都行，考虑到性能，我们肯定更愿意将这两个应用放到一台服务器上部署以提高交互的速度，假设 A 需要占用 1G 内存，B 需要占用 2G 内存，现在 K8s 集群有两个 node，其中一个 node1 内存还剩 2G，其中一个 node2 剩余 3G，当开始创建容器时，首先创建 A，发现 node1 还剩 2G，可以运行 A，所以在 node1 上运行 A，因为我们希望 A、B 在一台服务器上，所以 B 也在 node1 上创建，但是发现剩余的内存资源不够了，这个时候就只能失败。</p><p>针对上面的场景，可以考虑根据两个容器的资源总和来决定调度到哪个 node，那就势必要阻塞调度进程，等到所有容器创建指令到达时才能决定调度到哪个 node，这是个调度的性能问题。</p><p>以上是基于 Docker 的角度考虑的，调度的单位是容器，k8s 的思想有所不同，为了解决上述的问题，k8s 调度的单位是 Pod，每一个 Pod 中可以有强相关的多个容器，这样就能保证不会出现上述情况。</p><blockquote><p>似乎只是换了个说法而已，但这确实是 Kubernetes 相对于 Mesos、Docker Swarm 等编排系统的一大优点，因为基本的思想不同，所以实现的时候肯定也天差地别，代码堆上去之后，是很不好回头的。</p></blockquote><p><strong>所以，Pod 虽然是一个逻辑概念，但是它的出现是为了在实现容器编排的同时，还能自动的处理容器之间的复杂依赖关系。</strong></p><h2 id="如何创建一个-Pod？"><a href="#如何创建一个-Pod？" class="headerlink" title="如何创建一个 Pod？"></a>如何创建一个 Pod？</h2><p>k8s 创建 Pod 或者 Service 等对象也好，都可以使用 <code>kubectl apply -f &lt;config.yml&gt;</code> 来根据编写好的配置文件创建。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="comment">#namespace: nginx</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面就是一个简单的 nginx Pod 的配置文件。</p><ul><li>apiVersion，顾名思义，api 的版本而已。</li><li>kind，表示当前要创建的对象类型，比如 Pod、Deployment、Service。</li><li>metadata，要创建的资源的元数据，比如资源名称，所属命名空间和一些 label 标识。</li><li>spec，这一部分就是真正的 Pod 的内容了，比如 Pod 里面都有哪些容器，这里只是一个 nginx 容器</li></ul><p><code>imagePullPolicy</code> 是创建容器时的镜像拉取策略，<code>Always</code> 是永远从镜像仓库拉，<code>IfNotPresent</code> 是如果本地没有再拉取，<code>Never</code> 是不拉镜像，本地没有就报错。</p><p>然后执行 <code>kubectl apply -f nginx.yaml</code>，因为没有执行命名空间，所以默认是创建在 <code>default</code> 命名空间。</p><p>然后查看 Pod：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod</span><br></pre></td></tr></table></figure><p>就能看见 Pod 的一些简单的信息，如果创建时指定了命名空间，只需要在后面再加上 <code>-n &lt;namespace&gt;</code> 即可。</p><p>虽然这样也可以创建，但是，在生产环境中，我们很多应用可不止一个实例，而是会有多个实例，这样如果其中一个挂了，还有其他的可用，所以一般无状态的应用的 Pod 都是通过 Deployment 对象进行管理：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx-deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br></pre></td></tr></table></figure><p>会发现 template 部分和前面的 Pod 的内容很像，其实就是，只不过 Deployment 对象又多了一些属性，主要还是在 spec 下面：</p><ul><li>selector，用来选择这个 Deployment 要管理哪些 Pod，这里的意思时管理 label 中 app 属性为 nginx 的 Pod。</li><li>replicas，创建的 Pod 数量。</li></ul><p>执行文件 <code>kubectl apply -f nginx-deployment.yaml</code>，然后查看 Pod 就会发现启动了两个 nginx 的 Pod。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod -n nginx</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-66857ff745-2jb9m   1/1     Running   0          36m</span><br><span class="line">nginx-66857ff745-k2fvf   1/1     Running   0          36m</span><br></pre></td></tr></table></figure><h2 id="配置容器健康检查和恢复"><a href="#配置容器健康检查和恢复" class="headerlink" title="配置容器健康检查和恢复"></a>配置容器健康检查和恢复</h2><p>在生产环境中，对于应用是否存活这件事，不能以容器是否在运行来判断。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># liveness.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">                <span class="attr">test:</span> <span class="string">liveness</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">test-liveness-exec</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">        <span class="attr">containers:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness</span></span><br><span class="line">                  <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">                  <span class="attr">args:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">touch</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">30</span><span class="string">;</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">600</span></span><br><span class="line">                  <span class="attr">livenessProbe:</span></span><br><span class="line">                        <span class="attr">exec:</span></span><br><span class="line">                                <span class="attr">command:</span></span><br><span class="line">                                        <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">                                        <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line">                        <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">                        <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>上面的 Pod，在启动后会在 /tmp 目录下创建 healthy 文件，然后 30s 后删除，后面的 livenessProbe 就是配置健康检查的内容，表示执行 <code>cat /tmp/healthy</code> 命令，启动后 5s 执行，每 5s 一次。</p><p>当 Pod “不健康” 时会根据 Pod 的重启策略 <code>restartPolicy</code> 决定如何处理。</p><ul><li>Always，只要不是 Running，直接重启。</li><li>OnFailure，容器异常时重启。</li><li>Never，从不重启。</li></ul><p>这个配置会对 Pod 中的所有容器生效。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 集群搭建</title>
      <link href="posts/57c3525593bc.html"/>
      <url>posts/57c3525593bc.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/image/202203262057512.png'/><span id="more"></span><p>主要是通过 kubeadm 安装，kubeadm 将 k8s 的大部分组件直接以容器的形式进行安装。 </p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul><li>两台腾讯云服务器</li><li>每台服务器 50G 云硬盘</li><li>每台服务器 2 核 8G</li><li>通外网，两台服务器内网互通</li></ul><h1 id="Master-节点安装"><a href="#Master-节点安装" class="headerlink" title="Master 节点安装"></a>Master 节点安装</h1><h2 id="安装-kubeadm-和-Docker"><a href="#安装-kubeadm-和-Docker" class="headerlink" title="安装 kubeadm 和 Docker"></a>安装 kubeadm 和 Docker</h2><p>安装的时候需要下载一些镜像，众所周知的原因，国内最好使用阿里云的源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get update &amp;&amp; apt-get install -y apt-transport-https</span><br><span class="line"></span><br><span class="line">$ curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -</span><br><span class="line"> </span><br><span class="line">$ <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">$ apt-get update</span><br><span class="line">$ apt-get install -y docker.io kubeadm</span><br></pre></td></tr></table></figure><p>初次之外还需要配置一下 docker 镜像仓库的地址，和一些必要参数，直接编辑 <code>/etc/docker/daemon.json</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;exec-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;native.cgroupdriver=systemd&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://&lt;yours&gt;.mirror.aliyuncs.com&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>registry-mirrors 的配置可以到自己的阿里云账号的镜像加速服务下找到。</p></blockquote><p>重启 docker 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="开始初始化-master"><a href="#开始初始化-master" class="headerlink" title="开始初始化 master"></a>开始初始化 master</h2><p>先写一个部署配置脚本 <code>kubeadm.yaml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">controllerManager:</span></span><br><span class="line">        <span class="attr">extraArgs:</span></span><br><span class="line">                <span class="attr">horizontal-pod-autoscaler-sync-period:</span> <span class="string">&quot;10s&quot;</span></span><br><span class="line">                <span class="attr">node-monitor-grace-period:</span> <span class="string">&quot;10s&quot;</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line">        <span class="attr">extraArgs:</span></span><br><span class="line">                <span class="attr">runtime-config:</span> <span class="string">&quot;api/all=true&quot;</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">registry.aliyuncs.com/google_containers</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="string">&quot;latest-1.23&quot;</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">podSubnet:</span> <span class="string">&quot;192.168.0.0/16&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>因为后面网络插件安装遇见了问题，参考<a href="https://github.com/flannel-io/flannel/issues/1344%EF%BC%8C%E6%89%80%E4%BB%A5%E5%8A%A0%E4%BA%86">https://github.com/flannel-io/flannel/issues/1344，所以加了</a> networking 配置，虽然后面安装的是 calico 网络插件而不是 flannel，但也同样需要这个配置。</p></blockquote><p>然后开始初始化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm init --config kubeadm.yaml</span><br></pre></td></tr></table></figure><blockquote><p>如果前面没有对 docker 设置 <code>native.cgroupdriver=systemd</code> 参数，那么在 init 过程中连接  kubelet 会报错：</p><p>[kubelet-check] The HTTP call equal to ‘curl -sSL <a href="http://localhost:10248/healthz&#39;">http://localhost:10248/healthz&#39;</a> failed with error: Get “<a href="http://localhost:10248/healthz&quot;">http://localhost:10248/healthz&quot;</a>: dial tcp 127.0.0.1:10248: connect: connection refused.</p></blockquote><p><code>kubeadm init</code> 命令执行完之后，末尾的日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 172.30.0.8:6443 --token go067l.k66gt7fx2cpjz04v \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:98d7b902a634dbcb0a52c1f6650a103616f8ddaf9a5a9d59cb4fdb223e461c44</span><br></pre></td></tr></table></figure><p>日志提示要开始使用集群需要手动执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">$ sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">$ sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><p>Kubernetes 集群默认需要加密方式访问。所以，这几条命令，就是将刚刚部署生成的 Kubernetes 集群的安全配置文件，保存到当前用户的.kube 目录下，kubectl 默认会使用这个目录下的授权信息访问 Kubernetes 集群。</p><p><strong>最后几行还打出了一个 <code>kubeadm join</code> 命令及其参数键值对，这个需要记下来，因为部署 Worker 节点时需要通过这个命令加入集群。</strong></p><p>查看当前唯一的节点的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-8-ubuntu:/home/ubuntu<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME            STATUS     ROLES                  AGE     VERSION</span><br><span class="line">vm-0-8-ubuntu   NotReady   control-plane,master   4m37s   v1.23.5</span><br></pre></td></tr></table></figure><p>当前是 NotReady 状态，使用 <code>kubectl describe node vm-0-8-ubuntu</code> 查看节点详细新鞋，其中 <code>vm-0-8-ubuntu</code> 是节点名称，执行结果太长了，打出的日志中有这样一段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ready            False   Sat, 26 Mar 2022 14:51:32 +0800   Sat, 26 Mar 2022 14:46:10 +0800   KubeletNotReady              container runtime network not ready: NetworkReady=<span class="literal">false</span> reason:NetworkPluginNotReady message:docker: network plugin is not ready: cni config uninitialized</span><br></pre></td></tr></table></figure><p>意思是尚未部署任何网络插件。</p><p>可以使用 <code>kubectl get pods -n kube-system</code> 查看 kube-system 命名空间的 pod 状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-8-ubuntu:/home/ubuntu<span class="comment"># kubectl get pods -n kube-system</span></span><br></pre></td></tr></table></figure><p>kube-system 是 k8s 预留给系统 pod 的命名空间（非 Linux Namespace），CoreDNS 因为依赖网络插件，所以没起起来。</p><h2 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h2><p>安装calico网络插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f https://projectcalico.docs.tigera.io/manifests/tigera-operator.yaml</span><br><span class="line">$ kubectl create -f https://projectcalico.docs.tigera.io/manifests/custom-resources.yaml</span><br></pre></td></tr></table></figure><h1 id="部署-Worker-节点"><a href="#部署-Worker-节点" class="headerlink" title="部署 Worker 节点"></a>部署 Worker 节点</h1><p>安装好 kubeadm 和 docker，然后执行 master 节点安装好之后日志中的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm <span class="built_in">join</span> 172.30.0.8:6443 --token bhtlzk.hwqr6ix8broo4vr7 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:39ae952bddbc1f12090887c8a6b7f2243a75c112b0d478f120b0fe84f562e77a</span><br></pre></td></tr></table></figure><p>然后日志会提醒在 master 节点执行 <code>kubectl get nodes</code> 可以看见集群状态。</p><p>等待一会儿，在集群执行<code>kubectl get nodes</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-8-ubuntu:/home/ubuntu# kubectl get nodes</span><br><span class="line">NAME            STATUS   ROLES                  AGE    VERSION</span><br><span class="line">vm-0-5-ubuntu   Ready    &lt;none&gt;                 2m7s   v1.23.5</span><br><span class="line">vm-0-8-ubuntu   Ready    control-plane,master   24m    v1.23.5</span><br></pre></td></tr></table></figure><h1 id="部署容器存储插件"><a href="#部署容器存储插件" class="headerlink" title="部署容器存储插件"></a>部署容器存储插件</h1><p>这里选用的是 rook 插件，整体来讲这款插件的各方面功能比较全面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --single-branch --branch v1.8.7 https://github.com/rook/rook.git</span><br><span class="line">$ <span class="built_in">cd</span> rook/deploy/examples</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">bucket-notification-endpoint.yaml     create-external-cluster-resources.sh  object-bucket-claim-delete.yaml        pool-device-health-metrics.yaml</span><br><span class="line">bucket-notification.yaml              csi                                   object-bucket-claim-notification.yaml  pool-ec.yaml</span><br><span class="line">bucket-topic.yaml                     dashboard-external-https.yaml         object-bucket-claim-retain.yaml        pool-mirrored.yaml</span><br><span class="line">ceph-client.yaml                      dashboard-external-http.yaml          object-ec.yaml                         pool-test.yaml</span><br><span class="line">cluster-external-management.yaml      dashboard-ingress-https.yaml          object-external.yaml                   pool.yaml</span><br><span class="line">cluster-external.yaml                 dashboard-loadbalancer.yaml           object-multisite-pull-realm-test.yaml  rbdmirror.yaml</span><br><span class="line">cluster-on-local-pvc.yaml             direct-mount.yaml                     object-multisite-pull-realm.yaml       README.md</span><br><span class="line">cluster-on-pvc.yaml                   filesystem-ec.yaml                    object-multisite-test.yaml             rgw-external.yaml</span><br><span class="line">cluster-stretched-aws.yaml            filesystem-mirror.yaml                object-multisite.yaml                  storageclass-bucket-delete.yaml</span><br><span class="line">cluster-stretched.yaml                filesystem-test.yaml                  object-openshift.yaml                  storageclass-bucket-retain.yaml</span><br><span class="line">cluster-test.yaml                     filesystem.yaml                       object-test.yaml                       subvolumegroup.yaml</span><br><span class="line">cluster.yaml                          images.txt                            object-user.yaml                       toolbox-job.yaml</span><br><span class="line">common-external.yaml                  import-external-cluster.sh            object.yaml                            toolbox.yaml</span><br><span class="line">common-second-cluster.yaml            monitoring                            operator-openshift.yaml                volume-replication-class.yaml</span><br><span class="line">common.yaml                           mysql.yaml                            operator.yaml                          volume-replication.yaml</span><br><span class="line">crds.yaml                             nfs-test.yaml                         osd-env-override.yaml                  wordpress.yaml</span><br><span class="line">create-external-cluster-resources.py  nfs.yaml                              osd-purge.yaml</span><br></pre></td></tr></table></figure><p>东西挺多的，反正安装的 rook 插件，安装教程参考<a href="https://rook.github.io/docs/rook/v1.8/quickstart.html">https://rook.github.io/docs/rook/v1.8/quickstart.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f common.yaml</span><br><span class="line">$ kubectl apply -f operator.yaml</span><br><span class="line">$ kubectl apply -f crds.yaml</span><br><span class="line">$ kubectl apply -f cluster.yaml</span><br></pre></td></tr></table></figure><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><p>国内源配置：<a href="https://cloud.tencent.com/developer/article/1353427">https://cloud.tencent.com/developer/article/1353427</a></p><p>连接 kubelet 失败：<a href="https://segmentfault.com/a/1190000041553731">https://segmentfault.com/a/1190000041553731</a></p><p>更改配置：<a href="https://blog.csdn.net/oceanyang520/article/details/103948450">https://blog.csdn.net/oceanyang520/article/details/103948450</a></p><p>calico: <a href="https://projectcalico.docs.tigera.io/getting-started/kubernetes/quickstart">https://projectcalico.docs.tigera.io/getting-started/kubernetes/quickstart</a></p><p>rook: <a href="https://rook.github.io/docs/rook/v1.8/quickstart.html">https://rook.github.io/docs/rook/v1.8/quickstart.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 容器原理浅析</title>
      <link href="posts/c98e3542f944.html"/>
      <url>posts/c98e3542f944.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/image/2022032412483123.jpg'/><span id="more"></span><h1 id="Docker-容器原理浅析"><a href="#Docker-容器原理浅析" class="headerlink" title="Docker 容器原理浅析"></a>Docker 容器原理浅析</h1><p>在微服务盛行的时代，相对于虚拟机更轻量级的容器技术应运而生，其中 Docker 被广泛应用，虽然现在还有 Podman 等一些新兴的容器管理工具，但万变不离其宗，我们只需要知道容器到底是如何产生，如何运行的。</p><h2 id="容器和虚拟机的区别是什么？"><a href="#容器和虚拟机的区别是什么？" class="headerlink" title="容器和虚拟机的区别是什么？"></a>容器和虚拟机的区别是什么？</h2><p>要搞清楚这两者的区别，首先得知道容器和虚拟机的原理，从原理的角度，才能明白这两者的区别。</p><p>我们知道，虚拟机本质上是基于虚拟化技术（比如 Hypervisor），模拟出了一套硬件，在这套硬件上面运行了一个完整的操作系统。</p><p><img src="http://image.hanelalo.cn/image/202203252242870.svg" alt="虚拟机"></p><p>而容器一直被称为“轻量级虚拟化技术”，这种说法是为了和虚拟机对比，这种说法本身，严格来讲其实是错的。</p><p>因为容器本身其实是宿主机上的一个进程，只不过这个进程被做了各种限制和隔离，这是下一节的内容。</p><p><img src="http://image.hanelalo.cn/image/202203252249140.svg" alt="容器原理"></p><p>我们知道，操作系统本身所携带的类库是很庞大的，庞大到可能其中大部分都不是运行的应用会依赖的。</p><p>虚拟机不会考虑应用是否需要，直接无脑提供了一个完整的操作系统。容器则只是将必要的一些库封装到了镜像中，所以才会有“轻量级虚拟化技术”的说法，并且，通过上面的两张提可以看出，虚拟机中的应用，是虚拟机操作系统的进程，而容器化的应用本身其实是宿主机的一个进程，Docker Engine 只是起一个管理和控制的作用。</p><p>那么，容器这种像沙盒一样的机制，是如何实现的？</p><h2 id="如何实现容器的沙盒？"><a href="#如何实现容器的沙盒？" class="headerlink" title="如何实现容器的沙盒？"></a>如何实现容器的沙盒？</h2><h3 id="Linux-Namespace"><a href="#Linux-Namespace" class="headerlink" title="Linux Namespace"></a>Linux Namespace</h3><p>首先启动一个容器，方便分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it busybox /bin/sh</span><br></pre></td></tr></table></figure><p>此时会进入刚创建的容器，在容器内执行 <code>ps</code> 命令查看进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps</span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:00 /bin/sh</span><br><span class="line">    6 root      0:00 ps</span><br></pre></td></tr></table></figure><p>此时容器内由两个进程，一个是 <code>/bin/sh</code>，PID 为 1，另一个是 <code>ps</code> 命令的进程，编号为 6。</p><p>上一章讲到，docker 容器本质上是宿主机的一个进程，但是为什么在容器内，看见的容器主进程的 PID 是 1 呢？</p><p>这是因为采用了 Linux Namespace 技术，为容器做了一层隔离，这里使用的是 PID Namespace，让容器内的进程以为自己的是 1 号进程。</p><p>除了 PID Namespace，还有下一章会讲到的 Mount Namespace，和做网络隔离的 Network Namespace 等。</p><p>综上，Linux Namespace 技术主要是改变了容器进程的视图，让容器进程产生了“幻觉”，像 <code>docker exec</code> 命令和 <code>docker run</code> 指令的 <code>-net</code> 参数其实就是基于 Namespace 技术实现的，将容器进程加入到目标 Namespace 即可。</p><h3 id="Linux-Cgroups"><a href="#Linux-Cgroups" class="headerlink" title="Linux Cgroups"></a>Linux Cgroups</h3><p>在做了隔离之后，还需要考虑一个问题，那就是服务器资源占用问题。</p><p>比如，我们如果不对容器使用的内存做限制。宿主机的内存有 16G，宿主机上运行着很多容器，其中一个容器因为发生异常导致使用的内存一直上涨，直到将宿主机的 16G 用完，那么其他的容器也会因此而异常，因为内存不够。</p><p>上面这种情况，如果是可以接受的，那么对于严重依赖容器的微服务来讲，容器变得毫无意义，因为挂了一个应用，其他的全挂了。</p><p>所以，容器还需要对 内存、CPU、带宽等资源的使用做限制，这里使用的是 Linux Cgroups 技术。</p><p>Linux Cgroups 技术，可以限制进程使用的 CPU、带宽、磁盘、内存等资源做限制。</p><p>Linux 秉承着一切皆文件的原则，Linux Cgroups 技术不例外，我们可以通过 <code>mount -t cgroup</code> 命令查看操作系统为 cgroup 技术挂载的相关文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ mount -t cgroup</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,net_prio,net_cls)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br></pre></td></tr></table></figure><p>可以知道这些文件都在 <code>/sys/fs/cgroup</code> 目录下，其中有 cpu、memory、cpuset、devices 等类型，这些表示可以使用多个 Cgroups 资源类型。</p><p>在每种资源类型中，又有多种限制方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ ll /sys/fs/cgroup/cpu</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  3 root root 0 Mar 20 22:23 YunJing</span><br><span class="line">-rw-r--r--  1 root root 0 Mar 20 22:22 cgroup.clone_children</span><br><span class="line">--w--w--w-  1 root root 0 Mar 20 22:22 cgroup.event_control</span><br><span class="line">-rw-r--r--  1 root root 0 Mar 20 22:22 cgroup.procs</span><br><span class="line">-r--r--r--  1 root root 0 Mar 20 22:22 cgroup.sane_behavior</span><br><span class="line">-rw-r--r--  1 root root 0 Mar 20 22:22 cpu.cfs_period_us</span><br><span class="line">-rw-r--r--  1 root root 0 Mar 20 22:22 cpu.cfs_quota_us</span><br><span class="line">-rw-r--r--  1 root root 0 Mar 20 22:22 cpu.rt_period_us</span><br><span class="line">-rw-r--r--  1 root root 0 Mar 20 22:22 cpu.rt_runtime_us</span><br><span class="line">-rw-r--r--  1 root root 0 Mar 20 22:22 cpu.shares</span><br><span class="line">-r--r--r--  1 root root 0 Mar 20 22:22 cpu.stat</span><br><span class="line">-r--r--r--  1 root root 0 Mar 20 22:22 cpuacct.stat</span><br><span class="line">-rw-r--r--  1 root root 0 Mar 20 22:22 cpuacct.usage</span><br><span class="line">-r--r--r--  1 root root 0 Mar 20 22:22 cpuacct.usage_percpu</span><br><span class="line">drwxr-xr-x  3 root root 0 Mar 25 23:03 docker</span><br><span class="line">-rw-r--r--  1 root root 0 Mar 20 22:22 notify_on_release</span><br><span class="line">-rw-r--r--  1 root root 0 Mar 20 22:22 release_agent</span><br><span class="line">drwxr-xr-x 59 root root 0 Mar 25 22:58 system.slice</span><br><span class="line">-rw-r--r--  1 root root 0 Mar 20 22:22 tasks</span><br><span class="line">drwxr-xr-x  2 root root 0 Mar 20 22:22 user.slice</span><br></pre></td></tr></table></figure><blockquote><p>YunJing 这个文件夹应该是因为我使用的是腾讯云的虚拟机才会有的。</p></blockquote><p>这其中有很多的文件，比如 <code>cfs_quota_us</code> 和 <code>cfs_period_us</code> 这两个文件就是限制进程在长度为 cfs_period 的时间内，只能被分配到总量为 cfs_quota 的 CPU 时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> cpu.cfs_quota_us</span><br><span class="line">-1</span><br><span class="line">$ <span class="built_in">cat</span> cpu.cfs_period_us</span><br><span class="line">100000</span><br></pre></td></tr></table></figure><p>cfs_quota 配置为 -1 表示不限制。</p><p>那么，如何知道这个规则限制哪些进程呢？</p><p>同级目录下有一个 tasks 文件，里面记录了限制的进程 ID。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> tasks</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面我们看见的是操作系统最原始的限制，那如果现在我们需要自定义限制某些进程的 CPU 资源使用，可以在 cpu 这个目录下新建一个文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/sys/fs/cgroup/cpu</span><br><span class="line">$ <span class="built_in">mkdir</span> <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">cgroup.clone_children  cpu.cfs_period_us  cpu.rt_runtime_us  cpuacct.stat          notify_on_release</span><br><span class="line">cgroup.event_control   cpu.cfs_quota_us   cpu.shares         cpuacct.usage         tasks</span><br><span class="line">cgroup.procs           cpu.rt_period_us   cpu.stat           cpuacct.usage_percpu</span><br></pre></td></tr></table></figure><p>会发现当我们在 cpu 目录下新建一个文件夹时，文件夹里面也自动新建了一些限制方法的文件。</p><p>现在我们在操作系统中运行一个死循环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">while</span> : ; <span class="keyword">do</span> : ; <span class="keyword">done</span> &amp;</span><br><span class="line">[1] 17851</span><br></pre></td></tr></table></figure><p>死循环的 PID 为 17851，当前的 top 显示这个死循环占用了 100% 的 CPU。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">top - 09:25:57 up 5 days, 11:03,  3 <span class="built_in">users</span>,  load average: 0.74, 0.26, 0.12</span><br><span class="line">Tasks: 105 total,   2 running, 103 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s): 50.4 us,  0.3 sy,  0.0 ni, 49.1 <span class="built_in">id</span>,  0.2 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  3880192 total,   193944 free,   712920 used,  2973328 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  2884072 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">17851 root      20   0  116180   1232    192 R 100.0  0.0   1:22.74 bash</span><br><span class="line"> 2048 root      20   0  678192  12472   2416 S   0.7  0.3  37:51.62 barad_agent</span><br><span class="line"> 2182 root      20   0  973884  40268  18308 S   0.7  1.0  81:16.49 YDService</span><br><span class="line">    1 root      20   0   43620   4056   2596 S   0.0  0.1   0:30.75 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.23 kthreadd</span><br><span class="line">    4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H</span><br><span class="line">    6 root      20   0       0      0      0 S   0.0  0.0   0:02.18 ksoftirqd/0</span><br><span class="line">    7 root      rt   0       0      0      0 S   0.0  0.0   0:01.58 migration/0</span><br><span class="line">    8 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_bh</span><br><span class="line">    9 root      20   0       0      0      0 S   0.0  0.0   1:00.04 rcu_sched</span><br><span class="line">   10 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 lru-add-drain</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>紧接着，我们在 test 文件夹下面，为这个进程加上 cpu 使用限制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 20000 &gt; cpu.cfs_quota_us</span><br><span class="line">$ <span class="built_in">echo</span> 17851 &gt; tasks</span><br><span class="line">$ <span class="built_in">cat</span> cpu.cfs_period_us</span><br><span class="line">100000</span><br></pre></td></tr></table></figure><p>第一行将 CPU 时间限制为 20 ms（20000 us），因为 cfs_period_us 中写入的时 100000，所以受这个规则限制的进程最多占用 20% 的 CPU；</p><p>第二行将限制的 PID 写入 tasks；</p><p>然后再看看此时的 top：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">17851 root      20   0  116180   1232    192 R  19.9  0.0   4:21.69 bash</span><br><span class="line"> 2182 root      20   0  973992  40284  18308 S   1.0  1.0  81:20.40 YDService</span><br><span class="line">   12 root      rt   0       0      0      0 S   0.3  0.0   0:01.19 watchdog/1</span><br><span class="line"> 1144 root      20   0  520420  46404  16708 S   0.3  1.2   6:33.87 containerd</span><br><span class="line"> 2047 root      20   0  165192   9448   2052 S   0.3  0.2   5:32.34 barad_agent</span><br><span class="line"> 2048 root      20   0  678192  12472   2416 S   0.3  0.3  37:53.62 barad_agent</span><br><span class="line"> 9006 mysql     20   0 1841484 436844  18664 S   0.3 11.3  10:47.80 mysqld</span><br><span class="line">    1 root      20   0   43620   4056   2596 S   0.0  0.1   0:30.77 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.23 kthreadd</span><br><span class="line">    4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H</span><br><span class="line">    6 root      20   0       0      0      0 S   0.0  0.0   0:02.18 ksoftirqd/0</span><br><span class="line">    7 root      rt   0       0      0      0 S   0.0  0.0   0:01.58 migration/0</span><br><span class="line">    8 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_bh</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>确实从 100% 降到了 20%，这说明 Linux Cgroups 技术还是生效了。</p><p>除了 cpu 的限制能力， Cgroups 技术还有其他的一些限制能力，比如：</p><ul><li>blkio 用来限制 I/O；</li><li>cpuset 用来指定 cpu 核和对应内存节点；</li><li>memory 用来限制内存；</li></ul><p>综上，容器的两大核心技术就是 Linux Namespace 用来做进程隔离，Linux Cgroups 技术用来做进程资源限制。</p><h2 id="容器的文件系统"><a href="#容器的文件系统" class="headerlink" title="容器的文件系统"></a>容器的文件系统</h2><h3 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h3><p>和上一章一样，先启动一个容器，从容器内部开始讲起。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --<span class="built_in">rm</span> -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>此时会直接进入容器内，再容器内执行 <code>ls</code>，会发现和宿主机（我的是腾讯云 CentOS 7）一样的目录结构，但是执行 <code>ll /tmp</code> 就会发现只是结构一样而已，实际的内容和宿主机根本不一样，就仿佛是容器内有完整的一套 ubuntu 的文件。</p><p>其实，因为运行的就是 ubuntu 的镜像，单看文件，确实是有一个完整的 ubuntu 的文件结构。那么，这种在容器内仿佛看见的就是一个真的操作系统的现象，是如何实现的呢？</p><p>首先要从 chroot 说起，维基百科的解释是：</p><blockquote><p>A <strong><code>chroot</code></strong> on <a href="https://en.wikipedia.org/wiki/Unix">Unix</a> and <a href="https://en.wikipedia.org/wiki/Unix-like">Unix-like</a> <a href="https://en.wikipedia.org/wiki/Operating_system">operating systems</a> is an operation that changes the apparent <a href="https://en.wikipedia.org/wiki/Root_directory">root directory</a> for the current running process and its <a href="https://en.wikipedia.org/wiki/Child_process">children</a>. </p><p>在 Unix 和类 Unix 操作系统中，chroot 是一个能改变当前进程及其子进程的执行根目录的操作指令。</p></blockquote><p>简单来讲，就是改变进程看见的 <code>/</code> 目录，使用了 chroot 指令后，进程看见的 <code>/</code> 目录可能在宿主机上并不是 <code>/</code> 而是一个其他的什么目录。</p><p>在上一章提到的 Mount Namespace 技术就是基于 chroot 不断改良后的产物，也是第一个 Namespace。</p><blockquote><p>需要注意的是，Mount Namespace 虽然改变的是进程的文件视图，但其实是伴随着文件挂载的发生，才会改变进程的文件试图，如果某个进程启动后没有做挂载，就算开启了 Mount Namespace，那么它的执行目录依然将继承自宿主机（这是废话）。</p></blockquote><p>基于此，就能做到为容器进程准备一个完整的执行目录，比如我在 CentOS 7 上运行一个 ubuntu 的容器，其实是在素质及上的不是 CentOS 7 根目录的某个地方，有这个 ubuntu 容器运行时的完整的文件目录，比如 <code>docker_asdasfa</code>，然后 Docker Engine 将容器进程的执行根目录切换到了这个 <code>docker_asdasfa</code> 目录下，就完成了文件系统的隔离，容器内看见的就似乎是一个完整的操作系统。</p><p>那么，现在知道 Docker 启动一个容器的过程：</p><ol><li>启动 Linux Namespace 配置；</li><li>设置 Linux Cgroups 参数；</li><li>切换容器进程执行根目录；</li></ol><blockquote><p>Docker 在最后一部不是使用的 chroot，而是使用 pivot_root 系统调用，如果不支持，才会使用 chroot。</p><p>piovt_root 改变的是当前 Mount Namespace 的根目录，并 umount 原来的目录，chroot 只是改变的是当前进程的根目录。</p></blockquote><p>上面讲到的这种为容器运行时提供隔离的执行环境的文件系统，叫做 rootfs（Root File System，根文件系统），其实就是<strong>容器镜像</strong>了。</p><h3 id="Union-FS"><a href="#Union-FS" class="headerlink" title="Union FS"></a>Union FS</h3><p>上一节清楚了容器镜像，它是一个有着容器运行时完整依赖的文件系统，容器一直大肆宣扬的“一致性”也是基于这个实现。</p><p>接下来的问题是，它的易用性如何保证？</p><p>加入现在我为了运行 App A，基于 Ubuntu 安装了 Jre 等环境，然后将 App A 放进去，制作了一个 App A 的 rootfs，着没毛病，那如果我现在要运行 App B，它和 App A 有着一样的环境依赖，是不是也需要自己从头开始制作一个 rootfs？</p><p>这样做，不是不可以，只是太麻烦，A 和 B 只是运行的 App 不同，Ubuntu 和 Jre 都是一样的，是否可以考虑把前面的步骤的产物保留下来，做成可以复用的一个产物？</p><p>事实上，确实也是这样做的。</p><p>上面的例子只有 Ubuntu 和 Jre 这两中东西的糅合，那如果依赖的环境再复杂一点，比如我想修改一些文件，这个时候，这种可复用的产物就越来越多了，最终汇集成容器的 rootfs 时可能就会出现，A 文件夹下新增了一个 a 文件夹，另一个人一个人又加了一个 b 文件夹，到容器里面一看，会发现 A 文件夹下面同时存在 a 和 b 两个文件夹。</p><p>会发现，最终使用的镜像，可能经过了多次修改，Docker 将这些修改，每一次都保存为一层，增加 a 文件夹会加一层，增加 b 文件夹再加一层，用户的每个操作，都会增加一层，最终就是一个增量更新的 rootfs。</p><p>这种增量更新，并且还支持多个不同物理位置挂载到一个一个目录下面的 rootfs，叫做联合文件系统（Union File System），简称 UnionFS。</p><blockquote><p>Docker 在 v19.03 开始默认使用 overlay2 UnionFS，在此之前默认使用 AuFS。</p></blockquote><blockquote><p>AuFS，现在的全程 Advance UnionFS，最开始叫  Another UnionFS，后来又改名 Alternative UnionFS，最终改为 Advance UnionFS。</p><p>AuFS 曾试图合并进入 Linux 内核，但多次被  Linus Torvalds（Linux 之父，真的大佬）拒绝，据说是因为代码写的太烂了哈哈哈。</p></blockquote><p>以 AuFS 为例，它的 rootfs 分为了 3 层，从上到下依次是：</p><ul><li><p>可读写层</p><p>运行中的容器修改了文件、配置都会在这一层。</p></li><li><p>Init 层</p><p>Docker 自动创建的一层，比如 <code>docker run</code> 时指定的一些参数，这一层在执行 <code>docker commit</code> 时不会打包进镜像中。</p></li><li><p>只读层</p><p>这一层是基础镜像，如果在容器中修改了这一层的文件，其实并没有修改到这一层的文件，而只是施加了“障眼法”，比如运行时删除了只读层的 <code>foo.txt</code>，其实在 rootfs 中并没有删除，而是增加了一个 <code>.wh.foo.txt</code> 表示文件被删除了，至于修改操作，其实就是一种写时复制的机制来实现的，并非真的修改了只读层的文件。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP理论与分布式事务</title>
      <link href="posts/fd8e6ae23310.html"/>
      <url>posts/fd8e6ae23310.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/image/202203152219479.jpg'/><span id="more"></span><blockquote><p>最近做一些 interview 遇到了一些问题，有时间慢慢总结，慢慢学习。</p></blockquote><h1 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h1><p>现代的业务系统，在业务有了一定复杂度之后，都会逐渐向微服务、服务网格甚至无服务的方向演进。不管发展到那个阶段，都会脱离单体架构，演化成一个分布式的系统，分布式系统涉及共享数据的问题时，总会讨论一致性、可用性、分区容忍性。</p><ul><li><p>一致性（Consistency）</p><p>一致性表示任何时刻，任何分布式节点看到的数据都是符合预期的。</p></li><li><p>可用性（Availability）</p><p>可用性主要用可靠性和可维护性两个指标衡量。可靠性使用平均无故障时间 (Mean Time Between Failure，MTBF) 来度量，可维护性使用平均修复时间 (Mean Time To Repair，MTTR) 来衡量，常说的系统可用性达到 5 个 9，其实就是说 <code>MTBF / (MTBF + MTTR) = 99.999%</code>。</p></li><li><p>分区容忍性（Partition Tolerance）</p><p>指部分节点因网络问题相互失联后，形成了网络分区，依然能正常提供服务。</p></li></ul><p>首先，分布式系统中，认为系统的网络通信是可靠的，但是事实上，因为网络环境的复杂性，并不能完全保证网络的可靠性，所以分区容忍性是必须保证的。</p><p>业界也一致认为，一致性和可用性不可兼得，所以现在的分布式系统，要么是 CP 系统，要么是 AP 系统。</p><ul><li><p>CP 系统</p><p>牺牲可用性，当系统发生网络分区时，因为要保证数据的一致性，节点间的数据同步将不可预期地延长，或者直接响应失败，响应失败意味着可用性降低。</p><p>Zookeeper 作为服务注册和发现中心时，当发生网络分区时，为了保证数据一致性，分区内重新进行了选举，这个过程是耗时的，选举过程中，整个服务注册与发现功能是不可用的，所以 Zookeeper 是一个 CP 系统。</p></li><li><p>AP 系统</p><p>牺牲一致性，当系统出现网络分区时，各个分区各自为政，继续对外服务，就可能出现数据不一致的情况，比如相同的请求分发到不同分区，导致得到的结果不一样。</p><p>Eureka 同样也是服务注册与发现，和 Zookeeper 不同的是，每个服务往每个注册中心都进行注册，整个 Eureka 集群不分主从节点，只要还有一个节点活着，就能继续提供服务，只不过数据可能已经过时了，所以 Eureka 是一个 AP 系统。</p></li></ul><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在微服务架构下，因为服务间需要做到数据自治，常常会进行分库，不同的微服务使用不同的库，当一个业务需要调用多个写服务时，就涉及到分布式事务的问题。</p><blockquote><p>也有些非规范的做法，将写服务中访问数据库的代码打包成一个 jar 包，供其他服务依赖，其实所有的数据库写操作都在一个本地事务中，不存在分布式事务，这种的我认为不是微服务，因为代码还是产生了耦合，而微服务本身有一个目的就是解耦。</p></blockquote><p>需要说明的是，一个本地事务执行过程，遵循事务的 ACID 原则，对于事务的隔离级别，又分成了<strong>读未提交、读已提交、可重复度、串行执行。</strong></p><p>但到了分布式环境中，势必会有多个事务分布在不同的进程中，很难保证进程 A 中的事务和进程 B 中的事务会一起成功或一起失败，所以对于分布式事务的一致性分成了三类：</p><ol><li><p>弱一致性</p><p>数据更新后，能容忍后续访问出现部分访问不到或者直接无法访问的情况。</p></li><li><p>强一致性</p><p>任意时刻，在任何一个节点看到的数据都是一致的。</p></li><li><p>最终一致性</p><p>允许数据在短时间内不一致，但经过一定时间最终达到一致。</p></li></ol><p>而最终一致性起源于以 CAP 理论为基础扩展而来的 BASE 理论。</p><h2 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h2><ul><li><p>Basically Available</p><p>基本可用，当出现故障时，能容忍系统部分不可用，来保证核心功能可用。</p></li><li><p>Soft State</p><p>软状态，允许系统存在中间状态，且这种中间状态不会对系统造成影响。</p></li><li><p>Eventually Consistent</p><p>最终一致性，允许分布式系统中不同节点在同一时刻读到的状态不一致，但是随着时间推移，最终会保持一致。</p></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="两阶段提交（TPC）-XA-协议"><a href="#两阶段提交（TPC）-XA-协议" class="headerlink" title="两阶段提交（TPC）/XA 协议"></a>两阶段提交（TPC）/XA 协议</h3><p>两阶段提交的实现中，有 2 个概念：</p><ul><li><p>事务管理器</p><p>协调各个本地资源管理器。</p></li><li><p>本地资源管理器</p><p>一般是指执行各个本地事务的应用。</p></li></ul><p>上面的两个管理器，一般都是数据库扮演的，而不需要应用的接入，事务管理器的选择也是数据库自行选择的。</p><p>两阶段提交的 2 步：</p><ol><li>准备阶段，事务管理器向所有参与事务的本地资源管理器询问是否准备就绪，资源管理器在响应这次询问时，会执行本地事务，但是不会提交，也就是说会一直持有数据的锁，保证对其他事务的隔离性。</li><li>提交或回滚阶段，管理器收到所有资源管理器回复 Prepared 消息后，先将自己的本地事务 Commit，然后通知其他资源管理器进行 Commit，而如果收到一个资源管理器回复 Abort 或者资源管理器的回复超时了，就会先将自己的本地事务回滚，然后通知其他资源管理器回滚。</li></ol><p>两阶段提交因为是所有本地事务一起提交，只是可能会有细微的网络延迟导致的时间差异而已，所以，使用两阶段提交需要有两个保证：</p><ol><li>网络是可靠的，不会丢失消息，比如丢失协调器发送给资源管理器的 Commit 的消息，如果这个消息丢了，是无法补救的。</li><li>出现网络分区时可恢复，当资源管理器因为各种原因下线、停机后，最终能够恢复上线，而不是一直失联，因为在恢复后才能将未提交的本地事务提交。</li></ol><p>两阶段提交虽然简单，但是缺点也比较显著：</p><ul><li><p>单点问题</p><p>在事务管理器和资源管理器的通信中，事务管理器对资源管理器超时这种情况还会有回滚的操作，但是如果挂掉的是事务管理器，资源管理器在接受事务管理器的指令这个点上是没有超时机制的，所以，如果事务管理器挂了，那么所有资源管理器会一直等待。</p></li><li><p>性能问题</p><p>两阶段提交过程中，相当于将多个进程中的本地事务绑定成了一个整体，整个过程中有 2 次远程调用，3 次数据库写入（一阶段执行本地事务写 redo log，二阶段事务管理器持久化事务状态，二阶段资源管理器提交事务），整个过程将持续到最后一步中操作时间最长的本地事务完成为止。</p></li><li><p>一致性风险</p><p>前文提到两阶段的必要网络条件和网络分区可恢复保证，但是实际上，并不能 100% 保证不会因为网络故障导致丢失 Commit 消息，也不能保证资源管理器下线之后一定会上线，这个时候就会出现一致性问题，有些本地事务提交了，有些本地事务一直在等待或者直接丢失。</p></li></ul><h3 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h3><p>为了解决上述两阶段提交的部分问题，又演化出了三阶段提交。具体来讲，其实解决的是单点问题和准备阶段的性能问题。</p><p>三阶段提交将两阶段提交中的准备阶段又细分为 CanCommit、Pre Commit 两个阶段，二阶段中的提交或回滚阶段叫做 Do Commit。</p><ul><li><p>Can Commit</p><p>询问每个资源管理器，根据当前的自身状态评估该事务是否有可能顺利完成。</p></li><li><p>Pre Commit</p><p>每个资源管理器执行本地事务，但是不提交，其实就是写了 redo log。</p></li><li><p>Do Commit</p><p>和二阶段一样，提交或者回滚。</p></li></ul><p>第一阶段并不会执行事务中的一些 SQL，所以会很快，这一步的存在是为了更好的保证事务能顺利完成，向二阶段提交那样，其中一个资源管理器失败了，而其他分支事务都成功了，最后依然还是回滚，那么那写成功的分支其实是做了无用功，所以这在一定程度上也缓解了两阶段提交的第一阶段的性能问题。</p><p>第二阶段依然是执行事务内的 SQL，写入 redo log，但事务不会提交。</p><p>第三阶段，和两阶段提交相似，全部成功就提交，其中一个失败就是回滚，不同的是，对于事务管理器在第三阶段指令超时的情况，这里不会一直等待，资源管理器超时后会执行提交操作。</p><p>性能上，因为多了一阶段的检查，所以如果是整个分布式事务最终能够成功提交的场景下，三阶段提交性能可能甚至不如两阶段提交，而对于回滚的场景，因为做了提前的检查，所以出现大部分资源管理器都写了 redo log 之后依然回滚的概率比较小，更大概率是在一阶段就直接失败了，所以，对于回滚的场景，三阶段提交相对于两阶段提交有所提升。</p><p>一致性方面，三阶段提交可能会导致数据错误，比如在第三阶段资源管理器应该受到 Abort 消息而回滚，但是网络原因导致超时，最后实际执行的是 Commit，这个时候就会出现数据不一致的情况。</p><h3 id="可靠事件队列"><a href="#可靠事件队列" class="headerlink" title="可靠事件队列"></a>可靠事件队列</h3><p>现在加入有 A、B、C 三个服务要一起完成一个业务，分布式事务一开始由 A 发起。</p><ol><li>A 服务完成本地事务，并在自己的数据库建立一张消息表，其中主要包含事务 ID、事务的内容、事务状态（进行中），这个，这两个操作是在 A 服务的同一个本地事务中完成，以免出现事务执行成功，但是消息存储失败的情况。</li><li>在系统中建立消息服务，定时轮询第 1 步中的消息表，如果由新的消息，就发送到 B、C 服务，此时会有以下 4 中情况：<ol><li>B、C 都接收到新的消息，并成功执行自己的本地事务并提交，然后将结果返回给 A 服务，A服务将消息表中指定的消息事务状态改为已完成，整个分布式事务结束。</li><li>B、C 两个服务中，至少一个没有成功接收到消息，导致整个分布式事务的状态一直是进行中，此时消息服务器会继续发送消息，知道 B、C 全都成功消费，因为就会出现重复消息的问题，所以 B、C 服务需要做幂等处理，可以考虑将分布式事务的事务 ID 作为标识来进行幂等处理，如果某个 ID 已经处理过了，就不再进行执行本地事务逻辑。</li><li>B、C 至少有一个消费事件失败，导致分布式事务不能完成，这种情况，失败的服务依然会一直消费，知道人工介入，这说明可靠事件队列这种方式是只许成功，不许失败的。</li><li>当 B、C 都消费成功，但是最后发送的返回结果因为网络问题丢失了，此时 A 服务过一段事件会重新发送消息，B、C 会重新消费，但是因为已经做了幂等处理，所以不会再执行事务逻辑，而只是再次触发发送执行结果的逻辑而已。</li></ol></li></ol><blockquote><p>这种方式其实可以通过支持事务消息的消息中间件来实现，比如 RocketMQ。</p></blockquote><h3 id="TCC-事务"><a href="#TCC-事务" class="headerlink" title="TCC 事务"></a>TCC 事务</h3><p>TCC 是 Try-Confirm-Cancel 的缩写，</p><ul><li><p>Try</p><p>尝试执行阶段，完成事务可执行性的检查，预留好执行事务需要的资源，比如锁定库存。</p></li><li><p>Confirm</p><p>确认执行阶段，如果 Try 阶段执行成功，将进入确认执行阶段，这一阶段不执行业务检查，使用 Try 阶段预留的资源直接完成业务逻辑，任何一方出现问题都会重复执行，知道成功为止，所以这一步必须保证幂等性。</p></li><li><p>Cancel</p><p>取消执行阶段，如果 Try 阶段任何一方出现任何问题，将会进入取消执行阶段，取消执行阶段会释放 Try 阶段的资源，如果在这个过程中任何一方出现问题，会一直重复执行，知道释放资源成功，所以这一步必须保证幂等性。</p></li></ul><p>会发现 TCC 事务和两阶段提交很像，但是，两阶段提交是数据库之间自行完成的，不需要应用代码接入，但是 TCC 事务是需要应用层面的代码开发来支持 3 个阶段的操作的，对业务代码侵入性比较强。</p><h3 id="SAGA-事务"><a href="#SAGA-事务" class="headerlink" title="SAGA 事务"></a>SAGA 事务</h3><blockquote><p> SAGA 事务我第一次是在《微服务架构设计模式》这本书上见过。</p></blockquote><p>到目前位置介绍的方案，基本都保证了事务的隔离性，以防止出现“超售”的情况，但是前面几种方案都是建立在这多个分支事务都是可控的情况下，而如果是要对接第三方系统时，前面的方案就没用了，比如在接入微信支付或者支付宝支付时，这写平台肯定不会专门针对每一个平台提供二、三阶段提交或者 TCC 的支持，这个时候，就出现了  SAGA 事务这种解决方案。</p><p>SAGA 要求为每一个事务提供一个补偿事务来保证最终一致性。</p><p>比如，分布式事务 T 分成 T1、T2、T3…Tn 一共 n 个分支事务，那么就必须提供 C1、C2、C3…Cn 一共 n 个补偿事务。</p><p>如果 T1 到 Tn 都执行成功了，那么整个分布式事务就成功了，而如果在执行 Ti 时失败了，那么 T1 到 Ti 都需要回滚，此时就需要执行 Ci 到 C1 的补偿事务来保证最终一致性。</p><p>需要注意的是，SAGA 事务在全局上的隔离级别是读未提交，而在局部分支上是根据实际的数据库隔离级别来决定的。</p><p>总是，对于分布式事务的解决方案，并没有所谓的银弹，只有因地制宜而已，对于这些解决方案，由开源 Seata 框架支持了上述几乎所有方案，并且在两阶段提交的基础上做改进，提出了 AT 模式。</p><blockquote><p>Seata：<a href="https://seata.io/">https://seata.io/</a></p><p>另外，《深入理解 Java 虚拟机》的作者周志明老师开源了新书<a href="http://icyfenix.cn/">《凤凰架构》</a>中也有专门对分布式事务做讲解。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM类加载机制</title>
      <link href="posts/4635eb915ea6.html"/>
      <url>posts/4635eb915ea6.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/images/20220129152458.jpg'/><span id="more"></span><h1 id="JVM-类加载机制"><a href="#JVM-类加载机制" class="headerlink" title="JVM 类加载机制"></a>JVM 类加载机制</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>在加载阶段，JVM 要完成以下 3 件事：</p><ol><li>通过一个类的全限定名来获取一个类的字节流。</li><li>将这个二进制数据流代表的静态数据结构转换成为方法区的运行时数据结构。</li><li>内存中为这个类生成一个 java.lang.Class 对象，作为方法区中这个类各种访问的入口。</li></ol><p>因为第 1 点并没有明确规定从哪里获取一个类的字节流，也就是说这是交给开发者自己实现的，所以就有了现在的以 jar、war 的形式启动的方式，这种相当于是从压缩文件获取字节流，还有一些比较少见的从数据库获取字节流的场景，以及现在很多 AOP 框架还会在运行时动态构建字节流来实现动态代理，甚至一些闭源的代码的字节流在这一步还需要进行解密，总之因为这一步没有明确定义路径，所以很灵活得支持了很多场景。</p><p>上面的操作，都是基于加载的是一个类而不是数组的前提的。对于数组，它最后在方法区中也会有一个对应的 java.lang.Class 对象，只不过不是由类加载器加载，而是 JVM 在内存中直接构建的，但是根据数组的元素类型(不管是一维数组还是多维数组，将所有纬度去掉之后的类型)和组件类型(指去掉一个纬度之后的类型，如果是多维数组，这里的组件类型可能还是个数组)，还是会和类加载器有关系，比如有一个数组 C[][]，它的元素类型是 C，组件类型是 C[]，根据 C 类型的不同，分为 2 种情况：</p><ol><li>如果组件类型是引用类型，最终还是会使用类加载器来加载 C 这个类，而整个 C[][] 的加载也是通过递归的方式进行加载，每次递归加载的时候也依然会根据具体的类型决定如何加载，而数组也将会标识在类加载器上。</li><li>如果组件类型是基础类型，比如 int 或者 int[]，JVM 会把这个类标识在引导类加载器上。</li></ol><p>加载阶段完成后，方法区就会有类型对应的 java.lang.Class 对象，并且，加载过程和下一阶段的验证很多时候是交叉着在执行的，因为字节流转换成 java.lang.Class 对象时需要进行一些必要的格式校验，比如魔数。虽然这两步是交叉运行，但是开始时间依然是先加载、后验证的顺序严格执行的。</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>连接阶段又细分成了验证、准备、解析 3 个阶段。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证阶段主要是验证字节码的合法性，验证字节码是否对的《Java 虚拟机规范》的全部约束要求，主要分为文件格式验证、元数据验证、字节码验证、符号引用验证。</p><p>验证阶段其实是非常重要但非必要的步骤，如果全是经过大量使用的依赖包，可以考虑关掉验证这一步，因为这一步本质上只是通过、不通过两种输出的区别而已，可以通过 <code>-Xverify:none</code> 参数关闭。</p><h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>这里主要验证二进制流中的魔数、版本号等信息是否正确，除了这两个，其实还验证了很多东西。这一步是基于字节流验证的，在这一步验证通过之后才能通过这个字节流转换成 java.lang.Class 对象，后续的验证都是基于这一步验证之后生成的字节码对象进行验证。</p><h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>元数据验证阶段，主要是对字节码描述信息进行语意验证，比如是否继承了不能被继承的类(final 修饰的类)，是否实现了继承的抽象类中必须要实现的方法。</p><h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>整个验证过程中最复杂的阶段，这里主要通过数据流分析和控制流分析判断语义合法性和逻辑正确性，确保不会做出危害虚拟机的行为，比如：</p><ul><li>int 类型变量不会按照 long 类型加载到本地变量表中。</li><li>任何跳转指令不会跳转到字节码之外的字节码指令上。</li></ul><p>如果一个类型中有方法没有校验通过，那么一定是不合法的，但是如果所有方法都检验通过了，也不能保证一定是合法的，因为不可能用一段程序来判断另一端程序是否有 bug（比如平时写单元测试的时候，不能保证一定覆盖了所有场景，只能说能想到的场景都覆盖了）。</p><h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>其实主要就是检查当前的类型中是否缺少、进制访问依赖的方法、类、接口、字段等资源，比如直接访问另一个类的 private 修饰的字段，通常是过不了这一个检查的。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为 static 字段分配内存，并设置初始零值。final 修饰的字段不会在这里设置，因为 final 修饰的字段在编译时就已经设置了。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将常量池内的符号引用转换为直接引用，如果符号引用指向的类未被加载，就会触发目标类的加载过程。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>执行类的 init()，该方法不用显示定义，是编译器自行收集各属性的赋值动作及静态代码块得到该方法，如果该类有父类，会保证先执行父类 init() 方法，再执行子类 init() 方法。 </p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>业务代码中调用该类的实例。</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p>JVM 中的类加载器分为: </p><ul><li>BootstrapClassLoader<br> 由 C/C++ 实现，本身没有父加载器，它加载 ExtensionClassLoader 和 ApplicationClassLoader，并且是它们的父加载器。</li><li>ExtensionClassLoader<br> 扩展类加载器，派生自 ClassLoader，从 jre/lib/ext 目录和系统环境变量 java.ext.dirs 配置的目录加载类库。</li><li>ApplicationClassLoader<br> 应用类加载器，派生自 ClassLoader，从 classpath 和环境变量 java.class.path 指定目录加载类库，Java 应用程序的类都由它加载。通过  <code>ClassLoader#getSystemClassLoader</code> 方法可以获得该类加载器。</li><li>自定义类加载器<br> 继承 ClassLoader 类，重写 findClass 方法即可，比如 Tomcat 打破双亲委派机制就是通过重写 findClass 方法实现。</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>当一个类加载器加载一个类时，首先会尝试让父加载器加载该类，如果父加载器没找到，自己才会尝试加载目标类，也就是说，一般情况下，任何一个类的加载都会轮到 BootstrapClassLoader 尝试加载一次。如果最终还是没能加载到目标类，就会抛出 <code>ClassNotFoundException</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> 深入理解Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议相关知识点</title>
      <link href="posts/5f1fe6aef7d6.html"/>
      <url>posts/5f1fe6aef7d6.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/images/202202271047191.png '/><span id="more"></span><h1 id="网络协议相关知识点"><a href="#网络协议相关知识点" class="headerlink" title="网络协议相关知识点"></a>网络协议相关知识点</h1><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><ol><li><p>客户端发送 SYN 信号，并且还带了一个序列号，进入 SYN_SENT 状态，这是第一次握手。</p></li><li><p>服务端收到 SYN 信号，返回 ACK 信号，同时也会有一个 SYN 信号从服务端发向客户端，同样也带了一个序列号客户端变成 SYN_RCVD 状态，这是第二次握手。</p></li><li><p>客户端收到服务端的 SYN 信号后，返回给服务端一个 ACK 信号，服务端进入 Established 状态，这是第三次握手。</p></li></ol><h2 id="为什么-TCP-需要三次握手，而不是两次？"><a href="#为什么-TCP-需要三次握手，而不是两次？" class="headerlink" title="为什么 TCP 需要三次握手，而不是两次？"></a>为什么 TCP 需要三次握手，而不是两次？</h2><p>因为要确定连接建立成功，所以发送 SYN 信号后还需要等待服务端返回一个 ACK 信号，这里有两次握手。TCP 每次传输的数据包都带了一个序列号，以避免重复传输或者漏传数据包，这个序列号是递增的，初始的序列号则是伴随 SYN 信号发出，TCP 是全双工协议，允许在两个方向上同时传输数据，如果服务端要向客户端发送数据，那也需要一个初始的序列号，所以在发送 ACK 信号给客户端时，还发送了一个 SYN 信号将初始序列号给了客户端，而客户端接收到 SYN 信号后，必须回复一个 ACK 信号给服务端，服务端才知道连接建立成功了。</p><p>所以，两次握手只能建立单向的连接，而 TCP 是全双工协议，需要建立双向连接，所以需要三次握手。</p><h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><ol><li><p>客户端发送带 FIN 标识的信号到服务端表示要断开连接，自己进入 FIN_WAIT_1 状态。</p></li><li><p>服务端返回一个 ACK 消息，序列号是收到的序列号加 1，客户端收到 ACK 消息后进入 FIN_WAIT_2 状态，服务端进入 CLOSE_WAIT 状态。</p></li><li><p>服务端发送 FIN 标识的信号到客户端表示要断开连接，然后进入 LAST_ACK 状态。</p></li><li><p>客户端收到 FIN 消息，回复一个 ACK 消息，序列号是收到的序列号加 1，进入 TIME_WAIT 状态，服务端收到 ACK 报文后进入 CLOSE 状态，完全关闭。</p></li></ol><h2 id="TCP-为什么需要四次挥手？"><a href="#TCP-为什么需要四次挥手？" class="headerlink" title="TCP 为什么需要四次挥手？"></a>TCP 为什么需要四次挥手？</h2><p>为了确保服务端和客户端的数据传输能顺利完成。</p><p>最开始发起 TCP 断开连接动作的，其实可以是客户端，也可以是服务端，只有最开始发起的一端最后会进入 TIME_WAIT 状态，等待还未接收完的数据。</p><p>CLOSE_WAIT 状态，是一个半关闭状态。TCP 是一个全双工协议，数据可以双向传输，客户端发起断开连接的请求后，只是表明服务端不再接收客户端的数据，但是它仍然可以向客户端发送数据。</p><p>和三次握手的主要区别在于，三次握手时，服务端将回复的 ACK 和 SYN 信号放在了一个报文里面，而四次挥手时，服务端回复 ACK 和发起断开连接的 FIN 信号分成了两个报文发送，所以变成了四次挥手而不是三次挥手。</p><p>而四次挥手时服务端将 ACK 和 FIN 分成两个报文发送，是因为 ACK 是内核态决定的，而 FIN 信号是用户态在数据处理完以后才发送的，所以并不能保证两者能同时发送，也就多了一次握手。</p><h2 id="TCP-粘包问题"><a href="#TCP-粘包问题" class="headerlink" title="TCP 粘包问题"></a>TCP 粘包问题</h2><p><strong>问题：</strong>发送方发送的若干数据包到接收方粘成了 1 个包。</p><p><strong>原因：</strong></p><ol><li>TCP 协议为了减少网络中的报文数量，收集多个数据包，再一起发送，导致粘包。</li><li>接收方将接收到的数据放在缓存里面，如果接收数据到缓存的速度大于应用从缓存取数据的速度，也会导致粘包问题。</li></ol><p><strong>解决方案：</strong></p><p>参考 Netty 对于 TCP 粘包、半包的处理，有 3 中方式。</p><ol><li>数据定长，比如约定请求报文的长度为 100，那么每次读取完整的信息就是读取 100 个字节，但是这并不灵活，万一有些请求数据本身大于 100 就不行了。</li><li>特殊字符作为结尾标识，比如读取到<code>\r\n</code> 就认为本次请求的数据读取完成，这样也不够灵活。</li><li>包头专门的字段记录请求数据的长度，现在的很多扩展性比较高的二进制协议都采用这种方式。</li></ol><h2 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h2><p>物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。</p><h2 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h2><p>物理层，数据链路层，网络层，传输层，应用层。</p><blockquote><p>TCP 协议是传输层协议，IP 协议是网络层协议。</p></blockquote><h2 id="Http-协议"><a href="#Http-协议" class="headerlink" title="Http 协议"></a>Http 协议</h2><p>现在 Http 协议有 1.0、1.1、2.0 一共 3 个版本。</p><p>Http 1.0 真正做到了无状态，每次建立连接，请求完成后都会断开连接；</p><p>Http 1.1 协议增加了保持长连接的 Keep-Alived 标识支持长连接，通过 Content-Length 判断数据是否接收完毕；</p><p>Http 2.0 协议是二进制协议，不再是文本协议，引入数据帧和流的概念，因为帧的存在，数据有了序列，服务器支持并行传输数据。</p><h3 id="Http-1-0-和-1-1-的区别"><a href="#Http-1-0-和-1-1-的区别" class="headerlink" title="Http 1.0 和 1.1 的区别"></a>Http 1.0 和 1.1 的区别</h3><ol><li>1.1 引入 Keep-Alived 支持长连接，避免频繁建立和销毁 TCP 连接，浪费资源。</li><li>1.1 引入更多的缓存控制策略。</li><li>支持 Host 头处理。</li></ol><h3 id="Http-2-0-和-1-1-的区别"><a href="#Http-2-0-和-1-1-的区别" class="headerlink" title="Http 2.0 和 1.1 的区别"></a>Http 2.0 和 1.1 的区别</h3><ol><li>2.0 支持多路复用，多个请求可以使用同一个连接，每个请求都有自己的 ID，通过 ID 对应请求和响应。</li><li>2.0 是二进制协议，不是文本协议，传输效率更高。</li></ol><h2 id="Https-协议"><a href="#Https-协议" class="headerlink" title="Https 协议"></a>Https 协议</h2><h3 id="Https-和-Http-的区别"><a href="#Https-和-Http-的区别" class="headerlink" title="Https 和 Http 的区别"></a>Https 和 Http 的区别</h3><ol><li>Http 默认使用 80 端口，Https 默认是用 443 端口。</li><li>Http 铭文传输数据，不安全，Https 传输加密后的数据。</li><li>Http 协议不需要加密，效率更高，Https 因为需要加密，效率更低，资源消耗更多。</li></ol><h3 id="Https-通信流程"><a href="#Https-通信流程" class="headerlink" title="Https 通信流程"></a>Https 通信流程</h3><ol><li>客户端向服务端发送请求。</li><li>服务端返回一个 SSL 证书，其中包含一个非对称加密的公钥。</li><li>客户端校验公钥是否为真，使用公钥对需要使用的对称加密算法和对称加密的密钥加密并发送给服务端。</li><li>服务端收到后，用非对称加密的私钥进行解密，得到对称加密的算法和密钥。</li><li>现在客户端可以使用对称加密的算法和密钥对数据加密进行通信。</li></ol><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>是指加密解密使用同一个密钥，加密速度也比较快，比如 AES、DES 算法。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>是指加密和解密使用不用的密钥，所以非对称加密算法分为公钥和私钥，公钥是可以对外公开的，私钥是不能对外公开的，加解密速度相对比较低，所以在 Https 中，实际的数据传输还是使用对称加密，只不过对称加密的算法和密钥是通过非对称加密的方式传输告知对方的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集器：G1</title>
      <link href="posts/ef0be76de5da.html"/>
      <url>posts/ef0be76de5da.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/images/202201182252051.png'/><span id="more"></span><blockquote><p>本文是《深入理解 Java 虚拟机》第 3 版的读书笔记。</p></blockquote><h1 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h1><p>G1 收集器，全称 Garbage First 收集器。</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>在 JDK 6 Update 14 版本时，G1 就已经提供给了开发人员测试和试用；JDK 7 Update 4 的时候，Oracle 才认为它达到了可商用的程度；在 JDK 8 Update 40 时提供并发的类卸载的卸载，此后 Oracle 称它是全能的垃圾收集器；JDK 9 发布时，它代替了 Parallel Scavenge + Parallel Old 组合成为服务端模式下的默认垃圾收集器组合，同时 CMS 不再是推荐的垃圾收集器，当使用 <code>-XX:+UseConcMarkSweepGC</code> 开启 CMS 收集器时，还会收到警告信息，提示 CMS 收集器未来将会被丢弃；JDK 10 时提出了一套“统一垃圾收集器接口”，将内存回收的“行为”与“实现”分离，CMS 及其他收集器重构成了基于该接口的一套实现。 </p><p>G1 收集器的论文是在 2004 年 Sun 实验室发表的，但是一直到 2012 年 4 月的 JDK 7 Update 4 才真的发布，可见它是真的复杂。</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="停顿预测模型"><a href="#停顿预测模型" class="headerlink" title="停顿预测模型"></a>停顿预测模型</h3><p>G1 收集器的设计目标是希望能够建立“停顿预测模型”的收集器，停顿预测模型的意思是：能够支持在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不超过 N 毫秒。</p><h3 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h3><p>上一篇笔记讲过，Mixed GC 是指新生代和部分老年代内存区域一起收集。</p><p>这是按照分代收集理论的角度来讲的。但是对于 G1 来讲，并不是真的分了一部分内存作为老年代或者新生代，然后针对不同分代收集，它是面向堆内存任何部分来组成回收集进行回收，衡量标准不再是属于那个分代，而是哪块内存的垃圾最多，回收后的收益最高，这就是 G1 收集器的 Mixed GC。</p><h3 id="Region-内存模型"><a href="#Region-内存模型" class="headerlink" title="Region 内存模型"></a>Region 内存模型</h3><p>为了实现前面的 Mixed GC，G1 收集器将堆内存划分为多个大小相等的内存块，这种模型叫做 Region 模型，每一个 Region 块可以视情况作为新生代的 Eden 空间或者 Survivor 空间，或者老年代空间，对于扮演不同角色的 Region 块，G1 采用不同的策略去收集，这样不管是新生代还是老年代的对象都能有很好的收集效果。</p><h4 id="Humongous-区域"><a href="#Humongous-区域" class="headerlink" title="Humongous 区域"></a>Humongous 区域</h4><p>Humongous 区域是一种特殊的 Region 块，用来存储大对象。程序运行时不可避免的可能会产生大对象，对于超过一个 Region 一般容量大小的对象，认为是大对象，Region 的大小可以通过 <code>-XX:G1HeapRegionSize</code> 设定，取值范围是 1 MB ~ 32 MB，且为 2 的 N 次幂，对于超过整个 Region 块容量的大对象，G1 会使用多个连续的 Humongous 区域来存储，这样的 Hmongous 区域一般都会被当成老年代。</p><blockquote><p>到这里可以知道，虽然 G1 收集器也是按照分代收集理论设计，但是它的新生代和老年代区域大小不是固定的，而是一系列可以不连续的 Region 块的动态集合。</p></blockquote><h3 id="回收区域优先级"><a href="#回收区域优先级" class="headerlink" title="回收区域优先级"></a>回收区域优先级</h3><p>现在我们知道，G1 不像其他收集器那样，要么收集整个新生代，要么收集整个老年代，而是将整个堆内存划分成多个 Region 内存块，每次回收的时候其实是针对一些 Region 块的集合进行回收，这样就能有效避免在整个堆内存或者某个分代的内存区域进行全区域回收。</p><p>对于每次收集的 Region 块集合应该是哪些，G1 会跟踪每个 Region 块中垃圾堆积的“价值”大小，也就是回收后会得到的空间和回收所需要的时间，然后在自己维护一个优先级列表，然后根据用户允许的收集停顿时间，优先收集那些“价值”更大的 Region 块。</p><p>G1 允许的收集停顿时间通过 <code>-XX:MaxGCPauseMillis</code> 设置，默认为 200 ms。</p><h2 id="面临的问题及解决方案"><a href="#面临的问题及解决方案" class="headerlink" title="面临的问题及解决方案"></a>面临的问题及解决方案</h2><h3 id="跨-Region-的引用怎么办？"><a href="#跨-Region-的引用怎么办？" class="headerlink" title="跨 Region 的引用怎么办？"></a>跨 Region 的引用怎么办？</h3><p>解决跨 Region 引用的问题，其实和解决跨代引用的问题有点像，目前解决跨代引用问题主要使用的思路是<strong>记忆集</strong>，常用的实现是<strong>卡表</strong>。</p><h4 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h4><p>当出现跨代引用时，为了避免将整个老年代一起进行一次扫描，专门设计了叫记忆集的数据结构，它是一种记录从非收集区域指向收集区域的指针的抽象数据结构。</p><p>最粗暴的实现就是用非收集区域的跨代引用的对象组成的数组来作为记忆集的实现，但是这种实现的维护成本和空间占用比较高，垃圾收集时，只要能判断出某一块内存区域是否有跨代引用就够了，这样就不用收集整个分代区域。</p><p>所以在设计记忆集的具体实现时，有了三种精度：</p><ul><li><p>字长精度</p><p>每个记录精确到一个机器字长，该字包含跨代指针。</p></li><li><p>对象精度</p><p>每个记录精确到一个对象，该对象中有跨代指针。</p></li><li><p>卡精度</p><p>精确到一块内存区域，该内存区域中有对象存在跨代引用指针。</p></li></ul><p>卡表就是卡精度的实现。</p><h4 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h4><p>可以理解为卡表维护的是一个 Map，内存区域被分为了多个区域，每个区域都有一个编号，如果某个编号在这个 Map 中对应的值为 1，就表示这个区域存在跨代引用，在进行 GC 时将该区域也加入 GC 即可。</p><h4 id="G1-的跨-Region-的解决方案"><a href="#G1-的跨-Region-的解决方案" class="headerlink" title="G1 的跨 Region 的解决方案"></a>G1 的跨 Region 的解决方案</h4><p>G1 收集器采用了卡表的思路，不过实现更加复杂。</p><p>每个 Region 块都维护了自己的卡表，记录那个 Region 指向了我，本质上是一个哈希表，Key 是别的 Region 的起始地址，Value 是一个集合，里面存的是每一个卡表的索引号。</p><p>因为每个 Region 都会维护自己的记忆集，这就导致 G1 收集器占用的内存相比于其他收集器更高。</p><h3 id="并发标记阶段，如何保证收集器线程和用户线程互不干扰的运行？"><a href="#并发标记阶段，如何保证收集器线程和用户线程互不干扰的运行？" class="headerlink" title="并发标记阶段，如何保证收集器线程和用户线程互不干扰的运行？"></a>并发标记阶段，如何保证收集器线程和用户线程互不干扰的运行？</h3><p>在并发标记阶段，因为 GC 线程的标记动作和用户线程在并发执行，所以整个过程中，对象的引用关系可能会发生变化，当前的主流垃圾收集器都是使用的可达性分析算法来判断对象是否存活，此时就需要考虑如何实现并发下的可达性分析。</p><h4 id="并发可达性分析"><a href="#并发可达性分析" class="headerlink" title="并发可达性分析"></a>并发可达性分析</h4><p>可达性分析中，是根据 GC Roots 节点开始遍历整个对象数，如果把这个过程分为两步：</p><ol><li><p>遍历 GC Roots 节点。</p></li><li><p>通过 GC Roots 节点遍历直接或间接关联的节点。</p></li></ol><p>那么第 1 步肯定是很快的，因为相对来讲，整个堆内存中的 GC Roots 节点肯定只是极少数的对象，而第 2 步的执行时间和回收区域的大小成正比，相应的 Stop The World 的时间也会升高，为了降低 Stop The World 的时间，才有了 GC 线程和用户线程并发的标记方法。</p><p>但是问题在于，如何保证在 GC 线程标记期间，用户线程运行时修改对象图结构不会造成 GC 标记的错误，这里的错误有两种：一种是应该收集的对象标记为存活，这种情况问题不大，大不了下次 GC 再回收；另一种是应该存活的对象被标记成了要收集的对象，这种情况就会导致用户线程严重错误。</p><p>为了解决上述问题，又提出了“三色标记法”。</p><h5 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h5><ul><li><p>白色</p><p>表示对象未被垃圾收集器扫描过，在可达性分析开始时，所有对象都是白色，如果可达性分析结束后依然是白色，表示对象不可达。</p></li><li><p>灰色</p><p>表示对象已经被垃圾收集器扫描过，但是该对象上至少还有一个引用没有被扫描过。</p></li><li><p>黑色</p><p>表示这个对象及其引用都已经被扫描过了，它是安全存活的对象，如果有其他对象又指向了它，并不需要重新扫描，黑色对象不会直接指向白色对象。</p></li></ul><p>如果在 GC 标记阶段直接 Stop The World，那么扫描完成后，每个对象的颜色要么白色要么黑色，不会有错。</p><p>但是如果 GC 线程和用户线程并发运行，就没这么简单了，这里主要解决的是“对象消失”的问题，即原本你应该是黑色的对象误标成了白色，要产生这种问题，只有同时满足下面两个条件才可以：</p><ol><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用。</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li></ol><p>也就是说，只需要打破其中任意一个条件，就能解决“对象消失”问题，针对这两种情况，给出了两种解决方案，分别是增量更新、原始快照。</p><h5 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h5><p>针对第一种情况：</p><blockquote><p>赋值器插入了一条或多条从黑色对象到白色对象的新引用。</p></blockquote><p>解决方案是，当有黑色对象指向白色对象的新引用时，将这个新引用记录下来，并发扫描结束后，以这个黑色节点为根节点再进行一次扫描。</p><p>什么意思呢？其实可以理解为，当黑色对象有新引用指向白色对象时，其实它就变成了灰色对象，这也和灰色对象的定义符合。</p><h5 id="原始快照"><a href="#原始快照" class="headerlink" title="原始快照"></a>原始快照</h5><p>针对第二种情况：</p><blockquote><p>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</p></blockquote><p>解决方案是，当删除了灰色对象指向白色对象的引用时，将这个引用记录下来，等并发标记结束后，再以这个灰色对象为根节点扫描一次。</p><p>什么意思呢？就是不管这个删除操作，以可达性分析开始时的对象图快照为准进行扫描。</p><p>以上两种解决方案都提到，需要在并发标记结束后以某个记录的节点为根节点再次扫描，这就说明，使用并发可达性分析的收集器，在并发标记之后，依然需要在 Stop The World 的情况下进行一次小范围的标记。</p><h4 id="G1-收集器的并发可达性分析"><a href="#G1-收集器的并发可达性分析" class="headerlink" title="G1 收集器的并发可达性分析"></a>G1 收集器的并发可达性分析</h4><p>CMS 收集器使用增量更新的算法来实现并发可达性分析，而 G1 收集器使用原始快照算法来实现。</p><p>并且，G1 收集器不仅实现了原始快照，还为每个 Region 块设计了两个名为 TAMS 的指针，在 GC 过程中用户线程产生的新对象都在 TAMS 指针之上，以 TAMS 为分界，上面的内存中的对象不会纳入垃圾收集的范围，而如果收集速度比不上产生新对象的速度时，G1 收集器也会暂停用户线程，执行 Full GC，也就导致了更长的 Stop The World 时间。</p><h3 id="怎么建立可靠的停顿预测模型？"><a href="#怎么建立可靠的停顿预测模型？" class="headerlink" title="怎么建立可靠的停顿预测模型？"></a>怎么建立可靠的停顿预测模型？</h3><p>通过 <code>-XX:MaxGCPauseMillis</code> 参数可以指定 G1 收集器的停顿时间期望值。</p><p>为了达到这个期望值，G1 在运行期间会收集每个 Region 块的收集“价值”，比如回收耗时、记忆集的脏卡数量等，然后通过这些数据预测现在开始回收的话，那些 Region 组成回收集可以在不超过用户期望时间的同时达到最大收集收益。</p><h2 id="G1-收集器运行过程"><a href="#G1-收集器运行过程" class="headerlink" title="G1 收集器运行过程"></a>G1 收集器运行过程</h2><h3 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h3><p>只标记 GC Roots 节点能直接关联的对象，这部分对象很少，虽然会 Stop The World，但是时间极短。同时还会修改 Region 中的 TAMS 的值，让下一阶段的标记运行同时，用户线程能正确分配对象。</p><h3 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h3><p>从 GC Roots 开始遍历整个堆的对象图，找出要回收的对象，这个时间很长，但是和用户线程并发执行，扫描结束后，还要处理原始快照算法记录下来的引用变动的对象。</p><h3 id="最终标记"><a href="#最终标记" class="headerlink" title="最终标记"></a>最终标记</h3><p>短暂的 Stop The World，处理并发标记结束后依然留下来的少量的原始快照算法记录的引用变动的对象。</p><h3 id="筛选回收"><a href="#筛选回收" class="headerlink" title="筛选回收"></a>筛选回收</h3><p>统计更新 Region 的回收统计数据，分析得出要回收的 Region 集合，然后将这些 Region 中存活的对象复制到空的 Region 中，再将要回收的 Region 整个清理掉，整体来讲，采用的是标记-整理算法，但是局部来讲，因为跨 Region 的操作，又是标记-复制算法。</p><p>这个过程需要移动对象，所以需要 Stop The World，但是停顿时间在用户的期望范围内。</p><blockquote><p>综上所述，尽管采用了并发标记的方式，但是 G1 收集器本身也是会 Stop The World 的，它的目的不是为了完全实现低延迟，而是为了实现延迟的可控。</p><p>虽然目标是延迟可控，但是如果这个期望的停顿时间设置得过分低了，那么为了达到这个期望值，每次 GC 都不会回收太多内存，久而久之，内存中的垃圾对象越来越多，直到内存不够用导致 Full GC，这只会带来更高的停顿时间，所以期望的停顿时间应该试场景合理配置，一般 100 ~ 300 ms 比较合理。</p></blockquote><h2 id="对比-CMS-收集器的优劣"><a href="#对比-CMS-收集器的优劣" class="headerlink" title="对比 CMS 收集器的优劣"></a>对比 CMS 收集器的优劣</h2><h3 id="G1-的优点"><a href="#G1-的优点" class="headerlink" title="G1 的优点"></a>G1 的优点</h3><ul><li><p>G1 得益于停顿预测模型和 Region 内存模型的红利，最大停顿时间有了可控性。</p></li><li><p>G1 整体采用标记-整理算法，局部采用标记-复制算法，不会有内存碎片，而 CMS 采用标记-清除算法，容易有内存碎片，所以 G1 有利于长时间运行，分配大对象时不会因为找不到连续内存空间而触发 Full GC。</p></li></ul><h3 id="G1-的缺点"><a href="#G1-的缺点" class="headerlink" title="G1 的缺点"></a>G1 的缺点</h3><ul><li>用户线程运行过程中，为了支持 G1 收集器导致的内存占用比 CMS 更高，比如么个 Region 都维护自己的记忆集，可能会占用 20% 的堆内存空间甚至更高，而 CMS 只有一份记忆集，相应的内存占用就会小很多。</li><li>G1 使用原始快照，CMS 使用增量更新，原始快照本身就比增量更新更耗费性能，况且 G1 的记忆集的结构比 CMS 的记忆集的结构又要复杂很多。</li></ul><blockquote><p>目前小内存应用上，CMS 的表现比 G1 更好，而大内存应用上 G1 的表现更好，这个优劣的平衡点在 6 ~ 8 GB 之间。</p><p>– 根据《深入理解 Java 虚拟机》原文删减。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> 深入理解Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机自动内存管理</title>
      <link href="posts/10d3f509192d.html"/>
      <url>posts/10d3f509192d.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/images/202201182236555.jpg'/><span id="more"></span><blockquote><p>本文是 《深入理解 Java 虚拟机》第 3 版的读书笔记。</p></blockquote><h2 id="JVM-内存区域划分"><a href="#JVM-内存区域划分" class="headerlink" title="JVM 内存区域划分"></a>JVM 内存区域划分</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul><li><p>可理解为当前线程所执行的字节码行号指示器。</p></li><li><p>从 JVM 的概念模型上看，是通过改变程序计数器选取下一条要执行的指令。</p></li><li><p>JVM 的多线程是通过线程轮流切换、分批处理器时间的方式来实现，所以需要每个线程都维护一个自己的程序计数器，方便线程切换后能恢复到正常的执行位置，因此，程序计数器是线程私有的，各线程的程序计数器单独存储，互不影响。</p></li><li><p>如果当前在执行一个 Java 方法，程序计数器记录的是当前正在执行的虚拟机字节码指令的地址。</p></li><li><p>如果当前在执行的是 native 本地方法，则程序计数器为空。</p></li><li><p>程序计数器是 JVM 运行时唯一没有规定任何 OutOfMemoryError 错误的内存区域中。</p></li></ul><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ul><li><p>描述 Java 方法执行时的线程内存模型：每个方法执行时，会创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p></li><li><p>每一个方法执行到执行完毕，都是一个栈帧从入栈到出栈的过程。</p></li><li><p>局部变量表存放的是编译期可知的 Java 基本数据类型、对象引用、returnAddress 类型，这些类型在局部变量表中存储空间以以变量槽的方式表示，局部变量表的大小在编译时就已经进行了分配，方法运行时，栈帧中要分配多大的局部变量表是确定了的，方法运行期间不会改变局部变量表的大小，这里的大小值得是槽的数量，至于每个槽占用的内存大小，不同虚拟机有不同的实现。</p><ul><li><p>Java 基本数据类型。boolean、byte、char、short、int、float、long、double，其中 long、double 两种数据类型占用两个变量槽，，其余数据类型占用一个变量槽。</p></li><li><p>对象引用。reference 类型，它不是对象本身，而是一个指向对象初始地址的引用指针，或者代表对象的句柄。</p></li><li><p>returnAddress 类型。方法的返回值地址，指向一条字节码指令地址。</p></li><li><p>虚拟机栈也是线程私有的内存区域。</p></li><li><p>栈深度超出虚拟机允许的最大深度时，会抛出 StackOverflowError 错误。</p></li><li><p>现在的虚拟机栈基本不支持扩展内存大小，所以当申请虚拟机栈的内存失败时，会抛出 OutOfMemoryError 错误。</p></li></ul></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul><li><p>和虚拟机栈类似，虚拟机栈服务与 Java 方法，本地方法栈服务于虚拟机调用的 native 本地方法。</p></li><li><p>和虚拟机栈一样，本地方法栈也会抛出 StackOverflowError 和 OutOfMemoryError 错误。</p></li></ul><h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><ul><li><p>所有对象实例和数组都在堆上分配内存。</p></li><li><p>主流 Java 虚拟机的堆都是以可扩展的方式实现，通过 -Xmx 和 -Xms 来配置。</p></li><li><p>如果堆中内存不足以完成新实例的分配，且无法再扩展时，会抛出 OutOfMemoryError。</p></li><li><p>堆内存在逻辑上是连续内存，在物理上可以是不连续的内存。</p></li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li><p>线程共享的内存区域。</p></li><li><p>存储类型信息、常量、静态变量、即时编译后的代码缓存。</p></li><li><p>和堆一样，不强制要求必须是连续的物理内存。</p></li><li><p>可扩展，甚至可以不实现垃圾回收。</p></li><li><p>无法满足新的内存需求时，会抛出 OutOfMemoryError。</p></li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul><li><p>方法区的一部分。</p></li><li><p>用于存放类加载后的生成的各种字面量和符号引用。</p></li><li><p>无法在申请到内存时，抛出 OutOfMemoryError。</p></li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ul><li><p>并不在虚拟机运行时的内存区域中。</p></li><li><p>JDK 1.4 之后引入了 NIO，可以通过 native 方法直接分配堆外的内存，通过 DirectByteBuffer 引用这块内存。</p></li><li><p>这样避免了在 Java 堆和 Native 堆之间来回复制数据，提高了性能。</p></li><li><p>堆外内存主要收操作系统的内存限制，当内存不足时，依然会抛出 OutOfMemoryError。</p></li></ul><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><ul><li><p>类加载</p></li><li><p>连接</p><ul><li><p>验证</p></li><li><p>准备</p></li><li><p>解析</p></li></ul></li><li><p>初始化</p></li></ul><blockquote><p>应该会有单独的笔记。</p></blockquote><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><ul><li><p>Mark Word</p><p>存储对象运行时数据：哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳。</p></li><li><p>类型指针</p><p>对象指向它的类型元数据指针。</p></li></ul><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><ul><li>对象真正存储的有效信息，即代码中定义的各种类型字段的内容。</li></ul><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><ul><li><p>非必要部分。</p></li><li><p>HotSpot 虚拟机自动内存管理要求对象起始地址大小必须是 8 的倍数，对象头设计成了 8 的倍数，但是实例数据部分，可能并不是 8 的倍数，为了对齐成 8 的倍数，会通过对齐填充来补全。</p></li></ul><h2 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h2><p>创建对象后，通过栈上的 reference 数据来操作堆上的具体的对象，reference 类型是一个引用类型，主要实现方式有两种。</p><ul><li><p>通过句柄访问。</p><ul><li><p>需要在堆中划分一块内存来作为句柄池。reference 中存的是句柄池中的句柄地址，句柄中存的是堆中的对象实例数据和方法区中的类型数据的地址信息。</p></li><li><p>好处在于如果对象实例地址变更（比如垃圾回收算法移动了对象实例），只需要变更句柄中的数据，而不用变更 reference 数据。</p></li></ul></li><li><p>通过直接指针访问。</p><ul><li><p>reference 中存的就是堆中的对象实例的地址，对象实例数据中有指向方法区中的类型数据的指针。</p></li><li><p>好处在于速度快，因为是直接引用了对象实例地址。</p></li></ul></li></ul><p>HotSpot 虚拟机主要使用的是通过直接指针访问。</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h3 id="判断对象是否存活？"><a href="#判断对象是否存活？" class="headerlink" title="判断对象是否存活？"></a>判断对象是否存活？</h3><ul><li><p>引用计数算法</p><ul><li><p>对象中添加一个引用计数器，有一个地方引用它，计数器加一，引用失效后，计数器减一。</p></li><li><p>无法解决对象 A、B 相互引用无法回收的情况。</p></li></ul></li><li><p>可达性分析</p><ul><li>通过一些列 GC Roots 对象作为起始节点集，根据这些节点的引用关系开始搜索，如果某个对象跟任何一个 GC Roots 节点都没有任何引用链，认为该对象不可达</li></ul></li></ul><h3 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h3><ul><li><p>强引用</p><p>日常代码中的类似 Object obj = new Object() 的引用关系，只要这种关系还在，垃圾收集器就不会回收被引用的对象。</p></li><li><p>软引用</p><p>描述有用但不是必要的对象，使用 SofeReference 类实现。只被软引用关联的对象，在内存即将溢出时会被回收，如果回收的软引用的对象之后内存还是不够，才会抛出内存溢出的异常。</p></li><li><p>弱引用</p><p>也是有用但非必要的对象，使用 WeakReference 实现，但是比软引用的强度低，弱引用的对象只能生存到下一次垃圾回收。</p></li><li><p>虚引用</p><p>最弱的引用关系，使用 PhantomReference 实现，设置虚引用的对象没实际的意义，只是为了能在它被回收时收到一个系统通知。</p></li></ul><h3 id="对象的自救"><a href="#对象的自救" class="headerlink" title="对象的自救"></a>对象的自救</h3><ul><li><p>当一个对象被判断为不可达之后，如果该类没实现 finalize() 方法，或者 finalize() 方法是否已经被虚拟机调用过了，如果是，那么对象将被回收，无法自救。</p></li><li><p>如果对象实现了 finalize() 方法且还未被虚拟机调用，那么该对象将进入 F-Queue ，会有另一个线程去执行它的 finalize() 方法，这是被判定为不可达之后唯一的“自救”机会，只要重新与引用链上任何一个对象建立关联即可。为了防止 finalize() 方法有问题，比如死循环导致阻塞以至于整个队列其他元素阻塞，虚拟机将不会等待 finalize() 方法执行完毕。</p></li></ul><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><h4 id="分代假说"><a href="#分代假说" class="headerlink" title="分代假说"></a>分代假说</h4><ol><li><p>弱分代假说：绝大多数对象都是朝生夕死。</p></li><li><p>强分代假说：熬过垃圾收集次数越多的对象，越不容易消亡。</p></li><li><p>跨代引用假说：跨代引用相对于同代引用，仅占极少数。</p></li></ol><p>对于假说 1、2，有些对象朝生夕死，有些对象熬过的垃圾收集次数越多，越不容易消亡。对于朝生夕死的对象，放到一起，每次垃圾收集时只关心那些少量的要存活的对象，如果剩余的都是些难以消亡的对象，将他们放在一起，这个区域的垃圾收集频率适当降低，这样垃圾收集的时间效率和内存的有效利用即可兼顾；这样就将对象分成了新生代和老年代；相应的有了 Minor GC、Major GC、Full GC 三种回收类型；针对不同分代区域的对象特征，又发展出了标记-复制算法、标记-清除算法、标记-整理算法。</p><p>对于假说 3，是指新生代的对象和老年代的对象有引用关系，导致进行 Minor GC 时，因为这个跨代引用还需要扫描老年代的 GC Roots，耗费性能。其实这个问题，长远来看，因为跨代引用，新生代中的对象也会随着时间推移进入老年代，那么跨代引用其实真就像假说 3 一样只是少数，所以没必要扫描所有的老年代的 GC Roots，只需要将老年代划分为多块，新生代只需要标记哪一块有跨代引用，发生 Minor GC 时，对于跨代引用的处理只需要扫描一小块的老年代对象。</p><h4 id="垃圾收集类型"><a href="#垃圾收集类型" class="headerlink" title="垃圾收集类型"></a>垃圾收集类型</h4><ul><li><p>Minor GC / Young GC</p><p>目标是新生代的垃圾收集。</p></li><li><p>Major GC / Old GC</p><p>老年代垃圾收集行为。目前只有 CMS 收集器有单独的老年代收集行为。</p></li><li><p>Mixed GC</p><p>目标是新生代和部分老年代的收集行为。目前只有 G1 收集器有这种收集行为。</p></li><li><p>Full GC</p><p>收集整个 Java 堆和方法区。</p></li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><ul><li><p>执行步骤</p><p>首先标记处所有需要清除的对象，标记完成后，统一回收标记的对象。</p></li><li><p>缺点</p><ol><li><p>执行效率不稳定。Java 堆中大部分对象都是需要被回收的，有大量的对象需要标记和回收，导致随着 Java 堆中的对象数量上涨，垃圾回收的效率也降低。</p></li><li><p>内存空间碎片化。标记-清除后，会产生大量不连续的内存碎片，导致如果需要申请大对象时，如果没有连续的大内存空间，会触发下一次垃圾回收动作。</p></li></ol></li></ul><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><ul><li><p>执行步骤</p><p>将内存分为两块，每次只使用其中一块，这一块内存用完之后，将存活的对象复制到另一块内存上面，然后将已使用的那一块内存空间直接清除掉。</p></li><li><p>优点</p><p>实现简单，运行高效。如果内存中多数对象都会存活，那么对象复制的开销比较大，但是对于多数对象都可回收的情况，算法复制的对象就只是少数了，而且每次回收都只是部分内存。</p></li><li><p>缺点</p><p>可用的内存缩小为实际内存的一半。</p></li></ul><blockquote><p>Appel 式回收：</p></blockquote><ul><li><p>Appel 式回收，是标记-复制算法的一个改良版本。</p></li><li><p>标记-复制算法浪费了一半内存，Appel 式回收将内存划分为一块大的 Eden 区和两块小的 Survivor 区，每次使用 Eden 区和一块小的 Survivor 区，每次回收时，将存活的对象复制到另一个小的 Survivor 区上。</p></li><li><p>HotSpot 虚拟机的 Serial、ParNew 等新生代收集器就是使用这种算法设计新生代的内存布局，默认的 Eden 和 Survivor 内存占比为 8:1，也就是只会浪费 10% 的内存。</p></li><li><p>如果 GC 的时候一个小的 Survivor 区内存不足以装下所有存活的对象，就需要依赖其他内存区域进行分配担保，一半是将无法装下的对象分配进入老年代。</p></li></ul><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><ul><li><p>执行步骤</p><ol><li><p>先标记要回收的对象；</p></li><li><p>然后将存活的对象移动到内存的一端；</p></li><li><p>最后清理掉边界以外的内存空间；</p></li></ol></li></ul><blockquote><p>和标记-清除算法的主要区别在于，是否移动对象？</p></blockquote><ol><li><p>如果移动，在 GC 时移动对象会影响用户线程，因为这会导致 Stop The World，这会为用户线程带来更高的延迟。</p></li><li><p>如果不移动，就会出现内存碎片，此时也可以通过更复杂的内存分配器（比如空闲列表）来解决问题，虽然也有 Stop The World，但通常时间很短，所以对用户线程造成的延迟较小。</p></li><li><p>标记-整理算法对程序吞吐量更加友好，标记-清除算法对延迟敏感的应用更加友好。CMS 收集器主要使用标记-清除算法实现，但是当遇见内存碎片比较严重的情况时，又改用标记-整理算法来进行 GC。</p></li></ol><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><ul><li><p>Serial 收集器是新生代收集器，采用标记-复制算法，单线程执行，所以会停掉所有的用户线程。</p></li><li><p>它是所有收集器中，额外占用内存最小的。</p></li><li><p>适用于用户桌面环境和一些微服务环境的应用，因为它们占用的内存一般不大，几十到几百兆，Serial 的 Stop The World 可以控制在十几毫秒或者几十毫秒，只要不频繁发生 GC，就不会有什么影响。</p></li></ul><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><ul><li><p>新生代垃圾收集器，Serial 的多线程版本，Serial 的 GC 线程是单线程运行标记-复制算法，而  ParNew 采用多个 GC 线程并行执行而已，依然会有 Stop The World。</p></li><li><p>是除了 Serial 之外，唯一能和 CMS 收集器搭配的新生代收集器，JDK 9 开始，也只有 ParNew 能和 CMS 收集器搭配了。</p></li><li><p>在单核环境下，因为有线程切换的开销，所以性能其实比不上 Serial 收集器。</p></li><li><p>多处理器核心环境下，可以通过 -XX:ParallelGCThreads 参数来限制 GC 线程数。</p></li></ul><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><ul><li><p>新生代收集器。</p></li><li><p>使用标记-复制算法，多个 GC 线程并行执行。</p></li><li><p>和 ParNew 的区别在于，ParNew 更关注 Stop The World 的时间，Parallel Scavenge 更关注应用的吞吐量。<br>吞吐量 = 运行用户代码时间 / (用户代码运行时间 + 运行垃圾收集时间)</p></li><li><p>适用于后胎运行而不需要太多交互的任务。</p></li><li><p>Parallel Scavenge 收集器还提供了 -XX:+UseAdaptiveSizePolicy 配置是否启用自适应调节策略，如果开启该功能，就不用设置新生代大小 -Xmn 、Eden 和 Survivor 区的比例 -XX:SurvivorRatio、晋升老年代的对象大小 -XX:PretenureSizeThreshold 等参数，Parallel Scavenge 收集器会根据虚拟机当前的运行状况调节这些参数。</p></li><li><p>通过 -XX:MaxGCPauseMillis 设置最大停顿时间，是一个大于 0 的毫秒数，GC 线程会尽量在配置的时间内完成收集任务。<br>并不是这个值设置得越小，垃圾收集就越快这么简单，垃圾收集越快，会导致触发触发 GC 的频率上升，相应的吞吐量肯定也会逐渐下降。</p></li><li><p>通过 -XX:GCTimeRatio 设置吞吐量大小，该配置为一个整数，如果设置为 N，表示 GC 时间不超过程序运行时间的 1 / (1 + N)，该配置默认为 99，即 GC 时间不超过运行时间的 1%。</p></li><li><p>和 Parallel Scavenge 收集搭配的老年代收集器是 PS MarkSweep 收集器，这个收集器和 Serial Old 收集器一样的实现原理。</p></li></ul><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><ul><li><p>Serila 的老年代收集器版本，采用标记-整理算法，单线程运行。</p></li><li><p>多是客户端模式下 HotSpot 虚拟机采用的老年代收集器。</p></li><li><p>如果在服务端使用该收集器，要么是在 JDK 5 及之前的版本搭配 Parallel Scavenge 收集使用，要么就是作为 CMS 收集器失败时的备选方案。</p></li></ul><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><ul><li><p>Parallel Scavenge 收集器的老年代版本，多 GC 线程并行执行，使用标记-整理算法。</p></li><li><p>和 Parallel Scavenge 收集器组合，适用于比较注重吞吐量或者处理器资源比较稀缺的场景。</p></li><li><p>在这个收集器出现之前，Parallel Scavenge 收集器的老年代搭配只有 Serial Old（其实是 PS MarkSweep） 收集器，但是因为 Parallel Scavenge 收集器注重吞吐量，而 Serial Old 收集器是单线程的，不能更好利用处理器资源，所以 Paralle Scavenge 收集器用的不多。</p></li></ul><h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><ul><li><p>Concurrent Mark Sweep，老年代收集器，采用标记-清除算法，以获取最短收集停顿时间为目标的收集器，它的收集过程分为 4 步。</p><ul><li><p>初始标记<br>初始标记只是标记 GC Roots 直接关联上的对象，这个过程因为不会深度遍历，所以比较快。</p></li><li><p>并发标记<br>并发标记是多个 GC 线程通过前一步标记的 GC Roots 直接关联的对象遍历对象图，这个过程虽然耗时比较长，但是不需要 Stop The World。</p></li><li><p>重新标记<br>重新标记是修正并发标记期间产生的用户线程运行导致的标记变动，这个过程比初始标记的过程长，但是远远比不上并发标记，该过程需要 Stop The World。</p></li><li><p>并发清除<br>并发清除是多个 GC 线程并行清除前面标记出的不再存活的对象，由于不需要移动对象，所以不需要 Stop The World。</p></li></ul></li><li><p>初始标记和重新标记需要 Stop The World。</p></li><li><p>因为 GC 过程中耗时最长的部分都是和用户线程并发执行的，所以 CMS 收集器的停顿时间是比较短的。</p></li><li><p>CMS 收集器的 3 个缺点：</p><ul><li><p>因为每次 GC 过程中大部分时间都是和用户线程并发执行，相应的对服务器资源的要求就比较高了，CMS 收集器默认会启动的 GC 线程数为 (处理器核心数 + 1) / 4，对于核心数大于等于 4 的服务器，GC 线程最多占用 25% 的运算资源，但是如果用户线程本就资源紧张的环境，还要分资源给 CMS，这样会降低用户程序的吞吐量，只管感受就是执行速度大幅度降低。</p></li><li><p>CMS 收集不了浮动垃圾，当 CMS 和用户线程在并发运行时，如果用户线程产生了新的对象，便随产生了新的垃圾，这部分就是浮动垃圾，因为这部分垃圾出现在标记结束后，所以只能留待下一次 GC 再清理，因为 GC 线程和用户线程并发运行，所以 GC 过程中还需要留出内存给用户线程， 因此，CMS 收集器不能等到老年代被占满之后再进行 GC，在 JDK 5 的时候，默认是当老年代内存占用的 68% 时就会进行 GC，通过 -XX:CMSInitiatingOccupancyFraction 参数配置，JDK 6 时改配置提升为 92%，参数设置得太高也不行，因为达到 92% 时，CMS 启动 GC 线程会再占用部分内存，此时的内存如果不够申请新的对象，很可能会出现内存不足的情况，此时就会出现一次并发失败（Concurrent Mode Failure），此时虚拟机只能采取备选方案，使用 Serial Old 收集器对老年代进行一次收集。</p></li><li><p>CMS 收集器使用标记-清除算法，这种算法每次运行都会出现内存碎片，此时就会出现老年代还有很多空间，但是就是无法分配足够的内存，不得不触发一次 Full GC，针对这个问题，CMS 收集器提供 -XX:+UseCMSCompactAtFullCollection(JDK 9 已废弃) 来开启在 Full GC 时整理内存碎片，虽然内存碎片的问题解决了，但是因为标记-整理算法在整理内存碎片时需要 Stop The World，导致用户线程停顿时间变长了，针对这个问题，CMS 收集器提供 -XX:CMSFullGCsBeforeCompact(JDK 9 已废弃) 参数来决定几次 Full GC 不整理内存碎片后，下次 Full GC 就必须整理，该参数默认是 0，即每次 Full GC 都整理。</p></li></ul></li></ul><blockquote><p>另外还有 3 个新的收集器，应该会单独写笔记了，太复杂了。</p></blockquote><ul><li><p>G1（Garbage First）收集器</p></li><li><p>ZGC 收集器</p></li><li><p>Shenandoah 收集器</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> 深入理解Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言入门</title>
      <link href="posts/f7f04dd66a62.html"/>
      <url>posts/f7f04dd66a62.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/images/202201032000947.png'/><span id="more"></span><h1 id="Go-语言入门"><a href="#Go-语言入门" class="headerlink" title="Go 语言入门"></a>Go 语言入门</h1><blockquote><p>我是一个 Java 开发者，所以本文大多是与 Java 的语法对比，方便作为一个 Java 开发者的自己理解，所以有些和 Java 类似的语法，只会写一个例子，不会再做解释。</p><p>本文是学习 Go 官方的教程 <a href="https://go.dev/tour/welcome/1">A Tour of Go</a> 时按自己的理解写下。</p></blockquote><p>和 Java 类似，Go 程序也是从一个 main 函数开始。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(math.pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>package 关键字就是包的意思，后面接包名即可</li><li>import 关键字用来引入其他的第三库</li><li>func 关键字用来定义一个函数。</li></ul><h2 id="函数（方法）"><a href="#函数（方法）" class="headerlink" title="函数（方法）"></a>函数（方法）</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>,y <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个方法的形式是<code>func &lt;methodName&gt;[arg1 typeOfArg1, arg2 typeOfArg2] &lt;returnType&gt; &#123;[function body]&#125;</code>。</p><p>如果参数类型一样，也可以简写成如下形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即：<code>func &lt;methodName&gt;[arg1, arg2 typeOfArg] &lt;returnType&gt; &#123;[function body]&#125;</code></p><h3 id="多返回值函数定义"><a href="#多返回值函数定义" class="headerlink" title="多返回值函数定义"></a>多返回值函数定义</h3><p>Go 还支持一个函数有多个返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，多个返回值时，用括号讲返回值得类型括起来，用逗号分割即可。</p><h3 id="已命名返回值"><a href="#已命名返回值" class="headerlink" title="已命名返回值"></a>已命名返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x,y <span class="type">int</span>) &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum - x</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，return 关键字后面没有跟任何代码，函数的返回值类型不再是单纯定义类型，而是两个变量，在 <code>split</code> 方法体中改变了 x、y 两个变量的值，调用 split 方法后的最终返回值，就是函数体执行完后 x、y 最终的值。</p><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(add(<span class="number">42</span>, <span class="number">13</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用方法名拼接参数的形式即可。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">    fmt.Println(i, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>var</code> 关键字定义变量的 形式<code> var &lt;var_name1&gt;[,var_name2...] type1</code>。</p><p>变量可以定义在函数内，也可以定义在函数外，上面这种定义方式，变量的值都是类型对应的初始值。还可以在定义变量时就给一个初始化的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line">    fmt.Println(i, j, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对于前面的定义方式，这里不再指定类型，而是直接使用 <code>=</code> 符号对每个变量赋值，而变量类型，由初始化的值得类型决定，且可以使用同一个 var 关键字初始化多个不同类型的变量。</p><p>上面这种赋予值得变量初始化，还有两一种更简单的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    k, m := <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">    c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(i, j, k, m, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来讲就是变量名和值之间使用 <code>:=</code> 连接，指定类型的同时也进行了赋值，且同样可以同时定义多个变量。</p><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><ul><li><p>bool</p><p>布尔类型，其实就是 true 和 false 这两种值。</p></li><li><p>string</p><p>字符串类型。</p></li><li><p>int、int8、int16、int32、int64</p><p>整数类型，区分正负号，后面的数字代码类型的大小，int 在后面有单独说明。</p><p>比如 int8 表示一个 int8 类型的变量占用 8 bit，因为最高位用来作为正负数表示，1 表示负数，0 表示非负数，所以非负数最高位位 0，实际值只有七位，所以最大只有 二进制数<code>01111111</code>，也就是 <code>2^8-1 = 127</code>，负数最高位为 1，此时如果所有位都是 1，二进制数为 <code>11111111</code>，负数的实际值有 8 位，不过最高位一直是 1，所以最小的负数为 <code>-2^8 = -128</code>。</p><blockquote><p>这里会发现一个有趣的等式：2 ^n-1 = 2^0+2^1+2^2+…+2^(n-1)</p></blockquote></li><li><p>uint、uint8、uint16、uint32、uint64、uintptr</p><p>无符号整数类型，只表示非负整数，后面的数字依然表示类型的大小。</p><p>比如 uint8, 表示一个 uint8 类型的变量有 8 bit，最小为 0，最大为 <code>2^8-1 = 255</code>。 </p></li><li><p>byte</p><p>可理解为别名为 byte 的 uint8。</p></li><li><p>rune</p><p>和 int32 一样。官方教程讲这个类型用来表示 Unicode。</p></li><li><p>float32、float64</p><p>浮点型，后面的数字依然是所占的 bit 数。</p></li><li><p>complex64、complex128</p><p>高等数学里面的<code>复数</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c := <span class="built_in">complex</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    fmt.Println(x) <span class="comment">// 输出结果: (2+3i)</span></span><br><span class="line">    c := <span class="number">3</span>+<span class="number">4i</span></span><br><span class="line">    fmt.Println(x) <span class="comment">// 输出结果: (3+4i)</span></span><br><span class="line">    realPart := <span class="built_in">real</span>(c) <span class="comment">// 实数部分</span></span><br><span class="line">    imagPart := <span class="built_in">imag</span>(c) <span class="comment">// 虚数部分</span></span><br><span class="line">    fmt.Println(realPart, imagPart) <span class="comment">// 输出结果: 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>int、uint、uintptr 在 32 位操作系统上是 32 bit，在 64 位操作系统上是 64 bit，一般都是建议使用 int，除非有什么特殊的变量大小要求或者需要无符号 int。数字类型的初始值是 0，bool 类型初始值为 false，string 类型初始值为 <code>&quot;&quot;</code>。</p><p>Go 中各个类型的转换需要显示转换，比如 int8 转 int16：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int8</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> y <span class="type">int16</span> = <span class="type">int16</span>(x)</span><br><span class="line">    fmt.Println(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量和变量的定义类似，只不过不能使用 <code>:=</code> 赋值，而是直接使用 <code>=</code>。</p><h2 id="分支、循环"><a href="#分支、循环" class="headerlink" title="分支、循环"></a>分支、循环</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>按照 Java 的 for 循环语法，分为初始条件、循环条件、循环后操作、循环体，即 <code>for(初始条件;循环条件;循环后操作)&#123;循环体&#125;</code>。</p><p>Go 也是一样，不过没有使用小括号将初始条件、循环条件、循环后操作括起来，所以 Go 的 for 循环如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">    sum += j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 for 后面定义的循环变量 i，作用域只在这个 for 循环。和 Java 一样，Go 的 for 循环的初始条件部分也可以不写，但是后面的分号是必要的。</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>Go 中的 while 和 Java 不一样，而是使用了 for 关键字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br></pre></td></tr></table></figure><h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>和 Java 的区别在于，Go 中 if 的条件语句没有用小括号括起来，而大括号是必须要的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(-x) + <span class="string">&quot;i&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 中的 if 语句的小括号内还可以有简单的逻辑语句，Go 也可以。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if…else…"><a href="#if…else…" class="headerlink" title="if…else…"></a>if…else…</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lim</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if...else if...</code> 以及 <code>if...else if...else...</code>语法也和 Java 类似，不解释。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">&quot;Go runs on &quot;</span>)</span><br><span class="line">    os := runtime.GOOS;</span><br><span class="line">    <span class="keyword">switch</span> os &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 Java 最大的区别在于，Java 里面每一个 case 执行体最后都需要一个 break 来结束执行，Go 里面已经隐式的加上了 break，所以 Java 里面多个 case 使用同一段 case 执行体的写法在 Go 里面不会达到预期效果。</p><p>如果 switch 的条件是空的，就相当于是一个 if 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := time.Now()</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面这个，就相当于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := time.Now()</span><br><span class="line">    <span class="keyword">if</span> t.Hour() &lt; <span class="number">12</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.Hour() &lt; <span class="number">17</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h2><p>defer 是 Go 里面的一个语法关键字，defer 语句会在函数返回前执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面这个函数最终会输出的结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><p>因为输出了 hello 之后，函数就要返回了，此时会执行 defer 中的逻辑，输出 world。</p><p>但是，这里有一个值得注意的地方，先看下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> world(getStr())</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">world</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getStr</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;get world&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按理说，这里的输出结果应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">get world</span><br><span class="line">world</span><br></pre></td></tr></table></figure><p>但是实际的输出结果却是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get world</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><p>这是因为 <strong>defer 语句会先执行内层的函数，只有最外层的函数才会在返回前执行。</strong></p><p>如果有多个 defer 语句，那么这些 defer 语句在函数返回时的执行顺序，就像是一个栈（Stack）一样，最先定义的 defer，最后才执行。</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote><p>指针这个东西，第一次见是在 C 语言中，我的理解是，指针记录的是变量的内存地址。</p></blockquote><p>首先需要先认识 <code>&amp;</code> 和 <code>*</code> 这两个特殊符号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span></span><br><span class="line">p := &amp;i</span><br><span class="line">j := *p</span><br></pre></td></tr></table></figure><p><code>&amp;</code> 后接变量名表示获取变量的指针，比如上面的 p 就是变量 i 的指针，<code>*</code> 后面接指针变量，就是通过指针获取变量的实际值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i := <span class="number">42</span></span><br><span class="line">    p := &amp;i</span><br><span class="line">    j := *p</span><br><span class="line">    fmt.Println(i) <span class="comment">// 42</span></span><br><span class="line">    fmt.Println(p) <span class="comment">// 0xc00000a098, 这个 16 进制数就是内存地址了</span></span><br><span class="line">    fmt.Println(j) <span class="comment">// 42</span></span><br><span class="line">    *p = <span class="number">21</span> <span class="comment">// 通过指针为变量赋值</span></span><br><span class="line">    fmt.Println(i) <span class="comment">// 21</span></span><br><span class="line">    fmt.Println(j) <span class="comment">//42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">42</span><br><span class="line">0xc00000a098</span><br><span class="line">42</span><br><span class="line">21</span><br><span class="line">42</span><br></pre></td></tr></table></figure><p>上面的代码，我们可以知道如下几点：</p><ul><li>指针的值是指针所表示的变量的虚拟内存地址（额，这是按操作系统层面的说法，其实就是平常说的内存地址），将指针输出就能证明这一点。</li><li>因为修改了 <code>*p</code> 的值之后，j 依然是 42，这说明 <code>j := *p</code> 这行代码其实是值传递，其实 j 重新申请了内存，不过内存里的值和 *p 一样而已。</li></ul><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>在 C 语言里面就出现了这个关键字。它其实用来定义多个字段的集合，好吧其实可以理解为 Java 里面的一个类。</p><h3 id="定义-struct"><a href="#定义-struct" class="headerlink" title="定义 struct"></a>定义 struct</h3><p>定义一个 struct 也很简单。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="type">int</span></span><br><span class="line">    Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">    fmt.Println(v.X)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得在 Java 中，对象是要 <code>new</code> 出来的，Go 也类似，但是并没有为此专门加一个关键字，而是向上面的代码那样 struct 的名称后面接大括号，括号内写入每个字段的值即可，而要访问内部的字段，直接通过 <code>变量名.字段名</code> 的方式就可以访问。</p><h3 id="struct-指针"><a href="#struct-指针" class="headerlink" title="struct 指针"></a>struct 指针</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="type">int</span></span><br><span class="line">    Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(v) <span class="comment">// &#123;1, 2&#125;</span></span><br><span class="line">    p := &amp;v</span><br><span class="line">    fmt.Println(p) <span class="comment">// &amp;&#123;1 2&#125;</span></span><br><span class="line">    p.X = <span class="number">1e9</span></span><br><span class="line">    fmt.Println(v) <span class="comment">// &#123;1000000000, 2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现这里使用 <code>p.X</code> 进行赋值时，按照之前的理解，应该会出错的，因为 p 只是一个内存地址，哪里去找 X 这个字段，但其实 Go 在这里隐式转换成了 <code>(*p).X</code>。</p><p>初始化一个 struct 实例的时候，如果大括号里面啥也不写，那么每个字段的值将是初始值，如果只想给某些字段赋值，在大括号内就可以使用类似 json 的语法进行赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="type">int</span></span><br><span class="line">    Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    v1 := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(v1) <span class="comment">// &#123;1, 2&#125;</span></span><br><span class="line">    v2 := Vertex&#123;&#125;</span><br><span class="line">    fmt.Println(v2) <span class="comment">// &#123;0, 0&#125;</span></span><br><span class="line">    v3 := Vertex&#123;Y:<span class="number">1</span>&#125;</span><br><span class="line">    fmt.Println(v3) <span class="comment">// &#123;0, 3&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure><p>上面的代码便是定义了一个容量大小为 10 的 int 类型的数组变量 a。和 Java 中类似，这样的数组的容量是不可变的。</p><p>还可以在定义数组时就将每个元素的值填充进去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">primes := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h3><blockquote><p>翻译为：切片，这里我认为其实是数组切分的意思。</p></blockquote><h4 id="创建-Slices"><a href="#创建-Slices" class="headerlink" title="创建 Slices"></a>创建 Slices</h4><ul><li>通过数组创建</li></ul><p>Slices 其实就是截取数组中的部分元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    primes := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的 <code>primes[1:4]</code> 是获取 primes 数组中的下标为 1 一直到下标为 3 的元素，也就是说 <code>[1,4]</code> 转换成数学里面的区间概念的话，就是一个前闭后开区间，并且和 Java 一样，数组中元素的下边是从 1 开始。</p><p>并且，冒号前后的数字是可以省略的，省略冒号前面的数字表示从下标 0 开始取，省略冒号后面的数字表示一直取到最后一个元素，如果两个数字都省略了，将会获取所有元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> = primes[:<span class="number">4</span>] <span class="comment">// 从 0 取到 3</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> = primes[<span class="number">1</span>:] <span class="comment">// 从 1 取到最后</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> = primes[:] <span class="comment">// 取 primes 中所有元素</span></span><br></pre></td></tr></table></figure><ul><li>通过 Slices literal syntax（切片文本语法）创建</li></ul><p>除了通过 Array 创建，还可以通过下面的方式创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure><p>会发现，这跟定义 array 的语法十分相似，只不过 array 指定了数组长度。</p><ul><li>通过其他的 slices 创建</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> odds =  [<span class="number">8</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>&#125;</span><br><span class="line">    slice1 := odds[<span class="number">2</span>:]</span><br><span class="line">    fmt.Println(slice1)     <span class="comment">// prints [5 7 9 11 13 15]</span></span><br><span class="line">    slice2 := slice1[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">    fmt.Println(slice2)     <span class="comment">// prints [9 11]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 make 方法创建</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>) <span class="comment">// make an int slice of length 5</span></span><br><span class="line">    fmt.Println(s) <span class="comment">// [0 0 0 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 make() 函数创建了一个长度和容量都是 5 的 slices。</p><p>make() 函数还支持创建长度和容量不一样的 slices。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printSlice(<span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>))</span><br><span class="line">    printSlice(<span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">len=5 cap=5 [0 0 0 0 0]</span><br><span class="line">len=4 cap=5 [0 0 0 0]</span><br></pre></td></tr></table></figure><h4 id="Slices-和-Array-的区别"><a href="#Slices-和-Array-的区别" class="headerlink" title="Slices 和 Array 的区别"></a>Slices 和 Array 的区别</h4><blockquote><p>Arrays, after declared of some size, cannot be resized, whereas slices can be resized. Slices are reference-types while arrays are value-type.</p></blockquote><p>数组的容量固定，不能改变容量，但是 Slices 的容量可以改变，Slices 是引用类型，array 是值类型。</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>Slices 操作并非是重新申请内存才存截取出的数据，里面每一个元素都是原始数组中的数据，通过以下代码就可以证明这一点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    names := [<span class="number">4</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Paul&quot;</span>,</span><br><span class="line">        <span class="string">&quot;George&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Ringo&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(names)</span><br><span class="line"></span><br><span class="line">    a := names[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    b := names[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">&quot;XXX&quot;</span></span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">    fmt.Println(names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[John Paul George Ringo]</span><br><span class="line">[John Paul] [Paul George]</span><br><span class="line">[John XXX] [XXX George]</span><br><span class="line">[John XXX George Ringo]</span><br></pre></td></tr></table></figure><p>可以看见，通过数组变量 b 将 b 中的下标为 0 的元素设置为 XXX，而这个元素其实是 names 中的下标为 1 的元素，所以此时再输出 names 的内容，发现 names 下标为 1 的元素的值也变成了 XXX。</p><h4 id="长度和容量"><a href="#长度和容量" class="headerlink" title="长度和容量"></a>长度和容量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slice the slice to give it zero length.</span></span><br><span class="line">    s = s[:<span class="number">0</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extend its length.</span></span><br><span class="line">    s = s[:<span class="number">4</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Drop its first two values.</span></span><br><span class="line">    s = s[<span class="number">2</span>:]</span><br><span class="line">    printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>长度是指 slices 结果中包含的元素个数，通过 len() 函数计算。</p></li><li><p>容量是基于做 slices 操作的数组的容量计算的，并且从 slices 结果中的第一个元素开始算，一直到底层数组的最后一个元素，通过 cap() 函数计算。</p></li><li><p>如果 Slice 有足够的容量，可以通过 re-slices 扩展 slices 的长度，但是超出容量会报错。</p></li></ul><h4 id="Nil-Slice"><a href="#Nil-Slice" class="headerlink" title="Nil Slice"></a>Nil Slice</h4><p>如果只是定义了一个 slices 变量，而没有为其中的元素赋值，slices 为 nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">    fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;nil!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] 0 0</span><br><span class="line">nil!</span><br></pre></td></tr></table></figure><h4 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slices := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    printSlice(slices)</span><br><span class="line">    s := <span class="built_in">append</span>(slices, <span class="number">1</span>)</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    printSlice(s)</span><br><span class="line">    printSlice(slices)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len=5 cap=5 [0 0 0 0 0]</span><br><span class="line">len=6 cap=10 [1 0 0 0 0 1]</span><br><span class="line">len=5 cap=5 [0 0 0 0 0] </span><br></pre></td></tr></table></figure><p>从上面代码的运行结果可以知道，append() 函数不仅进行了扩容，而且会新返回一个 slices，而不是修改原有的 slices。</p><blockquote><p>整个 slices 相关的知识其实还有一些，可以阅读一下下面的官方博客：</p><p><a href="https://golangdocs.com/slices-in-golang">Slices in GoLang</a></p><p><a href="https://go.dev/blog/slices-intro">Go Slices: usage and internals</a></p><p><a href="https://pkg.go.dev/builtin#append">function: append</a></p></blockquote><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><blockquote><p>有点像Java 中的 foreach 语法的味道。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i 是循环数组下标，v 是下标对应的值，这个顺序是不会变的。</p><p>如果只想要下标或者只想要每个下标对应的值，可以像下面这样用下划线代替。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pow := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        pow[i] = <span class="number">1</span> &lt;&lt; <span class="type">uint</span>(i) <span class="comment">// == 2**i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 range 语法中下标和值得顺序不会变，下标变量在前，值变量在后，所以如果只需要下标的话，不需要用下划线 <code>_</code> 代替值变量，但如果只想要值变量，因为前面的下标变量不可少，所以需要用 <code>_</code> 代替。</p><blockquote><p>下划线 <code>_</code> 在这里真的就只是一个占位符而已，并不具有定义一个变量的语义，所以循环里面要是把 <code>_</code> 当成下标变量使用是会报错的。</p></blockquote><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>可理解为 Java 中的 Map 一样的键值对的数据结构，和 slices 一样，map 的初始化值为 <code>nil</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Vertex)</span><br><span class="line">    m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(m[<span class="string">&quot;Bell Labs&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 map 有三种语法：</p><ul><li><p>第一种语法：<code>var m map[string]Vertex</code> </p><p>string 就是键的类型，Vertex 是值得类型。</p><p>这种方式因为没有初始化值，所以是 nil，也不能再增加键值对，因为对 nil 执行任何方法都会报错，就像 Java 中常常因为 null 导致空指针一样。</p></li><li><p>第二种语法：<code>make(map[string]Vertex)</code></p><p>通过 make() 函数创建 map。</p></li><li><p>第三种语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;Google&quot;</span>: Vertex&#123;</span><br><span class="line">        <span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略值的类型名称</span></span><br><span class="line">m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">    <span class="string">&quot;Google&quot;</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="增加键值对"><a href="#增加键值对" class="headerlink" title="增加键值对"></a>增加键值对</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m[key] = value</span><br></pre></td></tr></table></figure><h4 id="根据键获取值"><a href="#根据键获取值" class="headerlink" title="根据键获取值"></a>根据键获取值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ele = m[key]</span><br></pre></td></tr></table></figure><h4 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, key)</span><br></pre></td></tr></table></figure><h4 id="判断-map-中是否存在某个-key"><a href="#判断-map-中是否存在某个-key" class="headerlink" title="判断 map 中是否存在某个 key"></a>判断 map 中是否存在某个 key</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v,ok := m[key]</span><br></pre></td></tr></table></figure><p>v 是 key 对应的 value，如果不存在，v 就是 value 对应类型的零值；ok 是判断结果，true 表示存在，false 表示不存在。</p><h2 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h2><p>函数本身也可以定义成一个变量，并当作函数调用的参数做值传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="type">float64</span>, <span class="type">float64</span>)</span></span> <span class="type">float64</span>) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(compute(hypot))</span><br><span class="line">    fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义了一个 compute 函数，参数也是一个入参为两个 float64 类型变量、返回值类型为 float64 类型的函数，compute 函数本身的返回值类型为 float64。</p><p>在 main 函数中，定义了一个 <code>hypot</code> 变量，它是一个函数变量，入参为两个 float64 类型，返回值类型为 float64。</p><p>从后续的代码可以知道，hypot 变量可以当成函数名称以函数的形式直接调用，还可以当成函数调用参数传入 compute 函数。</p><h2 id="方法（method）"><a href="#方法（method）" class="headerlink" title="方法（method）"></a>方法（method）</h2><p>在 Java 里面，很多时候将函数和方法这两个名词混为一谈，因为不管什么样的 Java 代码，首先就必须定义一个类，然后在类里面定义方法或者函数。但是在 Go 中，没有类这种概念，唯一接近的也就只有 struct，用来定义一种聚合多个字段的自定义类型，为了能够像 Java 类那样灵活的为类添加一些特定的逻辑，在 Go 也可以定义一些和类型绑定的函数 (function)，这种函数称为方法 (method)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过 <code>v.Abs()</code> 的方式调用了 Abs 方法，说明这里的 Abs 是 Vertex 这个类型才具有的方法。而定义方式就是在原来的函数定义语法中的函数名前面加上类型限制（比如 Vertex），以及对应类型的引用变量（比如 v）。</p><p>通过上面的代码，发现其实换个角度思考，函数的方法的区别不大，比如上面的 <code>Abs()</code> 方法，写成一个入参为 Vertex 类型的函数也是一样的。</p><h3 id="基于类型指针的方法"><a href="#基于类型指针的方法" class="headerlink" title="基于类型指针的方法"></a>基于类型指针的方法</h3><p>先看一段代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">    v.X = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对之前的代码，在 Abs 方法中增加了一行代码，将 v.X 修改为 10，最后的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">41.23105625617661</span></span><br><span class="line">&#123;<span class="number">30</span> <span class="number">40</span>&#125;</span><br></pre></td></tr></table></figure><p>Abs 的方法到时和预期一样，但是执行完 Abs 方法之后再次输出 v 的值，发现依然是 <code>&#123;30 40&#125;</code>，这里和 Java 就不一样了，就会发现，在 Abs 方法里面对 v 的修改只在 Abs 方法内有效，也就是说，对于 Abs 方法来讲，拿到的 Vertex 变量的是基础数据类型一样的值传递。</p><p>那么，如果要修改 Vertex 类型的变量中的属性值要如何做？</p><p>我们需要为 Vertex 的指针变量定义一个方法，这样才能通过这个方法来实际修改 Vertex 变量的属性值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    v.Scale(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">50</span><br><span class="line">&#123;30 40&#125;</span><br></pre></td></tr></table></figure><p>发现 Scale 方法的定义有点不一样，在 Vertex 前面加上了 *，这种语法，是的 Scale 就可以真正修改 Vertex 变量 v 的属性值，在 Scale 方法中的 Vertex 就是引用传递。</p><p>和前面的 Abs 方法一样，Scale 一样也可以转换成普通的函数形式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span><span class="params">(v *Vertex, f <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    Scale(&amp;v, <span class="number">10</span>)</span><br><span class="line">    fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scale 方法接受的是 Vertex 的指针类型，以 <code>*Vertex</code> 的形式表示，调用的时候传入 Vertex 类型变量的指针就行 <code>&amp;v</code>。</p><h2 id="Interface（接口）"><a href="#Interface（接口）" class="headerlink" title="Interface（接口）"></a>Interface（接口）</h2><p>Go 中的接口，不像 Java 那样还需要 <code>implements</code> 关键字来表明实现关系，在 Go 里面只要有和某个接口一样的方法，就可以认为实现了某个接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Abs() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a Abser</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">    a = f  <span class="comment">// a MyFloat implements Abser</span></span><br><span class="line">    a = &amp;v <span class="comment">// a *Vertex implements Abser</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// In the following line, v is a Vertex (not *Vertex)</span></span><br><span class="line">    <span class="comment">// and does NOT implement Abser.</span></span><br><span class="line">    a = v</span><br><span class="line"></span><br><span class="line">    fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个 <code>Abser</code> 接口，其中有一个 Abs() 方法。</p><p>MyFloat 类型有 Abs 方法，参数和返回值类型和 Abser 接口中的方法一致，那么 MyFloat 就实现了 Abser 接口。</p><p>*Vertex 也有 Abs 方法，参数和返回值类型跟 Abser 接口中的方法一致，所以 *Vertex 类型也实现了 Abser 接口，但上面的 <code>a = v</code> 这行代码依然会报错是因为，v 的类型是 Vertex 而不是 *Vertex 指针类型，这两者是有区别的。</p><blockquote><p>Go 中的接口也支持类似 Java 的多态的语法，即：变量定义成接口类型，实际赋值是具体实现的类型。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M() &#123;</span><br><span class="line">    fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i I = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">    i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    describe(i)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">42</span></span><br><span class="line">    describe(i)</span><br><span class="line"></span><br><span class="line">    i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&lt;nil&gt;, &lt;nil&gt;)</span><br><span class="line">(42, int)</span><br><span class="line">(hello, string)</span><br></pre></td></tr></table></figure><p>空接口可以转换成任何类型。</p><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">    s := i.(<span class="type">string</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    s, ok := i.(<span class="type">string</span>)</span><br><span class="line">    fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">    f, ok := i.(<span class="type">float64</span>)</span><br><span class="line">    fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">    f = i.(<span class="type">float64</span>) <span class="comment">// panic</span></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hello true                                                      </span><br><span class="line">0 false                                                         </span><br><span class="line">panic: interface conversion: interface &#123;&#125; is string, not float64</span><br></pre></td></tr></table></figure><p>语法是 <code>i.(T)</code>，其中 i 是变量名，T 是类型名称，这个语法用来判断 i 是否是 T 类型的变量，返回值有两个，第一个是 i 的输出值，第二个返回时判断结果，单独只接受第一个返回值时，如果类型判断失败会报错。</p><h4 id="通过-switch-语句匹配类型"><a href="#通过-switch-语句匹配类型" class="headerlink" title="通过 switch 语句匹配类型"></a>通过 switch 语句匹配类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do(<span class="number">21</span>)</span><br><span class="line">    do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Twice 21 is 42</span><br><span class="line">&quot;hello&quot; is 5 bytes long</span><br><span class="line">I don&#x27;t know about type bool!</span><br></pre></td></tr></table></figure><blockquote><p>Go 比较神奇的是在 switch 语句里面竟然还能类型比较，相对来说，Java 要做这样的操作时，代码就没那么好看了。</p></blockquote><h2 id="Stringers"><a href="#Stringers" class="headerlink" title="Stringers"></a>Stringers</h2><p>这是 Go 定义在 fmt 包下的接口，实现它的 String 方法，就像 Java 里面类实现 toString() 方法一样的用途。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">    z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">    fmt.Println(a, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)</span><br></pre></td></tr></table></figure><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p>goroutines 是 Go 运行时的一个轻量级线程管理器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(str <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        fmt.Println(str)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>可以看见 hello 和 world 一直是在无序输出，就好像是两个线程，一个在输出 hello，一个在输出 world。</p><h2 id="channels（管道）"><a href="#channels（管道）" class="headerlink" title="channels（管道）"></a>channels（管道）</h2><p>我的理解是，管道就像是一个线程间通信的桥梁，一段接收消息，一端发送消息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v <span class="comment">// 将 v 发送到 管道 ch</span></span><br><span class="line">v := &lt;-ch <span class="comment">// 将 ch 这个管道接收到的值赋值给变量 v</span></span><br></pre></td></tr></table></figure><p>创建管道和创建 map 一样，需要调用 make() 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>上面创建了一个收发 int 类型数据的管道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>, s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sum += i</span><br><span class="line">    &#125;</span><br><span class="line">    ch &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">go</span> sum(ch, s[:<span class="built_in">len</span>(s)/<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">go</span> sum(ch, s[<span class="built_in">len</span>(s)/<span class="number">2</span>:])</span><br><span class="line">    x, y := &lt;-ch, &lt;-ch</span><br><span class="line">    fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面简单的结合 goroutines 使用了 channel。</p><ul><li>定义 sum 方法，传入一个 int 类型的管道 ch 和一个 int 类型的 slices 变量 s，内部获取 s 所有元素的和，然后发送到 ch 管道。</li><li>main 函数中首先创建了 int 类型的管道和 int 类型的 slices，然后启动两个 go 线程，分别去求 slices 前后两半的和，最后将 ch 管道接收的数据赋值给 x、y 并输出。</li></ul><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-5 17 12</span><br></pre></td></tr></table></figure><h3 id="Buffered-Channel"><a href="#Buffered-Channel" class="headerlink" title="Buffered Channel"></a>Buffered Channel</h3><p>channel 定义的时候，支持定义管道的容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>上面定义了一个容量为 2 的管道，ch 中最多只能容纳两条消息，不然就会抛出异常。</p><h3 id="channel-遍历"><a href="#channel-遍历" class="headerlink" title="channel 遍历"></a>channel 遍历</h3><p>遍历 channle 和遍历 slices 的区别在于，slices 的 range 语法会返回元素下标和值，channel 的range 语法则只返回值。</p><h3 id="关闭-channel"><a href="#关闭-channel" class="headerlink" title="关闭 channel"></a>关闭 channel</h3><p>就像文件流一样，channel 使用完之后最好手动关闭，直接通过 close 函数关闭即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            x, y = y, x+y</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">            fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select 换选择第一个可以执行的 case 执行，如果有多个 case 都可以执行，就随机选择一个。</p><p>上面的代码，因为在 main 函数里面启动的 go 线程会循环 10 次从 c 中获取数据，当 10 循环结束后，向 quit 管道发送信息。</p><p>在 fibonacci 函数中，死循环执行 select，因为 x、y 一直有效，所以 <code>c &lt;- x</code> 一直是可执行的，所以肯定会一直执行，当 go 线程中循环结束后，不再有地方能处理 c 管道中的数据， fibonacci 中发送数据到 c 就会被阻塞，此时发现 <code>&lt;-quit</code> 可以执行，程序顺势退出。</p><h3 id="default-selection"><a href="#default-selection" class="headerlink" title="default selection"></a>default selection</h3><p>前面讲到如果 select 的执行体中多个 case 都已经就绪时会随机选择一个执行，那如果都没有就绪时，如何处理呢？</p><p>Go 给了 select 一个默认的选项，如果没有任何一个 case 可执行，就执行 default 的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tick := time.Tick(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    boom := time.After(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tick:</span><br><span class="line">            fmt.Println(<span class="string">&quot;tick.&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> &lt;-boom:</span><br><span class="line">            fmt.Println(<span class="string">&quot;BOOM!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;    .&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><blockquote><p>终于又碰见了熟悉的并发锁！！！</p></blockquote><p>我们已经知道 channels 如果进行 goroutines 之间的通信，但是如果我们不需要通信，只是需要确认在同一个时间只有一个 goroutines 在访问变量呢？</p><p>此时就需要一个互斥机制，提供这个机制的数据结构通常是 mutex。</p><p>Go 标准库提供了 <code>sync.Mutex</code> 来实现这种互斥机制，它有两个方法：</p><ul><li><p>Lock</p></li><li><p>Unlock</p></li></ul><p>接下来使用一个例子来解析它的用法。</p><blockquote><p>本例取自于 <a href="https://go.dev/tour/welcome/1">A Tour of Go</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter is safe to use concurrently.</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.Mutex</span><br><span class="line">v  <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc increments the counter for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Inc(key <span class="type">string</span>) &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="comment">// Lock so only one goroutine at a time can access the map c.v.</span></span><br><span class="line">c.v[key]++</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value returns the current value of the counter for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Value(key <span class="type">string</span>) <span class="type">int</span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="comment">// Lock so only one goroutine at a time can access the map c.v.</span></span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> c.Inc(<span class="string">&quot;somekey&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(c.Value(<span class="string">&quot;somekey&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义了一个 <code>SafeCounter</code> 类型，其中维护了一个 Mutex 锁变量 mu，和一个 map 变量 v。</p><p>SafeCounter 提供了两个方法， Inc 和 Value，因为这两个都需要考虑并发问题，所以这里的方法应该定义在 <code>*SafeCounter</code> 指针类型上，这样才能保证每个线程执行同一个 SafeCounter 变量相关逻辑是拿到的是同一个 Mutex 锁。</p><p>对于有显示 return 的方法，建议将锁释放放在 defer 语句中执行，以保证最终一定能释放锁。</p><h2 id="一些题外话"><a href="#一些题外话" class="headerlink" title="一些题外话"></a>一些题外话</h2><h3 id="设置-goproxy"><a href="#设置-goproxy" class="headerlink" title="设置 goproxy"></a>设置 goproxy</h3><p>Go 的仓库比较有意思的是，它是基于 github 实现的，使用 <code>go get</code> 指令就能从仓库中获取目标库，但是目前因为知名原因，国内无法访问，所以需要配置国内的 go 镜像地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><p>这个镜像仓库好像是七牛云提供的来着，我忘了。</p><h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><p>基本上从云端下载的包都会存放到 <code>$&#123;GOPATH&#125;/pkg</code> 目录下，这个默认是当前的用户目录下，也可以自己设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GOPATH=&lt;your path&gt;</span><br></pre></td></tr></table></figure><h3 id="GO-MODULE"><a href="#GO-MODULE" class="headerlink" title="GO MODULE"></a>GO MODULE</h3><p>开启 GO MODULE 指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GO111MODULE=on </span><br></pre></td></tr></table></figure><h3 id="和-Java-对比"><a href="#和-Java-对比" class="headerlink" title="和 Java 对比"></a>和 Java 对比</h3><p>我不知道，Go 的话，我用的不多，学它只是因为 K8s 和 Docker 用这玩意儿写的。</p><p>不过执行 <code>go install</code> 之后竟然会根据操作系统的不同生成不同的可执行文件到 <code>$&#123;GOPATH&#125;/bin</code> 目录下，这个倒是没想到的。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 知识点梳理（二）</title>
      <link href="posts/92811ec9fdf9.html"/>
      <url>posts/92811ec9fdf9.html</url>
      
        <content type="html"><![CDATA[<img src='http://image.hanelalo.cn/images/202112192246399.jpeg'/><span id="more"></span><h2 id="InnoDB-Buffer-Pool"><a href="#InnoDB-Buffer-Pool" class="headerlink" title="InnoDB Buffer Pool"></a>InnoDB Buffer Pool</h2><ul><li>InnoDB 为了提高读写性能，会申请一部分内存，划分为很多数据页，这部分内存的大小由 innodb_buffer_pool_size 参数决定，部分 MySQL 的数据文件内容会映射到这些数据页中。</li></ul><ul><li><p>如果要读取的数据不在 Buffer Pool 中，就会触发磁盘 IO 将相应的数据加载到一个新的数据页中。</p></li><li><p>对于有修改的数据页，有一个专门的线程会定时刷新一部分有改动的数据页到磁盘。</p></li><li><p>因为 Buffer Pool 有大小限制，所以当这部分内存用完之后，如果需要加载新的数据到数据页中，此时就需要通过一些缓存淘汰算法来决定替换哪些数据页来读取新的数据。</p></li></ul><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>MySQL 的 Server 层的日志。在使用 InnoDB 存储引擎的表中，会先写 Redo Log，再写 binlog。</p><p>binlog 有三种模式</p><ul><li><p>ROW（基于行复制）</p><ul><li><p>记录数据被如何修改，主从同步时，只需要在从节点进行一样的修改即可。</p></li><li><p>优点</p><ul><li>清楚记录每一条数据的修改细节，不会出现因主从差异导致的数据差异，比如 rand() 等函数。</li></ul></li><li><p>缺点</p><ul><li>每一行数据的变化都会在 binlog 中有单独记录，导致 binlog 文件比较大，导致主从复制时的 IO 压力增大。</li></ul></li></ul></li><li><p>STATEMENT（基于语句复制）</p><ul><li><p>记录会修改数据的 SQL，以及上下文信息。</p></li><li><p>优点</p><ul><li>相对 ROW 模式，日志文件更小，因为不用记录每一行数据的变化。</li></ul></li><li><p>缺点</p><ul><li>容易出现因主从差异导致的数据不一致，比如 sql 中使用了 rand() 函数的情况，两台 MySQL 服务器调用 rand() 函数的结果是可能不一样的。</li></ul></li></ul></li><li><p>MIXED（混合模式）</p><ul><li><p>根据执行语句的具体情况记录 STATEMENT 或者 ROW 形式的日志。。</p></li><li><p>优点</p><ul><li>结合了前面两种模式的优点。</li></ul></li></ul></li></ul><h3 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h3><ul><li><p>什么是 WAL 技术？</p><ul><li>Write-Ahead Logging，写前日志，即先写日志，再写数据。</li></ul></li><li><p>为什么有了 binlog 还要 Redo log？</p><ul><li><p>Redo log 是 InnoDB 存储引擎内部维护的日志，binlog 是 MySQL 的 Server 层日志，不管使用什么存储引擎都会有。</p></li><li><p>Redo log 提供了 crash safe 的保障。 </p></li></ul></li><li><p>Redo Log 缓冲区: log buffer</p><ul><li><p>对数据的每一次变动，都会有相应的一条或多条 redo Log，redo Log 和 binlog 类似，也有写缓存，InnoDB 中通过 innodb_log_buffer_size 来配置 redo log 的写入缓存大小，MySQL 5.7 默认大小是 16MB。</p></li><li><p>redo log 写入缓冲区大小固定，缓冲区满了之后会从头开始写。</p></li></ul></li><li><p>落盘时机</p><ul><li><p>log buffer 满了。log buffer 有固定的容量限制，当 log buffer 写满之后，会从头开始写，在这之前，为了避免 redo log 数据丢失，会做一次 log buffer 数据落盘，其实 MySQL 在当前 log buffer 占用 50% 容量时就会落盘。</p></li><li><p>事务提交。执行 sql 的过程中，修改数据其实是修改的 Buffer Pool 中的某一个数据页，被修改的数据页并不会立即落盘，这个过程中会产生 redo Log，因为需要 redo Log 保证 crash safe，所以在事务提交时，哪怕修改的 Buffer Pool 数据页还没有落盘，事务产生的 redo log 也必须要落盘，不然 commit 之后如果宕机了，这部分日志丢失，也就没法正确恢复数据。</p></li><li><p>服务器正常关闭。和事务提交时落盘是一样的原因。</p></li><li><p>checkpoint。redo log 落盘后的磁盘文件大小也是有限制的，虽然 redo log 磁盘文件可以有多个，这些文件写满了之后，再写入数据就会从第一个文件开始覆盖，覆盖也就意味着 redo log 的数据丢失，所以，在覆盖的时候，必须保证要覆盖的 redo log 对应的 Buffer Pool 数据页已经落盘了；极端情况下，可能会出现要覆盖的 redo log 对应的 Buffer Pool 数据页还没有落盘，此时只能阻塞住，等后台线程将数据页刷盘之后才能继续写入 redo log，也就能解释 MySQL 偶尔执行速度慢的现象。</p></li></ul></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><p>MySQL 事务并发引发的一致性问题</p><ul><li><p>脏写</p><p>事务修改了其他事务修改但未提交的数据吗，其实这个已经限制死了不会发生。</p></li><li><p>脏读</p><p>事务读取了其他事务修改但未提交的数据。</p></li><li><p>不可重复读</p><p>一个事务内，读取同一条数据两次得到的结果不一样，一般是数据被其他事务 update 过。</p></li><li><p>幻读</p><p>一个事务内，根据某些搜索条件查询两次，得到的结果不一样，一般是有其他事务 insert 或者 delete 了符合条件的数据。我的理解是，不可重复读是针对同一条数据发生了变动，更关注前后两次查询的单一数据的不一致，幻读更关注前后两次查询出的数据条数不一致。</p></li></ul></li><li><p>事务隔离级别</p><ul><li><p>读未提交</p><p>当前事务可以读取到其他事务未提交的改动。存在脏读、不可重复读、幻读问题。</p><p>实现原理：直接读取最新数据即可。</p></li><li><p>读已提交</p><p>当前事务只能读取到其他事务已经提交的改动。存在不可重复读、幻读问题。</p><p>实现原理：在执行每一条 SQL 时创建视图，所以能读到已提交的数据。</p></li><li><p>可重复读</p><p>在事务开始后，其他事务提交了对数据的 update，当前事务也读取不到这部分 update 的数据改动。存在幻读问题。</p><p>实现原理：在开启事务时，创建一个视图，整个事务执行过程中不变，所以无法读取其他事务已提交的数据。</p></li><li><p>串行化</p><p>所有事务，只能一个接一个串行执行。不存在前面讲的任何一个问题，但是性能较低。</p><p>实现原理：直接加锁。</p></li></ul><p><strong>MySQL 默认隔离级别为可重复读，Oracle 默认隔离级别为读已提交。</strong></p></li><li><p>事务启动方式</p><ul><li><p>BEGIN</p></li><li><p>START TRANSACTION，和 BEGIN 的区别是，该指令后面还可以跟参数。</p><p>参数：</p><ul><li><p>READ ONLY，开启一个只读事务，只能读数据，不能修改数据。</p></li><li><p>READ WRITE，开启一个读写事务，读写数据都可以。</p></li><li><p>WITH CONSISTENT SNAPSHOT，启动一致性读。</p></li></ul><p>START TRANSACTION 后面可以跟多个参数，用逗号分隔，但是 READ ONLY 和 READ WRITE 是设置事务读写状态的，不能放一起，都可以和 WITH CONSISTENT SNAPSHOT 组合。 </p></li></ul></li><li><p>提交事务</p><p>COMMIT</p></li><li><p>回滚事务</p><p>ROLLBACK</p></li><li><p>索引</p><p>参考 <a href="https://hanelalo.cn/2021/03/14/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9-1/">https://hanelalo.cn/2021/03/14/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9-1/</a></p><p>关于唯一性索引（包括主键索引）和普通索引，在执行 DML 时时有不同的性能的。</p><ul><li><p>如果表中有唯一性索引，执行 DML 需要先校验数据是否已经存在，此时如果要读取的数据没有加载到 Buffer Pool，还必须加载数据到数据页中。</p></li><li><p>如果是普通索引，因为没有唯一性约束，此时如果数据不在内存中，也不会加载数据到内存页，而是将改动缓存到 change buffer 中，MySQL 有单独的线程将 change buffer 的改动真正应用到数据中，这个过程叫 merge，除了这个线程之外，在后续有请求要访问修改的数据时，也会先做 merge，然后再执行。</p></li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><ul><li><p>mysqldump</p><ul><li><p>启动一个事务，拿到一致性视图，不影响其他事务执行 DML。</p></li><li><p>因为需要一致性视图，所以必须使用支持事务得存储引擎。</p></li></ul></li><li><p>FTWRL</p><ul><li><p>一般是为了数据库备份，执行 Flush table with read lock 指令，整个数据库将处于只读状态，其他 DDL 和 DML 得执行线程都会阻塞。</p></li><li><p>如果在主库上执行，在备份期间，不能更新数据，业务停摆。</p></li><li><p>如果在从库执行，备份期间无法通过 binlog 进行主从同步，造成主从延迟。</p></li><li><p>有了 mysqldump 之后还有 FTWRL 是因为 mysqldump 要求必须使用支持事务的存储引擎。</p></li><li><p>如果是为了备份，为什么不通过 set global readonly=true 的方式将数据库设置为只读之后，再进行备份？</p><ul><li><p>有些系统会读取 readonly 参数来做一些逻辑，导致这种方式影响太大。</p></li><li><p>FTWRL 在连接异常断开后，会释放全局锁，但是 readonly 参数却不会在异常断开后恢复设置。</p></li></ul></li></ul></li></ul><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><h4 id="表锁-1"><a href="#表锁-1" class="headerlink" title="表锁"></a>表锁</h4><ul><li><p>针对表加读锁或写锁，读锁不互斥，写锁互斥，同一个事务持有写锁也可以进行读操作，和 Java 中的读写锁类似。</p></li><li><p>元数据锁（MDL，Meta Data Lock）</p><p>主要是为了保证读写的正确性。不需要显示加锁，访问表的时候就会自动获取，做增删改查时获取读锁，修改表结构时获取写锁。</p></li></ul><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>InnoDB 中行锁在执行 sql 的时候才会获取，直到事务结束才会释放。</p><h4 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h4><ul><li><p>超时</p><p>超过 innodb_lock_wait_timeout 配置时间就释放资源，这里也指挥回滚当前这一条 sql，而不是整个事务，如果要超时回滚整个事务就使用 innodb_rollback_on_timeout 参数，默认为 off。</p></li><li><p>死锁回滚</p><p>设置 innodb_deadlock_detect=on，发生死锁时，会根据 innodb_lock_wait_timeout 参数，看发生死锁的哪一个事务先超时，就回滚哪一个事务，但是到底是回滚发生死锁的 SQL 语句还是整个事务，取决于 innodb_rollback_on_timeout 参数。</p></li><li><p>如何解决死锁回滚造成的大量 CPU 资源消耗？</p><p>确认业务不会出现死锁的情况下，可以关掉死锁检测，但是关掉死锁，意味着可能出现大量死锁造成的超时；控制并发度，其实就是连接数控制，如果做在客户端，一旦客户端数量增加，还是会造成大量 CPU 资源消耗吗，所以需要作为服务端，或者中间件。</p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPI 在 Java 中的应用</title>
      <link href="posts/edfa54fb78f0.html"/>
      <url>posts/edfa54fb78f0.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/image/202208141841577.png'/><span id="more"></span><h1 id="SPI-在-Java-中的应用"><a href="#SPI-在-Java-中的应用" class="headerlink" title="SPI 在 Java 中的应用"></a>SPI 在 Java 中的应用</h1><p>SPI，全称 <code>Service Provider Interface</code>，是 Java 提供的一套用于接入第三方扩展的技术。</p><h2 id="SPI-使用方式"><a href="#SPI-使用方式" class="headerlink" title="SPI 使用方式"></a>SPI 使用方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EatService</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CatServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">EatService</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CatServiceImpl</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;初始化：猫&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">EatService</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DogServiceImpl</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;初始化：狗&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;狗啃骨头&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ServiceLoader&lt;EatService&gt; serviceLoader = ServiceLoader.load(EatService.class);</span><br><span class="line">    Iterator&lt;EatService&gt; iterator = serviceLoader.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">      iterator.next().eat();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了一个 EatService 接口，提供一个 eat() 的能力，EatService 接口又有 CatServiceImpl、DogServiceImpl 2 个实现类，每个实现类都各自实现了 eat() 方法，且显示的定义了无参构造。</p><p>最后，在 main() 方法中，通过 ServiceLoader 加载了 EatService 的实现类，并遍历实现类，执行 eat() 方法。</p><p>执行 main() 方法，没有任何输出，这是为何？唯一能想到的的结论是：Java并不知道 EatService 有哪些实现类。</p><p>虽然在开发者的视角，EatService 有 2 个实现类，那 Java 在运行时怎么知道有哪些实现类呢？Java 要求在 META-INF/services 目录下面进行接口实现类的配置，配置文件名为带包路径的接口名，内容为要加载的实现类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 文件: rg.hanelalo.spi.EatService</span><br><span class="line">org.hanelalo.spi.CatServiceImpl</span><br><span class="line">org.hanelalo.spi.DogServiceImpl</span><br></pre></td></tr></table></figure><p>加上上述配置之后，再运行 main() 方法，得到如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始化：猫</span><br><span class="line">猫吃鱼</span><br><span class="line">初始化：狗</span><br><span class="line">狗啃骨头</span><br></pre></td></tr></table></figure><p>可以看见，确实和配置所预想的一样，初始化了一个 CatServiceImpl 对象并调用了 eat() 方法，又初始化了一个 DogServiceImpl 对象并调用了 eat() 方法。</p><h2 id="SPI-原理"><a href="#SPI-原理" class="headerlink" title="SPI 原理"></a>SPI 原理</h2><p>这里再次将前面遍历 EatService 实现类的代码搬过来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  ServiceLoader&lt;EatService&gt; serviceLoader = ServiceLoader.load(EatService.class);</span><br><span class="line">  Iterator&lt;EatService&gt; iterator = serviceLoader.iterator();</span><br><span class="line">  <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    iterator.next().eat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合实际场景，真正做开发的时候，更多是需要在众多实现类中找到需要的那一个，前面的例子也已经说明，每当遍历一个实现类，才会初始化一个对象出来，所以合理猜测初始化对象是在调用 iterator.eat() 时进行的，那么就需要从 ServiceLoader 提供的迭代器入手。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceLoader#iterator()</span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">            = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现核心在于 knownProviders、lookupIterator 这 2 个变量，这里先聚焦于 lookupIterator，明白其作用后，也就知道了 knownProviders 的用处。</p><h3 id="lookupIterator-hasNext"><a href="#lookupIterator-hasNext" class="headerlink" title="lookupIterator#hasNext()"></a>lookupIterator#hasNext()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (acc == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> hasNextService();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Boolean <span class="title function_">run</span><span class="params">()</span> &#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管怎样，最终都是调用了 hasNextService() 方法进行了判断，再深入查看 hasNextService() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNextService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>其中 PREFIX 常量值为 <code>META-INF/services/</code>，那么 fullName 就恰好是前面讲到的 SPI 配置文件的地址。</p></li><li><p>loader.getResource() 加载了配置文件。</p></li><li><p>遍历配置文件中的实现类配置，调用 parse 方法进行解析。</p></li><li><p>nextName 赋值。</p></li></ol><p>在 parse() 方法中仅仅只是将实现类名解析了出来。</p><p>总之，在hasNext()、hasNextService() 两个方法配合下，读取了 SPI 的配置文件，并获取到接口实现类的类名。</p><h3 id="lookupIterator-next"><a href="#lookupIterator-next" class="headerlink" title="lookupIterator#next()"></a>lookupIterator#next()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (acc == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextService();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;S&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> S <span class="title function_">run</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 hasNext() 方法类似，关注 nextService() 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> S <span class="title function_">nextService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> nextName;</span><br><span class="line">    nextName = <span class="literal">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = Class.forName(cn, <span class="literal">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">S</span> <span class="variable">p</span> <span class="operator">=</span> service.cast(c.newInstance());</span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,</span><br><span class="line">             x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先还是调用 hashNextService() 方法做了二次检查，避免开发者没吊用 hasNext() 而直接调用 next() 方法，前面讲过 hashNextService() 会给 nextName 进行赋值。</p></li><li><p>获取当前遍历的实现类名称，并将 nextName 置为空，为下次遍历做准备。</p></li><li><p>通过 Class.forName() 的方式加载实现类。</p></li><li><p>通过 class.newInstance() 的方式实例化一个实现类的对象，并尝试转换为接口类型，这里其实是一次检查是否真的是目标接口的实现类的行为。</p></li><li><p>以类名为 key，类对象为 value，放入 providers 中，并返回。</p></li></ol><h3 id="knownProviders"><a href="#knownProviders" class="headerlink" title="knownProviders"></a>knownProviders</h3><p>前面讲了 lookupIterator 的方法，发现最后都会把实现类名和类对象放进 ServiceLoader 的 providers 中，再观察 ServiceLoader.iterator() 方法发现，knownProviders 其实就是从 providers 中生成的迭代器，所以后续再调用 ServiceLoader.iterator() 时，就不用再重新加载配置文件、初始化类了。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>上一节有提到，更多时候是在众多实现类中找一个，而找的方式只能是遍历，最终会出现只使用其中一个实现类，但却初始化所有实现类的情况，这是一种资源的浪费。</p><p>像 Dubbo 针对 SPI 进行了更灵活的优化，能够按需加载，为每个实现类定义一个名称，使用时，可以直接通过名称先找到实现类名，再进行初始化，而不是每个实现了都初始化之后再判断是否是需要的实现类，具体的可翻阅 dubbo 项目 org.apache.dubbo.common.extension 包下面的源码。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（二）</title>
      <link href="posts/356e0d8d2026.html"/>
      <url>posts/356e0d8d2026.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/images/202111061317524.jpg'/><span id="more"></span><h1 id="Redis-学习笔记（二）"><a href="#Redis-学习笔记（二）" class="headerlink" title="Redis 学习笔记（二）"></a>Redis 学习笔记（二）</h1><h2 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h2><ul><li><p>String</p></li><li><p>List</p></li><li><p>Hash</p></li><li><p>Set</p></li><li><p>zset</p></li></ul><p>底层数据结构：</p><ul><li>简单动态字符串 Simple Dynamic String（SDS）</li><li>双向链表</li><li>压缩链表</li><li>哈希表</li><li>跳表</li><li>整数数组</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>从 Redis 的指令上看，上面的底层数据结构，都是实现的值的数据结构，那键和值之间如何组织？</p><p>不管是使用 Java 还是什么语言，存储键值对，想到的都是使用 Map 的数据结构，也就是哈希表。研究过 Java 中的 HashMap 就会知道，涉及到哈希表，必定要解决哈希冲突问题，以及扩容机制。</p><p>当 hash 冲突过于频繁，会导致一个 hash 槽下对应的值的链表越来越长，影响查询效率，此时需要适时做 rehash 操作，其实就是扩容。</p><p>Redis 内部维护了两张 hash 表，一开始插入数据，使用表 1，表 2 不分配空间，数据增多后，会触发 rehash：</p><ol><li>给表 2 分配更大空间，比如表 1 的两倍。</li><li>将表 1 的数据拷贝到表 2。</li><li>释放表 1 的空间。</li></ol><p>重点在于第 2 步，因为数据量大，一次性拷贝完，会阻塞 Redis 线程。为了避免该问题，Redis 使用<strong>渐进式 rehash。</strong></p><p>渐进式 rehash 的实现原理是，Redis 每次处理请求的时候，就将表 1 中从索引位置 1 开始，顺便把该位置的值的链表移动到表 2，这样就能让 Redis 能一直处理请求，同时也完成了 rehash。</p><p><img src="/img/post/progressive-rehash.webp"></p></li><li><p>为什么集合类型有好几种数据结构的实现，都很快吗？</p><p>集合操作，首先需要在全局哈希表中通过键找到对应的集合，然后对集合进行增删改查。集合的操作效率，和集合的底层数据结构以及具体的操作有关系。</p><p>集合类型的底层实现有 5 种：整数数组、双向链表、哈希表、压缩列表、跳表。整数数组和双向链表，都是顺序读写，操作效率较低，基本都是 O(N) 级别。</p><p><strong>压缩列表</strong>类似一个数组，不过在压缩列表的表头位置有三个字段：zlbytes、zltail、zllen。它们分别标识列表长度、列表偏移量、列中中 entry 个数，在表尾还有一个 zlend，表示列表结束。如果要查找压缩列表的第一个或最后一个 entry，根据表头的三个元素值，时间复杂度为 O(1)，其他元素的查找只能一个一个找，时间复杂度为 O(N)。</p><p><strong>跳表</strong>是在有序链表基础上增加了层层索引，通过索引跳转，快速定位。</p><p><img src="/img/post/skip-list.webp" alt="skip list"></p><p>以上图为例，普通链表要查询 100 这个元素，只能一个一个遍历 9 次，才能找到 100，如果是跳表，有一级索引，只需要查询 4 次，如果有二级索引，只需要查询 3 次。跳表的查询复杂度为 O(logN)。</p></li><li><p>简单动态字符串是什么？</p><p>简单动态字符串，其实就是在实现 Redis 时，Redis 作者自己定义的一个字符串数据结构，里面包含了字符串的长度，因为有专门的属性表示字符串长度，所以在操作字符串的时候，不用在处理 C 语言字符串以 <code>\&#39;0&#39;</code> 结尾的情况。</p></li></ul><h2 id="为什么-Redis-单线程也能这么快？"><a href="#为什么-Redis-单线程也能这么快？" class="headerlink" title="为什么 Redis 单线程也能这么快？"></a>为什么 Redis 单线程也能这么快？</h2><ul><li><p>Redis 的操作基本都在内存中，并且选用的都是一些比较高效的数据结构，比如哈希表、跳表。</p></li><li><p>在网络 IO 上采用多路复用机制。</p><p>Linux 中 IO 多路复用机制指的是一个线程处理多个 IO 流，允许内核中同时存在多个监听套接字和已连接套接字，内核会监听这些套接字上的连接请求或者数据请求，一旦有请求到达就交给 Redis 处理，从而实现了 Redis 一个线程处理多个 IO 的效果。</p></li></ul><h2 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h2><p>在 MySQL 中，有写前日志的概念，先记录变动日志，再写数据，方便故障恢复。但是 Redis 不一样，Redis 使用的是写后日志，也就是先执行命令，再记录日志。</p><h3 id="为什么使用的是写后日志？"><a href="#为什么使用的是写后日志？" class="headerlink" title="为什么使用的是写后日志？"></a>为什么使用的是写后日志？</h3><ul><li>redis 记录 AOF 的方式决定，以下面的 <code>set testkey testvalue</code> 为例， <code>*3</code> 表示这个命令有 3 个部分，<code>$3</code> 表示当前部分有 3 个字节，也就是 <code>set</code>。为了避免额外开销，记录 AOF 日志时并没有做语法检查，如果 AOF 是写前日志，那 AOF 中很可能就会存在执行错误的命名，所以先执行命令，再记录，能保证 AOF 文件中记录的肯定是正确的命令。</li></ul><p><img src="/img/post/redisc-cmd-to-aof.webp"></p><ul><li>执行效率问题，先执行命令，再写入 AOF 日志，不会阻碍当前命令的写入操作。</li></ul><h3 id="存在的问题？"><a href="#存在的问题？" class="headerlink" title="存在的问题？"></a>存在的问题？</h3><ul><li>如果 Redis 执行完命令之后，还没来得及写入 AOF 日志就宕机了，怎么办？</li><li>AOF 文件写入也是在主线程中执行，也就是通常情况下，必须等当前命令的 AOF 日志写完，才能执行下一条指令，如果写入 AOF 日志时，磁盘压力较大，那么后续的命令执行都会被阻塞。</li></ul><p>这两个问题，都和 AOF 日志写入时机有关。</p><p>Redis 提供了三种写 AOF 的策略，通过 appendfsyc 配置：</p><ul><li>Always，同步写回，每条指令执行完之后，立马同步将日志写回磁盘。</li><li>Everysec，每秒写回，每个命令执行完之后，只是先把日志写到 AOF 文件的缓冲区，每隔一秒把缓冲区内容刷新到磁盘。</li><li>No，由操作系统控制写回磁盘时机，每次执行命令之后，只把日志写道 AOF 日志的缓冲区，具体的写回磁盘时间由操作系统决定。</li></ul><p>这三种策略，从上到下，性能越来越好，但是相应的对丢数据的情况也越来越不友好。</p><p>Always 基本能做到不丢数据，但是因为是同步写回磁盘才算是执行完成，所以命令的执行效率比较低；Everysec 的执行效率有所提升，但是因为数据是每隔一秒写入一次磁盘，所以最多可能会丢 1 秒内的数据；No 是性能最好的，因为缓存写入磁盘的时机交给了操作系统，但同时，如果在缓存还没有刷到磁盘时就宕机了，那么丢失的数据可能就相当多了。</p><p><img src="/img/post/aof-strategy-comparative.webp"></p><h3 id="AOF-文件越来越大，怎么办？"><a href="#AOF-文件越来越大，怎么办？" class="headerlink" title="AOF 文件越来越大，怎么办？"></a>AOF 文件越来越大，怎么办？</h3><p>当 Redis 运行一段时间后，执行的命令越累越多，AOF 文件的体积也越来越大，逐渐的就会影响日志的写入性能。</p><p>针对这个问题，Redis 提供了 AOF 重写机制来解决。</p><p>举个例子，在 Redis 执行了以下指令后，AOF 文件中记录了两条命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> testkey testval1</span><br><span class="line"><span class="built_in">set</span> testkey testval2</span><br></pre></td></tr></table></figure><p>在执行了 AOF 重写后的 AOF 文件中记录的命令翻译过来，就只有<code>set testkey testval2</code>，所以可以把 AOF 重写理解为将多条命令融合为一条命令。</p><h3 id="AOF-重写会阻塞吗？"><a href="#AOF-重写会阻塞吗？" class="headerlink" title="AOF 重写会阻塞吗？"></a>AOF 重写会阻塞吗？</h3><p>不会。执行 AOF 重写的是后台子进程 bgrewriteaof。</p><p>每次执行重写时，都会从主进程 fork 一个 bgrewritwaof 子进程，主进程中最新的内存数据也会拷贝一份给 bgrewriteaof 子进程，然后 bgrewriteaof 子进程就可以在不阻塞主线程情况下，逐一把拷贝的数据写成 AOF 重写日志。</p><p>此时主进程依然在处理请求，依然会将日志写道原来的 AOF 日志文件的缓冲区，不同的是，此时因为后台子进程在进行重写操作，所以此时不仅要将日志写到原来的 AOF 日志缓冲区，还要写到 AOF 重写日志的缓冲区，等 bgrewriteaof 执行完成后，将重写日志缓冲区的内容也写入到新的 AOF 文件中，就完成了 AOF 重写操作。</p><p><img src="/img/post/aof-rewrite.webp"></p><h2 id="RDB-内存快照"><a href="#RDB-内存快照" class="headerlink" title="RDB 内存快照"></a>RDB 内存快照</h2><p>RDB 是 Redis 在某一个时刻的内存快照文件，使用 RDB 恢复数据的时候，因为 RDB 文件是内存快照，所以可以直接读进内存中，但是 AOF 因为记录的是指令，需要一条一条执行才可以。</p><p>所以从速度上来讲，RDB 肯定是比 AOF 要快很多的。</p><h3 id="那么-RDB-是如何实现的？"><a href="#那么-RDB-是如何实现的？" class="headerlink" title="那么 RDB 是如何实现的？"></a>那么 RDB 是如何实现的？</h3><p>Redis 提供了两个指令来进行 RDB 操作，分别是 save 和 bgsave。save 指令会在主进程中创建 RDB 文件，会阻塞主进程，bgsave 是一个专门用来写 RDB 文件的子进程，避免了生成 RDB 文件时阻塞主进程的情况。bgsave 也是 Redis 生成 RDB 文件的默认方式。</p><p>那么，bgsave 子进程在生成 RDB 文件的过程中，主进程中是否可以修改内存中的数据？</p><p>如果 bgsave 执行过程中不能对内存中的数据进行修改，那其实和 save 指令就没有多大差别了，所以 bgsave 执行过程中其实是可以修改内存中的数据的。</p><p>在执行 bgsave 时，采用操作系统的写时复制 (Copy On Write) 技术，主进程和子进程共享内存空间，如果主进程要修改内存中的某项数据，Redis 会提供这一块数据的副本，主进程在内存副本上修改，这样就不会影响到 RDB 数据的准确性。</p><p><img src="/img/post/redis-bgsave.jpg"></p><p>简单来讲，bgsave 子进程是从主进程 fork 而来，和主进程共享了内存区域，RDB 文件记录的就是内存区域中的数据快照。如果在生成 RDB 文件过程中主进程要修改内存中的数据，为了不影响 RDB 文件的数据准确性，实际修改的是数据的副本。</p><h3 id="什么时候做-RDB-合适？"><a href="#什么时候做-RDB-合适？" class="headerlink" title="什么时候做 RDB 合适？"></a>什么时候做 RDB 合适？</h3><p>RDB 和 AOF 不同，比较吃资源，每次 RDB 文件的写入都会有磁盘的 IO，如果频繁的进行 RDB 文件的生成，磁盘 IO 来的性能问题必能十分明显。但是如果两次 RDB 间隔时间过长，一旦服务器宕机，丢失的数据必定会变多，两次 RDB 间隔时间太短的话，就不得不考虑磁盘 IO 带来的性能问题。</p><p>在 Redis 4.0 开始，提出了一种 AOF 和 RDB 混用的解决方案。</p><h3 id="RDB-和-AOF-混用"><a href="#RDB-和-AOF-混用" class="headerlink" title="RDB 和 AOF 混用"></a>RDB 和 AOF 混用</h3><p>举个例子就是，加入两次 RDB 的时间间隔为 t，在 T1 时刻进行了第一次 RDB，那么在 T1 到 T1+t 这段时间内的数据，将由 AOF 日志记录，这样就比单纯依靠 RDB 进行数据恢复带来的风险要低得多。</p><h2 id="主从数据同步"><a href="#主从数据同步" class="headerlink" title="主从数据同步"></a>主从数据同步</h2><p>在现代的分布式系统中，中间件一般的偶不会是单体部署，因为如果是单体部署，实例一旦挂了，可能会导致整个系统的瘫痪，所以在分布式环境下，Redis 也考虑到了高可用这一点，具体做法主要是一份数据多个副本，一个实例宕机了不要紧，另一个实例上还有全量的数据副本，Redis 依然可以继续提供服务。</p><p>Redis 的主从架构中，主从节点均可处理读操作，写操作均由主节点处理，然后讲数据同步给从节点。</p><p><img src="/img/post/redis-master-slave.webp"></p><h3 id="Redis-主从节点的第一次数据同步"><a href="#Redis-主从节点的第一次数据同步" class="headerlink" title="Redis 主从节点的第一次数据同步"></a>Redis 主从节点的第一次数据同步</h3><p>执行 <code>replicaof &lt;ip&gt; &lt;port&gt;</code> 就可以建立主从关系，然后数据同步会分为三个阶段：</p><ol><li><p>和主库建立连接，为全量复制做准备。</p><p>从库向主库发送一个 psync 指令，表示要进行数据同步，指令参数包括主库的 runID 和复制进度 offset。第一次复制的时候，从库并不知道主库的 runID，所以改参数为 ? ，offset 此时设置为 -1，表示要进行全量复制。</p><p>主库收到从库的 psync 指令后，会使用 FULLRESYNC 命令响应，同时也会带上主库 runID 和主库的写入偏移量 offset 两个参数，FULLRESYNC 表示这是一次全量复制。</p></li><li><p>主库将所有数据同步给从库，从库收到后，本地完成数据加载。</p><p>第一次全量复制以来的是 RDB 文件。因为同样的数据量，RDB 是内存数据直接存储的二进制文件，AOF 是指令集和，文件大小上，RDB 还是要小一点的，数据传输上肯 RDB 更快，而且从库收到后做数据加载的时候，直接将 RDB 文件读入内存肯定比执行 AOF 文件快很多。</p><p>从库接收到主库发送的 RDB 文件后，会先清空本地的数据库，然后再加载 RDB 文件。在传输 RDB 文件过程中，主库依然会处理请求，这个时候如果发生数据改动， Redis 会将数据变动写入 replication buffer，专门用来记录主从同步期间发生的改动。</p></li><li><p>将第二阶段收到的新命令同步给从库</p><p>当 RDB 文件发送完成后，将 replication buffer 中的数据变动发送给从库，从库在执行一遍，就实现了数据同步。</p></li></ol><h3 id="从库太多，如何分担主库复制压力？"><a href="#从库太多，如何分担主库复制压力？" class="headerlink" title="从库太多，如何分担主库复制压力？"></a>从库太多，如何分担主库复制压力？</h3><p>这里的问题在于，从库很多的情况下，如果都直接从主库进行全量复制，主库会频繁的 fork 子进程，这个过程是会阻塞主进程的，要是频繁发生，肯定会影响 Redsi 的性能，所以就有了“主-从-从”的模式，其实就是从库和从库建立主从关系。</p><p><img src="/img/post/master-slave-slave.jpg"></p><h3 id="主从断连了怎么办？"><a href="#主从断连了怎么办？" class="headerlink" title="主从断连了怎么办？"></a>主从断连了怎么办？</h3><p>在主从进行第一次数据同步后，并没有断开网络连接，而是一直保持着连接，也就是<strong>基于长连接的命令传播</strong>，那如果主从断开连接后怎么处理？</p><p>在 Redis 2.8 之前，断开重连后，会直接进行一次全量复制，其实比较浪费资源。</p><p>Redis 2.8 开始使用的是增量复制，增量复制其实就是把断连期间的所有改动同步给从库。</p><h3 id="如何实现增量复制？"><a href="#如何实现增量复制？" class="headerlink" title="如何实现增量复制？"></a>如何实现增量复制？</h3><p>增量复制主要通过 repl_backlog_buffer 实现，这是一个环形缓冲区，上面有两个偏移量，一个是主库的写入偏移量，一个是从库的同步偏移量，最开始的时候，两个偏移量在同一个位置，当主库不断处理请求，主库偏移量 master_repl_offset 逐渐变大，主从同步开始后，从库的同步偏移量 slave_repl_offset 也逐渐变大，正常情况下这两个偏移量应该是差不多的。</p><p><img src="/img/post/repl_backlog_buffer.jpg"></p><p>当主从连接断开后，master_repl_offset 依然逐渐增大，但是 slave_repl_offset 不变了，master_repl_offset 和 slave_repl_offset 逐渐拉开距离，当重新建立连接后，只需要把 master_repl_offset 和 slave_repl_offset 之间的操作同步给从库即可。</p><p>以上便是 repl_backloh_buffer 的基本操作，但是，它是一个环形缓存，当断开连接足够长的时候，会出现 master_repl_offset 逐渐覆盖 slave_repl_offset，就像大学跑 5000 米的时候，体力好的同学会超圈一样，这样的话， repl_backlog_buffer 就不能支持重连之后的主从同步了。</p><p>针对上面这种 master_repl_offset 覆盖 slave_repl_offset 的情况，首先需要考虑给足空间，尽量避免这种“超圈”现象，此时可以通过 repl_backlog_size 这个参数来调节 repl_backlog_buffer 的大小，这个参数和所需缓冲空间大小有关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缓冲空间大小 = 主库写入速度 * 操作大小 - 主从网络传输速度 * 操作大小</span><br></pre></td></tr></table></figure><p>在实际的环境中，考虑一些突发情况，可以直接将 repl_backlog_size 设置为缓冲空间大小的 2 倍。</p><p>需要注意的是，不管怎样设置，极端情况下，还是可能会出现因为这种“超圈”现象引起的主从不一致，这个时候要是主从重新建立连接，会选择进行全量复制。</p><h2 id="哨兵集群原理"><a href="#哨兵集群原理" class="headerlink" title="哨兵集群原理"></a>哨兵集群原理</h2><p>在主从模式下，如果从库挂了，那客户端可以连接到主库或者其他的从库上进行读写，但是如果是主库挂了，因为写请求都是由主库进行处理，这个时候整个系统基本上也就基本停摆了。</p><p>当主库挂了之后，为了整个系统能正常运行，需要一种机制，保证集群中依然有正常的主从关系，比如尝试选一个从库做为新的主库，此时又会面临三个问题：</p><ol><li>主库真的挂了吗？</li><li>选择那个从库作为新的主库？</li><li>如何通知其他从库以及客户端，集群的主库发生了变更？</li></ol><p>哨兵机制，就是为了解决主从故障切换的这三个问题。</p><p>从以上三个问题就可以知道，哨兵集群的作用就是监控、选主、通知。</p><p>所谓哨兵，其实就是一个运行在特殊模式下的 Redis 进程。</p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>监控，其实就是哨兵进程在运行时定时给所有主库和从库发送 <code>ping</code> 命令来检测实例是否还在运行中。如果从库没有在指定时间内响应，哨兵就判定改从库下线，如果主库在指定时间内没有响应，哨兵就判定该主库下线，然后开始进行<strong>自动切换主库</strong>操作。</p><p>这里的主要是判定 Redis 节点是否处于下线状态。</p><p>哨兵对于主库判定的下线状态有两种，<strong>主观下线</strong>和<strong>客观下线</strong>。</p><p>主观下线，就是哨兵在指定时间内没有收到主库对 ping 命令的响应，此时就可以判断为主观下线。如果是从库的话，直接标记为主观下线就可以真的下线了，因为从库的下线其实影响不大。</p><p>哨兵一般都是集群方式部署，所以当哨兵集群中有一定数量的哨兵都认为主库是主观下线时，可以判定为主库客观下线，当主库被判定为客观下线后，才会进行主从自动切换。</p><h3 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h3><p>选择新的主库，首先得保证新的主库的网络环境是可靠的，根据每个从库的历史网络环境统计进行筛选，Redis 哨兵有一项配置 down-after-milliseconds，表示主从断开连接最大超时时间，如果主库和从库在 down-after-milliseconds 内都没有连接上，就认为主从断开连接。如果发生断连次数超过 10 次，那说明网络环境实在不乐观，这样的从库肯定就直接筛选掉，不具备作为新主库的资质。</p><p>在筛选掉一部分从库之后，在剩下的从库中，哨兵按照从库优先级、复制进度、从库 ID 三个维度进行打分，最终谁得分最高，谁就是新的主库，这三个维度不是并列，而是有优先级关系，如果有通过优先级打分的过程中出现了一个从库的优先级最高，那它就是新的主库，不用再通过复制进度和 ID 进行打分。</p><h4 id="使用从库优先级选主"><a href="#使用从库优先级选主" class="headerlink" title="使用从库优先级选主"></a>使用从库优先级选主</h4><p>通过 slave-priority 设置从库优先级，比如其中一个从库的性能更好一点，就可以给这个从库的优先级设置高一点。</p><p>如果通过从库优先级没能选出新的主库，就会通过复制进度进行第二轮选主。</p><h4 id="通过复制进度选主"><a href="#通过复制进度选主" class="headerlink" title="通过复制进度选主"></a>通过复制进度选主</h4><p>在前面讲过主从同步的时候有一个 repl_backlog_buffer 环形缓冲区，里面有 master_repl_offset 和 slave_repl_offset 两个偏移量，那么此时哪一个从库的 slave_repl_offset 更接近 master_repl_offset，谁就是新的主库。</p><p>如果通过复制进度依然没能选主新的主库，就进行第三轮选主。</p><h4 id="通过从库-id-选主"><a href="#通过从库-id-选主" class="headerlink" title="通过从库 id 选主"></a>通过从库 id 选主</h4><p>每个从库都有一个自己的 id，id 最小的从库，会被选为新的主库。</p><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>哨兵将新的主库信息发送给客户端和从库即可。</p><h3 id="哨兵集群的高可用"><a href="#哨兵集群的高可用" class="headerlink" title="哨兵集群的高可用"></a>哨兵集群的高可用</h3><p>哨兵与哨兵之间建立连接，最开始是通过主库中的 <code>__sentinel__:hello</code> 频道发布自己的 ip 和端口，这样其他的哨兵只要订阅这个频道就能得知 ip 和端口，进而建立连接。</p><p>哨兵和从库建立连接，首先向主库发送 info 指令，主库返回从库的地址信息，哨兵就可以和从库建立连接。</p><h4 id="哪个哨兵节点执行主从切换？"><a href="#哪个哨兵节点执行主从切换？" class="headerlink" title="哪个哨兵节点执行主从切换？"></a>哪个哨兵节点执行主从切换？</h4><ul><li><p>投票表决主库是否客观下线</p><p>哨兵节点判断主库主观下线后，向集群中其他的哨兵节点发送 is-master-down-by-addr 命令，其他哨兵节点给出回应。当获得足够的票数后，就将主库标记为客观下线，这里所需要的赞成票数通过哨兵配置文件中的 quorum 配置。如果有 5 个哨兵节点，quorum 配置为 3，表示需要有 3 个哨兵节点认为主观下线，主库才会标记为客观下线。</p></li><li><p>竞争主从切换操作权</p><p>如果一个哨兵节点确定为执行主从切换的节点，那么它在竞争过程中必须满足两个条件：</p><ol><li>获取半数哨兵的赞成票</li><li>票数大于 quorum 配置值</li></ol><p>如果一个集群只有 2 个哨兵节点，那么必须获得两个赞成票才能执行主从切换，这就导致如果有一个节点挂了，就无法进行主从切换，所以哨兵集群一般都有 3 个节点。</p></li></ul><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="为什么使用切片集群？"><a href="#为什么使用切片集群？" class="headerlink" title="为什么使用切片集群？"></a>为什么使用切片集群？</h3><p>当单机数据量越来越大，每次进行 RDB 的时候，fork 子进程用的时间会越来越久，进而造成了主进程的阻塞，影响性能。</p><h3 id="使用切片集群，需要解决什么问题？"><a href="#使用切片集群，需要解决什么问题？" class="headerlink" title="使用切片集群，需要解决什么问题？"></a>使用切片集群，需要解决什么问题？</h3><ul><li><p>怎么切片？</p><p>Redis 3.0 之前没有官方解决方案，3.0 开始有个 Redis Cluster 解决方案，将整个集群中的数据分为了 16384 个哈希槽，Redis 每个键值对的 key 都会对应到这个 16384 个槽中的某一个。Redis Cluster 会默认均分这个 16384 个槽，比如集群有 N 个节点，那么每个节点上的哈希槽个数为 16384/N 个。</p><p>除了默认均分之外，考虑到不同节点的配置不同，提供了 cluster addslots 命令手动分配，需要注意的是，必须将 16384 个哈希槽分配完，Redis 才能正常启动。 </p></li><li><p>客户端如何定位自己要访问的数据在哪里？</p><p>集群中的节点之间在建立连接的时候，会将自己的哈希槽分布情况发送给对方，这样每个实例都能知道哈希槽的分布情况，当客户端连接到某个实例时，也能知道所有数据的分布情况。</p><p>但是集群中的节点存在上、下线操作，并非一成不变。集群中有节点的增减时，需要重新分配哈希槽，为了负载均衡，Redis 会把所有数据都重新分布一遍。</p><p>实例之间因为建立了连接，这些变化时刻可以知道，但是客户端要如何感知这些变化？</p><p>Redis 提供了一种重定向机制，当客户端访问的数据不在本实例上时，返回一个 MOVED 响应信息，里面包含目标数据坐在的哈希槽以及所在的服务器地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET hello:key</span><br><span class="line">(error) MOVED 13320 172.16.19.5:6379</span><br></pre></td></tr></table></figure><p>客户端接收到 MOVED 指令后，重新发送请求到新的节点上即可。</p><p>上面是客户端发送请求时数据同步已经完成的情况，但是更多的是数据还没有传输完成的时候，此时，会返回一个 ASK 错误码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET hello:key</span><br><span class="line">(error) ASK 13320 172.16.19.5:6379</span><br></pre></td></tr></table></figure><p>客户端收到 ASK 错误后，向新的节点发送 ASKING 命令表示允许新节点处理接下来的请求。</p><p>MOVED 和 ASK 重要的区别在于，MOVED 会更新客户端本地的槽和 Redis 实例对应关系的缓存，但是 ASK 不会，也就是说当收到一次 ASK 错误后，正常情况下后面还会有一次 MOVED，之后本地的缓存才会更新。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列概述</title>
      <link href="posts/8b6c7d201b88.html"/>
      <url>posts/8b6c7d201b88.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/images/202111061320053.png'/><span id="more"></span><h1 id="消息队列概述"><a href="#消息队列概述" class="headerlink" title="消息队列概述"></a>消息队列概述</h1><blockquote><p>本文是学习极客时间《消息队列高手课》专栏的笔记，文中有绿色方块的图，也是取自该专栏。</p></blockquote><h2 id="为什么需要消息队列？"><a href="#为什么需要消息队列？" class="headerlink" title="为什么需要消息队列？"></a>为什么需要消息队列？</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p> 以秒杀系统为例，一般需要风险控制、锁定库存、生成订单、短信通知、更新统计数据这 5 个步骤，仔细想想，其实只要风险控制和锁定库存这两步确定了，后面几步并不需要急着立马完成，这种场景下就可以在通过了风险控制并锁定了库存之后，发送消息到消息中间件，同时返回响应信息给用户，而剩下的 3 步就可以自行消费消息中间件中的消息，要是这 3 步的关系不大，甚至能直接并发进行这三步。</p><p> <img src="/img/post/second-kill.webp"></p><p> 这样做的<strong>好处</strong>是：</p><ul><li><p>可以更快的返回结果。</p></li><li><p>减少用户等待时间，实现了业务步骤上的并发，提高了系统性能。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>在高并发场景下，很多时候都会出现大量请求直接讲服务器打垮的情况，同样是秒杀系统，为了避免这种情况，在服务网关和后端服务之间加入消息队列，当有请求过来时，讲请求作为消息发送到消息队列，后端服务根据自身的情况进行消费。</p><p><img src="/img/post/second-kill-2.webp"></p><p>这样做的<strong>好处</strong>是：</p></li><li><p>超时的请求可以直接丢弃，APP 直接做秒杀失败处理。</p></li><li><p>运维可以随时增加秒杀服务实例，不需要改动系统其他部分。</p><p>其实就是<strong>流量削峰</strong>了。</p><p>但是同样也是有<strong>坏处</strong>的：</p></li><li><p>系统层面增加了调用环节，响应时间必定变长。</p></li><li><p>上下游系统都变为异步调用，增加了系统复杂度。</p><p>上面的解决方案其实只是为了做到流量控制，如果能够预估到秒杀系统的处理能力，这时就可以实现一个令牌桶算法来控制请求的并发度以及最终秒杀成功的数量。</p><p>令牌桶算法：在消息中间件中设置一个匀速生成令牌的消息队列，每个请求到达之后，先从令牌队列中获取一个令牌，获取到了就可以继续往下走，获取不到就直接秒杀失败。</p><p><img src="/img/post/token-bucket-algorithm.webp"></p><p>这种解决方案的前提是，能够<strong>预估后端服务的请求处理能力，才能合理设置生成令牌的速度，不然有可能直接将后端服务打垮。</strong></p><h3 id="服务解耦"><a href="#服务解耦" class="headerlink" title="服务解耦"></a>服务解耦</h3><p>在电商业务中比较常见的情况是，当一个订单创建时，可能会发生以下事件：</p></li></ul><ol><li><p>支付系统发起支付流程</p></li><li><p>风控审核订单合法性</p></li><li><p>客服系统发送短信通知</p></li><li><p>更新统计数据</p></li><li><p>。。。。。。。</p><p>这个时候，订单服务的开发人员头大了，创建一个订单，为了对接下游的系统，还得专门为每个下游系统提供接口，不只是考虑订单创建的情况下，甚至什么场景还需要调用哪个下游系统也得在代码里体现出来，万一变了，还得立马改代码重新上线。</p><p>如果引入消息队列，订单服务只需要在生成了订单后发送一个事件到消息队列，下游系统谁关系这个事件，谁就自行消费，订单服务不管这些。</p><p>所以这个时候引入消息队列的<strong>好处</strong>是：</p></li><li><p>上下游系统之间因为没有直接的接口调用，断开了 api 耦合，不会出现一个业务调用链上一个微服务的失败导致整个请求处理失败。下游系统如果挂了，因为消息还在，所以下游系统恢复之后可以继续消费消息。</p><blockquote><p>一开始我一直没明白这里所谓解耦到底是怎么回事，带到我们公司正在做的微服务里面发现好像没什么用处。知道今天我才知道为什么，以为按照微服务的架构来讲，每个服务都需要数据自治，相当于订单服务在其他的服务中应该是有冗余一些必要的数据的，而我司现在做的微服务并没有做到这一点，所以也就不存在用 MQ 来解耦这个场景。</p></blockquote></li></ol><h2 id="消息队列引入的问题"><a href="#消息队列引入的问题" class="headerlink" title="消息队列引入的问题"></a>消息队列引入的问题</h2><p> 不管是什么技术，肯定不会是十分完美的，只可能是在特定场景下解决特定的问题，所以，引入消息队列，虽然有诸多有点，但是相应的也会带来一些问题。</p><h3 id="延迟问题"><a href="#延迟问题" class="headerlink" title="延迟问题"></a>延迟问题</h3><p> 因为在架构上，调用链上多出了一个甚至多个节点，有些场景下必然会导致处理的事件相应的会增加，比如前面讲到的令牌桶算法，每次请求都必须多一步获取令牌。</p><h3 id="增加系统复杂度"><a href="#增加系统复杂度" class="headerlink" title="增加系统复杂度"></a>增加系统复杂度</h3><p> 每引入一种中间件，系统的复杂度和运维的门槛也必定会升高。</p><h3 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h3><p> 因为服务间的通信不再是 api 直接调用，所以并不能完全保证用户接收到响应的时候后端所有的消息消费逻辑都已经完成。幽默的说法是，订单创建了，但是又没完全创建好。</p><h2 id="消息中间件选型"><a href="#消息中间件选型" class="headerlink" title="消息中间件选型"></a>消息中间件选型</h2><p> 消息中间件选型，必要的 3 点是：</p><ul><li><p>必须是开源产品</p><p>大部分公司并没有完全自研的能力，只能选择开源，遇见问题也有开源社区和各种平台提供帮助，关键是实在逼不得已，可以改源码解决问题，而不是等作者发布下一个版本。</p></li><li><p>近年比较流行，社区有一定活跃度</p><p>如果使用比较冷门的产品，遇见问题的时候，在网上寻求解决方案的成本会增高，甚至不一定能解决，也因此，对于社区的活跃度也有一定要求，而且流行的产品一般 bug 也比较少，遇见的基本也都有解决方案。</p></li><li><p>必须包含下面 3 个特性：</p><ol><li>消息可靠性，确保不丢消息。</li><li>Cluster，支持集群部署，确保不会因为一个节点宕机导致服务不可用或者丢失消息。</li><li>性能，其实都用到了消息队列了，肯定对性能有要求的，不然还用它干啥。</li></ol><h3 id="常见开源消息中间件"><a href="#常见开源消息中间件" class="headerlink" title="常见开源消息中间件"></a>常见开源消息中间件</h3></li></ul><ol><li><p>RabbitMQ</p><p><strong>优点</strong>：</p><ul><li>轻量级，易部署。它是所有消息队列中客户端支持的语言最多的一个，如果使用的语言比较冷门，可以考虑。</li><li>RabbitMQ 在生产者和队列之间还增加了一个 Exchange 模块，根据配置的路由规则将消息分发到不同的队列，比较灵活。</li></ul><p><strong>缺点</strong>：</p><ul><li>开发的语言 erlang 冷门且学习成本高，和 Java 不可同日而语，如果遇见问题，又不懂 erlang，那就只能求助社区了。</li><li>性能普通，根据硬件配置不同，每秒能处理几万到十几万条消息，对于性能要求很高的，建议不考虑 RabbitMQ。</li><li>消息堆积不友好，设计理念上认为消息堆积本身就是一件不好的事，应当尽量避免，当消息堆积时，性能会急剧下降。</li></ul></li><li><p>RocketMQ</p><p>最开始由 Alibaba 开源，后捐赠给了 Apache 基金会。</p><p><strong>优点</strong>：</p><ul><li>使用 Java 语言开发，开源，方便做针对性的二次开发。</li><li>对响应时延方面做了优化，大多数情况下能做到毫秒级响应，性能上比 RabbitMQ 高了一个数量级，每秒可以处理几十万条消息。</li><li>近几年得益于 Alibaba 的影响力，社区十分活跃。</li></ul><p><strong>缺点</strong>：</p><ul><li>因为是国产开源的软件，所以和周边生态的集成上可能相对于其他消息中间件略逊一筹，不过也一直在补足。</li></ul></li><li><p>Kafka</p><p>Kafka 最初的设计目的是为了处理日志，因为日志这种东西，就算偶尔丢失一两条影响不大，所以最开始的 Kafka 为了极致性能，牺牲了一些东西，在丢消息的处理上比较欠缺，甚至也不支持集群。<strong>但是</strong>后来 Kafka 慢慢的又将这些缺点补齐了。</p><p>Kafka 使用 Java 和 Scala 语言开发，大量使用异步和批量的思想，所以它的性能是最好的，但是和 RocketMQ 也还在一个量级，但是，因为使用了批量的思想，如果单位时间内消息的数量不多时，时延反而会比较高，因为需要等生产者累计了某个数量的消息之后一起压缩再发送到 Broker 端。</p><p><strong>优点</strong>：</p><ul><li>高性能，比 RocketMQ 性能好，但依然在每秒几十万的量级。</li><li>使用 Java 和 Scala 开发，方便二次开发和问题排查。</li><li>社区活跃，这时活跃在国内外的开源产品，大数据和流计算领域基本都选它。</li></ul><p><strong>缺点</strong>：</p><ul><li>要是生产者每秒的消息比较少，因为 Kafka 使用了批量处理的思想，可能反而会导致时延变长，所以 Kafka 不太适合在线业务场景。</li></ul><p>总结一下：</p><blockquote><p>如果说，消息队列并不是你将要构建系统的主角之一，你对消息队列功能和性能都没有很高的要求，只需要一个<strong>开箱即用易于维护</strong>的产品，我建议你使用 RabbitMQ。</p><p>如果你的系统使用消息队列主要场景是<strong>处理在线业务</strong>，比如在交易系统中用消息队列传递订单，那 RocketMQ 的<strong>低延迟和金融级的稳定性</strong>是你需要的。</p><p>如果你需要处理<strong>海量的消息</strong>，像收集日志、监控信息或是前端的埋点这类数据，或是你的应用场景大量使用了<strong>大数据、流计算</strong>相关的开源产品，那 Kafka 是最适合你的消息队列。</p></blockquote><h2 id="主题和队列"><a href="#主题和队列" class="headerlink" title="主题和队列"></a>主题和队列</h2><h3 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h3><p>早期的消息中间件的设计模型，就像“队列”这种数据结构一样，先入先出，由消息生产者入队，消息消费者出队，所以使用这种模型设计的消息中间件里面，<strong>队列</strong>指的就是用来装消息的“队列”数据结构。但是问题在于，按照“队列”数据结构的特性来设计，那么每条消息就只能被一个消费者消费，如果由多个消费者想消费同一条消息，此时，因为第一个消费者让消息出队了，后面的消费者就没消息可以消费。比如创建订单时，发送的“订单创建”的事件就是一条消息，加入这个时候风控服务和支付服务都要消费者条消息，但是因为是按照“队列”数据结构设计，就会导致只有其中一个服务消费成功。</p><p><img src="/img/post/queue-model.webp"></p><p>所以，在“队列”数据结构的基础上，可以选择为每个消费者建立一个队列，没次发送消息，其实就是每个“队列”都进行一次入队操作。这种做法，本质上就是在消息中间件中将消息复制很多个副本，而且，消息生产者还必须知道有哪些消费者，因为这样才知道要发送到哪些队列中。讲到这里终于发现这个设计的坏处：</p></li></ol><ul><li><p>本质上是消息复制很多次，浪费资源。</p></li><li><p>生产者必须知道有哪些消费者，从系统架构层面看，和最开始讲到的消息中间件的“服务解耦”设计理念相悖。</p><h3 id="发布-订阅模型"><a href="#发布-订阅模型" class="headerlink" title="发布-订阅模型"></a>发布-订阅模型</h3><p>前面讲了原始的队列模型，发现对于多个消费者的场景，解决方案不人性化。所以，发布-订阅模型支持了一条消息被多个消费者消费的场景。</p><p><img src="/img/post/publish-subscribe-model.webp"></p><p>其中，消息发送方被称为<strong>发布者</strong>，消息消费者被称为<strong>订阅者</strong>，消息中间件服务端存储消息的容器称为<strong>主题</strong>。发布者将消息发布到指定的主题中，订阅者如果想要消费某条消息，必须订阅这个消息所在的主题，订阅者可以接收到订阅的主题中的所有消息。</p><p>当只有一个消费者时，其实就是一个队列模型。所以两者的主要区别在，一条消息能不能被多次消费。</p><h3 id="RabbitMQ-如何解决多消费者问题？"><a href="#RabbitMQ-如何解决多消费者问题？" class="headerlink" title="RabbitMQ 如何解决多消费者问题？"></a>RabbitMQ 如何解决多消费者问题？</h3><p>RabbitMQ 目前使用的消息消息模型，依然是队列模型，那么它如何解决多消费者问题？</p><p>在前面的消息中间件的选型小节中，讲到 RabbitMQ 在架构上多了一个 Exchange 模块，用来做消息的路由，一条消息到底要发送到哪些队列，需要对 Exchange 做配置。</p><p><img src="/img/post/rabbitmq-exchange-arch.webp"></p><p>看上面的图，发现生产者并不是直接将消息发送到队列，而是发送到 Exchange 模块，由 Exchange 模块自己再做分发，决定消息都要发送到哪些队列。这里的设计，就像重构的时候，比较流行的一句话叫做“没有什么是封一层不能解决的”，这里我认为 Exchange 就是封的那一层，从而实现了“服务解耦”。</p><h3 id="RocketMQ-除了发布-订阅模型，为什么还有队列？"><a href="#RocketMQ-除了发布-订阅模型，为什么还有队列？" class="headerlink" title="RocketMQ 除了发布-订阅模型，为什么还有队列？"></a>RocketMQ 除了发布-订阅模型，为什么还有队列？</h3><p>RocketMQ 使用的是发布-订阅模型，并且术语表中的发布者、订阅者、主题者三个概念也符合前面的解释。</p><p>但是，RocketMQ 中依然有队列这样一个重要的概念，那么为什么需要队列呢？</p><p>首先得知道，不管是发送消息还是消费消息，都会设计到和服务端得网络通信，同时也就会带来消息发送失败、消息消费失败等问题，RocketMQ 为了解决这些问题，实现了<strong>请求-确认</strong>模式，发送消息时，当服务端接收到消息后会通知发布者，如果发布者迟迟未收到通知，会尝试重新发送，消息消费时，消费者消费了消息，会给消息中间件的服务端一个反馈，表示某条消息已经消费完成了，如果服务端迟迟没有收到确认的通知，会尝试将消息重新推送。</p><p>队列要解决的问题时消费端消费时间过长、消费失败重试的场景。</p><p>在普通的发布-订阅模型下，如果消费者消费失败了，需要重试的话，主题只有一个，其他所有订阅了这个主题的消费者就必须等这个消费者将这条消息消费过后，才能继续消费，这样对并发的消费并不友好，很多场景也不需要这种等待。</p><p>对于上述问题的解决方案就是，每个主题下维护多个队列，生产者发送消息时就已经确定了消息所在的消息队列，每个队列持有的 topic 的部分消息，各自队列中的消费进度可以不一样。集群消费模式下，每个队列上的消费进度存储在 Broker 端，同一个消费者组中，每个队列只能有一个消费者实例进行消费，所以队列记录的消费进度，本质上是消费者组在这个队列上的消费进度，这样就做到了集群消费模式下，每条消息在组内只消费一次。</p><p><img src="/img/post/rocketmq-consum-pattern.webp"></p><p>在 RocketMQ 中，每个订阅者，可能对应的不只是一个消费者，而是由多个<strong>消费者</strong>组成的一个<strong>消费者组</strong>，相应的发布者其实对应的也是一个<strong>生产者组</strong>。</p><p>然后就是，前面讲到，RocketMQ 的队列是主题的全量消息，那岂不是和队列模型一样造成了资源浪费？</p><p>其实不是的，RocketMQ 的消息存储设计上，所有消息都顺序存储在 commitlog 中，队列只是记录了消息 id 和消息在 commitlog 中的位置偏移量而已，所以也没造成资源浪费，只能说是使用空间换时间。</p><h3 id="Kafka-的消息模型"><a href="#Kafka-的消息模型" class="headerlink" title="Kafka 的消息模型"></a>Kafka 的消息模型</h3><p>Kafka 和 RocketMQ 的模型设计其实是差不多的，只不过 RocketMQ 中的队列，在 Kafka 中叫做<strong>分区</strong>(partition)。需要注意的是，这里只是<strong>消息模型上两者是一致的，但是具体实现上，肯定是不一样的</strong>。</p><h2 id="基于-MQ-的分布式事务的实现"><a href="#基于-MQ-的分布式事务的实现" class="headerlink" title="基于 MQ 的分布式事务的实现"></a>基于 MQ 的分布式事务的实现</h2><h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h3></li><li><p>原子性</p><p>一个事务操作不可分割，要么一起成功，要么一起失败。</p></li><li><p>一致性</p><p>在事务执行完成前，独到的一定是更新前的数据，执行完成后，读到的一定是更新后的数据，不存在一个时刻可以读到更新过程中的数据。</p></li><li><p>隔离性</p><p>事务之间不互相干扰。</p></li><li><p>持久性</p><p>事务一旦提交，后续发生的其他操作都不会对这次事务的结果产生影响。</p><p>这四个特性，如果分布式事务都要严格实现，几乎不可能，甚至单独要实现严格的数据一致性就会花费巨大的成本，最后只能退一步选择最终一致性。</p><p>在实际应用中的分布式事务实现由 2PC 、TCC 和事务消息，各自都存在问题，不是完美的解决方案，需要根据具体场景做出选择。</p></li><li><p>*事务消息**适合需要异步更新数据，对数据实时性要求不太高的场景。</p><h3 id="MQ-如何实现事务消息？"><a href="#MQ-如何实现事务消息？" class="headerlink" title="MQ 如何实现事务消息？"></a>MQ 如何实现事务消息？</h3><p>现在的电商网站都有购物车和订单的概念，购物车中的商品下单后，购物车中对应的商品会被清理掉。</p><p>订单和购物车是分开的两个系统，必定没办法在同一个本地事务中更新各自的数据，势必会出现下单成功，清理购物车失败，或者请求购物车成功，但是下单失败的场景。</p><p>此时就可以考虑使用 MQ 实现分布式事务来解决这个问题。</p><p><img src="/img/post/transactional-message.webp"></p></li></ul><ol><li>订单系统首先在消息中间件上开启一个事务。</li><li>然后发送一个<strong>半消息</strong>。</li><li>执行本地事务，创建订单。</li><li>提交或回滚消息队列中的事务。</li><li>如果事务要提交，消息中间件将消息投递到购物车系统。</li></ol><p> <strong>半消息</strong>，本身是一条完成得消息，只不过在事务提交之前，对消费者不可见、不能被消费。</p><p> 这里有一个问题，如果第四步失败了怎么办？</p><p> 对于这种情况，Kafka 会直接抛异常，交由用户处理。RocketMQ 则是给出了另一种解决方案。</p><h3 id="RocketMQ-中分布式事务的实现"><a href="#RocketMQ-中分布式事务的实现" class="headerlink" title="RocketMQ 中分布式事务的实现"></a>RocketMQ 中分布式事务的实现</h3><p> RocketMQ 的分布式事务实现流程中，增加了事务消息反查的机制来解决事务消息生产者提交失败的问题。</p><p> 如果 Producer 在第 4 步失败，RocketMQ 的 Broker 因为迟迟没有收到提交或者回滚事务的通知，就会定期去 Producer 上查询这个事务对应的本地事务状态，根据反查的结果决定事务消息提交还是回滚，这个反查本地事务的实现，不依赖消息发送放的特定节点，不然万一 Producer 在执行第 4 步时挂了，那反查也会失败。</p><p> <img src="/img/post/rocket-half-message.webp"></p><p> 上面的流程图解释了 RocketMQ 的分布式事务实现：</p><ol><li><p>生产者发送半消息到 Broker。</p></li><li><p>Broker 返回确认收到半消息。</p></li><li><p>Producer 执行本地的事务。</p></li><li><p>Producer 根据本地事务执行结果，通知 Broker 提交或回滚事务，Broker 接收到通知后，如果事务要提交，就投递消息，如果事务回滚，就删除半消息。</p></li><li><p>如果 Broker 一直没收到提交或回滚事务的通知，就向 Producer 反查事务。</p></li><li><p>Producer 接收到反查事务的请求，查询本地事务的执行状态并返回。</p></li><li><p>Broker 根据反查结果决定事务回滚或提交。</p><p>需要注意的是，反查的时候，处理反查请求的生产者实例和最开始发送半消息的生产者实例可以不是一个，意思是，反查逻辑不应该依赖生产者实例本身。比如前面创建订单的逻辑，反查逻辑可以是直接根绝订单号查询数据库中是否有这个订单，如果有，就证明本地事务执行成功。</p><p>这里有两个疑问：</p></li></ol><p> <strong>1. 如果生产者的本地事务成功了，事务消息也提交了，但是消费者消费失败了，如果不是消费者本身的问题，而是消息的业务数据本身就有问题，此时要怎么处理？</strong></p><p> 这种情况，肯定无法再回滚生产者端的数据，而且消息中间件本来就是为了解耦，所以也不应该影响生产者端的数据。而对于消费者，多次消费失败的消息，会将这种消息放到一个特殊队列中，等待人工处理，正常情况下，这种情况一般是偶发的。</p><p> <strong>2. 为什么不等本地事务执行完之后直接发送一条普通消息给消费者消费，而一定要事先发送半消息？</strong></p><p> 执行本地事务成功后，如果发送消息失败了，消费者端不会有消息可以消费。</p><blockquote><p>RocketMQ 事务消息示例：<a href="https://github.com/hanelalo/example/tree/main/rocketmq-example">https://github.com/hanelalo/example/tree/main/rocketmq-example</a></p></blockquote><h2 id="如何做到不丢消息？"><a href="#如何做到不丢消息？" class="headerlink" title="如何做到不丢消息？"></a>如何做到不丢消息？</h2><h3 id="如何排查丢消息问题？"><a href="#如何排查丢消息问题？" class="headerlink" title="如何排查丢消息问题？"></a>如何排查丢消息问题？</h3><p> 生产者发送消息时，给消息附加一个消息有序的序号，在消费者统计序号，缺少的序号就是丢失的消息。</p><p> 为了避免对业务代码的侵入，生产者给消息附加序号、消费者统计序号这两步都应该是放在客户端的拦截器中实现。</p><h3 id="生产阶段丢消息"><a href="#生产阶段丢消息" class="headerlink" title="生产阶段丢消息"></a>生产阶段丢消息</h3><p> 消息生产阶段丢消息，就是消息发送失败，此时需要在生产者端对发送结果进行检查和异常处理，就能保证不丢消息。</p><h3 id="存储阶段丢消息"><a href="#存储阶段丢消息" class="headerlink" title="存储阶段丢消息"></a>存储阶段丢消息</h3><p> 消息最终都会存储在 Broker 上，如果 Broker 首先新消息后还没来得及落盘，Broker 就宕机，此时就会出现丢消息的情况。不同的部署模式，有不同的解决方案。</p><ul><li><p>如果 Broker 是单机部署，只能设置为消息真正落盘后再返回确认信息给生产者，在 RocketMQ 中，直接将 flushDiskType 设置为 SYNC_FLUSH 即可。</p></li><li><p>如果是集群部署，需要配置成至少需要消息成功发送到了两个 Broker，才返回确认信息给生产者，如果其中一台 Broker 宕机了，还有其他 Broker 可以存储消息。</p><h3 id="消费阶段丢消息"><a href="#消费阶段丢消息" class="headerlink" title="消费阶段丢消息"></a>消费阶段丢消息</h3><p>消费者会先从 Broker 拉取消息，此时丢消息的情况一般都是因为先发送了消费确认的消息，再进行消费端的业务处理，如果消费端业务处理失败了，消息就丢了，因为对 Broker 来讲，这条消息已经消费成功了。</p><p>所以，在消费端必须先进行业务处理，再发送消费确认的信息到 Broker。</p><h2 id="如何解决重复消息问题？"><a href="#如何解决重复消息问题？" class="headerlink" title="如何解决重复消息问题？"></a>如何解决重复消息问题？</h2><h3 id="什么是消息传递服务质量标准"><a href="#什么是消息传递服务质量标准" class="headerlink" title="什么是消息传递服务质量标准"></a>什么是消息传递服务质量标准</h3></li><li><p>At most once</p><p>消息传递最多成功一次，最不可靠的质量，允许丢消息。适用于消息可靠性要求不高的场景，比如日志收集，偶尔丢一行日志影响也不大。</p></li><li><p>At least once</p><p>至少传递成功一次，消息传递时至少成功一次，允许消息重复。</p></li><li><p>Exactly once</p><p>消息恰好传递成功一次，不允许丢消息，也不允许重复。</p><p>主流的消息队列中间件服务质量都是 At least once 级别。</p><h3 id="幂等解决重复消息"><a href="#幂等解决重复消息" class="headerlink" title="幂等解决重复消息"></a>幂等解决重复消息</h3><p>在消费端，让消息的消费逻辑具有幂等性。</p></li><li><p>*幂等**：任意操作，执行一次和多次的影响是一样的。</p><p>可以认为 At least once + 幂等 = Exactlly once。</p><h4 id="使用数据库唯一约束实现幂等"><a href="#使用数据库唯一约束实现幂等" class="headerlink" title="使用数据库唯一约束实现幂等"></a>使用数据库唯一约束实现幂等</h4><p>适用于消息消费时插入的数据有不可重复的字段的场景。</p><h4 id="为更新数据设置前置条件"><a href="#为更新数据设置前置条件" class="headerlink" title="为更新数据设置前置条件"></a>为更新数据设置前置条件</h4><p>适用于更新数据的场景。</p></li><li><p>可以在更新前确认目标数据是否正确，比如确认字段 amount 的值是 500 时，才会执行更新语句，将 amount 更新成原来的值加 100。</p></li><li><p>为数据加上版本号，没更新一次，版本号加 1，每次更新，都需要确认更新前的版本号是否正确。</p><h4 id="使用全局唯一标识"><a href="#使用全局唯一标识" class="headerlink" title="使用全局唯一标识"></a>使用全局唯一标识</h4><p>为消息生成全局唯一的标识，消费者端没消费一条消息，就比较这个 id 的消息为已消费。</p><p>方案思路简单，但是实现十分困难，分布式唯一性 id 本身就是难点，设置消费状态还需要使用分布式事务，而分布式事务的实现本身就是一个问题。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><strong>为什么大部分消息队列都选择只提供 At least once 的服务质量，而不是级别更高的 Exactly once 呢？</strong></p></li></ul><ol><li><p>严格实现 Exactly Once，势必会导致 Broker 处理新消息得性能下降。</p></li><li><p>就算 Broker 做到了 Exactly once，消费者如果消费成功，但是 ack 失败，依然会造成对同一条消息重复消费，Broker 做的 Exactly once 完全没有意义。</p><h2 id="消息积压如何处理？"><a href="#消息积压如何处理？" class="headerlink" title="消息积压如何处理？"></a>消息积压如何处理？</h2><p>因为一般情况下，业务节点对请求得处理逻辑比消息队列对消息得处理逻辑要复杂得多，所以消息挤压其实是无法完全避免得问题，只能通过优化，让消息生产者和消费者更好的配合消息队列，达到最佳性能。</p><h3 id="生产端优化"><a href="#生产端优化" class="headerlink" title="生产端优化"></a>生产端优化</h3><p>其实生产者端的优化和队列中的消息挤压关系不大。</p><p>如果消息发送太慢，那可能是发送消息前的业务处理太耗时，因为发送消息一般都是放在最后一步。</p><p>然后，对于不同业务场景，也需要选择不同的消息发送的模式。</p><p>如果是在线业务场景，业务上更在意时延，那就选择并发的方式发送消息；如果是离线的分析场景，不关心时延，更关心吞吐量，那就选择批量发送，使用少量的并发就可以提高吞吐量。</p><h3 id="消费端优化"><a href="#消费端优化" class="headerlink" title="消费端优化"></a>消费端优化</h3><p>如果消费的速度跟不上消息生产的速度，此时就会出现消息积压。</p><p>如果消费端的性能问题只是暂时的，那么消费端的性能恢复后，积压的消息自然也会随着消费慢慢解决。</p><p>如果消费端的性能一致比生产端慢，那就会导致消息不断积压，最后队列被填满，造成消息丢失，这是一个严重的故障。</p><p>所以，<strong>一定要保证消费端性能比生产端性能高，才能更好避免消息积压。</strong></p><p>除了优化消费端代码性能，还可以选择消费者的横向扩展，增加消费者实例数，需要注意的时候，<strong>扩展消费者的同时，需要同步增加订阅的主题中的队列数量，确保消费者数量和队列数量一致</strong>，因为每个队列每个时刻只能一个线程消费。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>突然的消息积压，要么是消息发送变快了，要么是消息消费变慢了。</p><p>如果是因为网站搞活动这种活动导致消息发送变快，那就只能增加消费者是实例数，如果没资源可以分配了，那就只能忍痛关闭一些不重要的业务系统，释放资源。</p><p>消费变慢的情况，可能是消费者运行时发生了死锁或者卡在了资源竞争上。</p><p>还有一种场景，消费速度和生产速度没明显变化，此时需要排查是否是因为某条消息消费失败，导致一直在重复消费这条消息。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 分布式锁</title>
      <link href="posts/26347f83912d.html"/>
      <url>posts/26347f83912d.html</url>
      
        <content type="html"><![CDATA[<img src='http://image.hanelalo.cn/images/202111061352025.png'/><span id="more"></span><p>在分布式应用场景下，总是会涉及到多个应用并发操作同一个业务数据得问题，在这种情况下，就会采用分布式锁来限制并发操作。</p><p>目前业界的分布式锁实现方式主要有 Zookeeper 实现和 Redis 实现，本文主要介绍 Redis 实现的分布式锁。</p><h1 id="要解决的问题？"><a href="#要解决的问题？" class="headerlink" title="要解决的问题？"></a>要解决的问题？</h1><ul><li><p>加锁</p><p>简单点直接使用 set 指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> key value</span><br></pre></td></tr></table></figure><p>如果在锁已经被持有的时候，有其他线程获取锁，是不能成功的，所以考虑使用 <code>setnx</code> 指令，这个指令只有在 key 不存在时才会设置成功，key 不存在，那就是未加锁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure><p>其实上面的解决方案太过片面，是有问题的，继续往下看吧。</p></li><li><p>解锁</p><p>从前面加锁的操作来看，其实解锁直接将 key 删除即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure></li><li><p>锁超时</p><p>如果锁超时，不续锁的话，肯定是要让锁释放的，要做到这种效果，可以考虑 <code>expire</code> 指令，用来设置 key 的过期时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire key 10 <span class="comment"># key 10 秒后过期</span></span><br></pre></td></tr></table></figure><p><code>set</code> 指令是支持直接一步到位的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> key value ex 10 <span class="comment"># 设置 key 和 value 键值对，有效期为 10 秒</span></span><br></pre></td></tr></table></figure><p>但是 <code>setnx</code> 是不支持的，只能单独再执行一次 <code>expire</code> 指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br><span class="line">expire key 10</span><br></pre></td></tr></table></figure><p>既然 <code>setnx</code> 指令不能一步到位，那如果说在 <code>setnx</code> 后 Redis 宕机了，那么这个锁就会一直存在，因为没设置过期时间。</p><p>其实 set 指令也可以通过参数控制，做到 setnx 的效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> key value ex 10 nx <span class="comment"># 设置一个 key-value 键值对，有效期为 10 秒，当 key 不存在时做这个操作</span></span><br></pre></td></tr></table></figure><p>在锁超时场景下，上述解决方案依然还有问题。</p><p>试想这样一个场景：</p><p>A 线程持有 orderId 的锁，有效期 10 秒，但是 10 秒后，A 线程的业务操作还没有做完，这个时候锁超时，被释放，紧接着 B 线程请求锁并成功持有了锁，然后 A 线程终于操作完成，大家都知道，写代码的时候，有加锁，那必定会在结尾调用解锁，A 最终调用了解锁，将 Redis 中的锁删除。</p><p>上面的问题在于， A 线程删除的锁，并不是自己所持有的锁。要如何保证多线程环境下，不会删除其他线程的锁呢？</p><p>Redis 官网给除了很多种语言平台基于 Redis 的分布式锁解决方案，其中 Java 的 Redisson 框架上榜。</p></li></ul><h1 id="Redisson-实现分布式锁"><a href="#Redisson-实现分布式锁" class="headerlink" title="Redisson 实现分布式锁"></a>Redisson 实现分布式锁</h1><p><a href="https://redisson.org/">Redisson</a> 是一个封装了基于 Redis 的分布式操作的 Java 框架。</p><p>先尝试使用一下 Redisson 的锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.setTransportMode(TransportMode.NIO);</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">myLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br><span class="line"><span class="comment">// 加锁，有效期 20 秒</span></span><br><span class="line">myLock.lock(<span class="number">20</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>启动程序后，查看一下 redis 中的数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> myLock</span><br><span class="line"><span class="built_in">hash</span></span><br><span class="line">127.0.0.1:6379&gt; ttl myLock</span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; hgetall myLock</span><br><span class="line">1) <span class="string">&quot;cc405566-7cfb-40ea-a1e3-7ddbe998e348:1&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>可以看见， myLock 这个锁在 Redis 里面其实是以 hash 的数据结构实现的，hash 内部的 key 和 value 是什么暂且先不讨论。</p><p>通过 <code>ttl</code> 指令也可以看见此时 myLock 的有效期还剩下 13 秒。</p><p>接下来再通过一个测试来看看前面提到了多线程的问题在 Redisson 中是否得到了解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">  config.setTransportMode(TransportMode.NIO);</span><br><span class="line">  config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line">  <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">  <span class="type">RLock</span> <span class="variable">myLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br><span class="line">  <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">first</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">          () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 加锁，有效期 10 秒</span></span><br><span class="line">            myLock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;-&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;获取锁成功&quot;</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">15000</span>);</span><br><span class="line">              System.out.println(</span><br><span class="line">                  <span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;-&quot;</span> + Thread.currentThread() + <span class="string">&quot; 锁持有情况:&quot;</span> + myLock.isHeldByCurrentThread());</span><br><span class="line">              System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;-&quot;</span> +Thread.currentThread().getName()+<span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">              myLock.unlock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;thread-first&quot;</span>);</span><br><span class="line">  first.start();</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">second</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">          () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              countDownLatch.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加锁，有效期 10 秒</span></span><br><span class="line">            myLock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;-&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;获取锁成功&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">7000</span>);</span><br><span class="line">              System.out.println(</span><br><span class="line">                  <span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;-&quot;</span> + Thread.currentThread() + <span class="string">&quot; 锁持有情况:&quot;</span> + myLock.isHeldByCurrentThread());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;thread-second&quot;</span>);</span><br><span class="line">  second.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容我稍微从时间线的角度解释一下这段代码：</p><ol><li>主线程建立 Redis 连接，先创建一个 myLock 的锁引用，这个时候其实 Redis 中还没有 myLock 这个 hash。</li><li>线程 first-thread 和 second-thread 启动。</li><li>通过 CountDownLatch 使得 first-thread 先获得锁后 second-thread 才开始获取锁，以产生可控的锁竞争情景，两个线程获取锁时设置的有效时间都是 10 秒。</li><li>first-thread 拿到锁之后，线程休眠 15 秒，静等锁自动超时。</li><li>10 秒后，线程 first-thread 锁超时自动释放，second-thread 里面持有了锁，并开始休眠 7 秒。</li><li>first-thread 的 15 秒休眠结束，检查当前的锁状态，持有锁的是否为本线程，尝试释放锁，注意在此之前其实已经自动释放了。</li><li>又过了大概 2 秒的时间，second-thread 休眠 7 秒结束，查看当前锁状态，是否为本线程持有锁。</li></ol><p>运行的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sun Apr 11 17:44:08 CST 2021-thread-first获取锁成功</span><br><span class="line">Sun Apr 11 17:44:08 CST 2021</span><br><span class="line">Sun Apr 11 17:44:18 CST 2021-thread-second获取锁成功</span><br><span class="line">Sun Apr 11 17:44:23 CST 2021-Thread[thread-first,5,main] 锁持有情况:false</span><br><span class="line">Sun Apr 11 17:44:23 CST 2021-thread-first 释放锁</span><br><span class="line">Exception in thread &quot;thread-first&quot; java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: c1fa6349-d087-49d1-8db4-ba48ed427de1 thread-id: 47</span><br><span class="line">at org.redisson.RedissonBaseLock.lambda$unlockAsync$1(RedissonBaseLock.java:312)</span><br><span class="line">at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)</span><br><span class="line">Sun Apr 11 17:44:25 CST 2021-Thread[thread-second,5,main] 锁持有情况:true</span><br></pre></td></tr></table></figure><p>可以看见，first-thread 休眠结束后，发现当前的锁并非自己持有的，尝试释放锁直接报错。</p><p>first-thread 线程在 08 秒获取到锁，10 秒后超时自动释放，second-thread 刚好在 18 秒拿到锁，最终 second-thread 在休眠 7 秒后，此时 first-thread 已经尝试释放过一次锁，然而此时 second-thread 的检查结果为当前持有锁的线程为 second-thread。</p><p>所以， Redisson 的锁实现是没有前面讲到的 A 线程释放掉 B 线程的锁的问题。</p><p>那么，是如何做到的呢？</p><p>通过上面的报错信息先猜想一下，是不是在 Redis 里面还存了当前持有锁的线程的”身份信息”？以此来判断释放锁的线程和持有锁的线程是否为同一个线程。</p><h1 id="Redisson-分布式锁源码浅析"><a href="#Redisson-分布式锁源码浅析" class="headerlink" title="Redisson 分布式锁源码浅析"></a>Redisson 分布式锁源码浅析</h1><p>在看源码之前，先复习一下 Java 本身提供的 Lock 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁，不支持中断</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 加锁，支持中断</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 尝试加锁，不支持中断</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 支持超时机制，尝试获取锁，支持中断</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>lock()</code> 是会阻塞线程的。</p><p>而 Java 中经典的锁有三种：</p><ul><li><p>普通的互斥锁</p><p>一个线程锁之后，其他线程再想要持有锁都必须等锁被释放，哪怕后来请求加锁的线程是持有锁的线程都不行。</p></li><li><p>重入锁</p><p>在前面一种锁的基础上支持同一个线程多次加锁。</p></li><li><p>读写锁</p><p>内部维护两个锁，一把读锁和一把写锁，写锁被持有时，其他所有线程请求读锁和写锁都被阻塞，读锁被持有时，其他线程获取写锁会阻塞，获取读锁会成功。</p></li></ul><p>然后，再看看 Redisson 中的锁实现。</p><h2 id="RedissonLock"><a href="#RedissonLock" class="headerlink" title="RedissonLock"></a>RedissonLock</h2><p>这是调用 <code>RedissonClient.getLock()</code> 方法返回的锁对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> CommandAsyncExecutor commandExecutor;</span><br><span class="line"><span class="keyword">public</span> RLock <span class="title function_">getLock</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedissonLock</span>(commandExecutor, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着看看 RedissonLock 的 lock 方法（艹了，源码一行注释都没有）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">boolean</span> interruptibly)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    .<span class="comment">// 当前线程 id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 尝试获取锁，这里的 ttl 后面解释</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 尝试获取锁失败，后续操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不看其他的，就看看 <code>tryAcquire()</code> 方法的实现，最后会追踪到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">            Collections.singletonList(getName()), unit.toMillis(leaseTime), getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那一大串拼接的字符串，其实是一段 lua 脚本，Redis 执行 lua 脚本是能保证原子性的，同时当 Redis 在执行一段 lua 脚本时，是不会有其他的 lua 脚本或者命令同时执行的，这就为同一时间真正能加锁成功的只有一个线程提供了保证。</p><p>这段 lua 脚本抽出来看看：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- RLock 在 redis 种采用 hash 数据结构</span></span><br><span class="line"><span class="comment">-- KEYS[1] 就是 hash 的名字，项目的例子中 KEYS[1]=myLock</span></span><br><span class="line"><span class="comment">-- hash 的 key 是线程 id, value 是数字</span></span><br><span class="line"><span class="comment">-- 先判断 myLock 这个 redis 是否存在，如果不存在，返回 0</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- hincrby 指令，如果指定域的某个 field 存在，就将该 field 的值 +1</span></span><br><span class="line">    <span class="comment">-- 如果不存在，就创建，初始化为 0 并 +1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="comment">-- 设置过期时间</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"><span class="comment">-- hash 存在，则判断 field 是否存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- field 得值 +1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="comment">-- 重置过期时间</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"><span class="comment">-- 证明锁已经被持有，那就返回锁的有效期</span></span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>看注释就够了，简单解释一下参数列表：</p><ul><li><p>KEYS[1] </p><p>其实就是前面的例子中的 myLock，锁的名字，也是 Redis 中 hash 的名字</p></li><li><p>ARGV[1]</p><p>线程持有锁的有效时间，单位为<strong>毫秒</strong>。</p></li><li><p>ARGV[2]</p><p>持有锁的线程 id，其实不是简单的 id，注意 getLockName() 这个方法，后续会再来剖析。</p></li></ul><p>从这里也就能猜到 tryAcquire() 方法返回的 Long 是当锁被其他线程持有时剩余的有效期，注意这里是 long 的封装类型，允许为 null。</p><p>现在将视线回到 RedissonLock 的 lock 方法里面，当 tryAcquire() 方法返回后，如果返回值为 null，从 lua 脚本的逻辑和 Java 代码的处理逻辑可以知道，此时是获取锁成功了。</p><p>当返回值不为 null 时，会放进一个 while 循环里面一致请求锁，直到成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">             <span class="comment">// 尝试获取锁，再次获取一次 ttl</span></span><br><span class="line">             ttl = tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line">             <span class="comment">// lock acquired</span></span><br><span class="line">             <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 获取锁失败</span></span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// waiting for message</span></span><br><span class="line">             <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">// 阻塞当前线程 ttl 的时长</span></span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                         <span class="keyword">throw</span> e;</span><br><span class="line">                     &#125;</span><br><span class="line">                     future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                     future.getNow().getLatch().acquire();</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     future.getNow().getLatch().acquireUninterruptibly();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>OK，到目前为止，Redisson 实现分布式锁的大致原理知道了。到这里基本上就结束了，下面只是我个人疑问的探索。</p><p>有个问题，在加锁的时候，我们在 hash 里面放入的键值对的 key 是一个线程 id 相关的字符串，既然是线程 id，那么当有多台服务器上的线程都在请求同一把锁时，肯定会出现不同服务器上的线程 id 重复的情况，那这种情况又要怎么解决？</p><p>前面在执行 lua 脚本的时候，又提过要主要 getLockName 这个方法，现在一起来看看吧。</p><h2 id="分布式场景下如何做到锁的-key-唯一"><a href="#分布式场景下如何做到锁的-key-唯一" class="headerlink" title="分布式场景下如何做到锁的 key 唯一"></a>分布式场景下如何做到锁的 key 唯一</h2><p>拉到最前面执行 lua 脚本的地方，仔细翻看源码不难发现 getLockName() 方法的返回值其实就是在加锁时，hash 中的 key，同样，在最开始使用 Redisson 的分布式锁的时候，就看见过这个 key 的样子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc405566-7cfb-40ea-a1e3-7ddbe998e348:1</span><br></pre></td></tr></table></figure><p>嗯，看不懂，还是看看代码吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String <span class="title function_">getLockName</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> id + <span class="string">&quot;:&quot;</span> + threadId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，格式对上了，那么这个 id 是什么，在什么时候，通过什么生成的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RedissonBaseLock</span><span class="params">(CommandAsyncExecutor commandExecutor, String name)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(commandExecutor, name);</span><br><span class="line">    <span class="built_in">this</span>.commandExecutor = commandExecutor;</span><br><span class="line">    <span class="built_in">this</span>.id = commandExecutor.getConnectionManager().getId();</span><br><span class="line">    <span class="built_in">this</span>.internalLockLeaseTime = commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout();</span><br><span class="line">    <span class="built_in">this</span>.entryName = id + <span class="string">&quot;:&quot;</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 id 是 RedissonLock 的父类 RedissonBaseLock 中定义的，最终其实又是从ConnectionManager 中获取，这个 ConnectionManager 从名字就可以知道其实是建立 redis 连接的时候初始化的，那就再看看初始化 ConnectionManager 的代码吧。</p><p>啊算了不看了，找了几秒钟发现其实就是一个 UUID，而 UUID 本身就是通过纳秒级的时间戳和宿主机的以太网卡地址等等一些信息生成的，本身就保证了分布式的唯一性，所以再搭配上线程 id，也就解决了前面提到的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL知识点-1</title>
      <link href="posts/3061a7fdd19b.html"/>
      <url>posts/3061a7fdd19b.html</url>
      
        <content type="html"><![CDATA[<img src='http://image.hanelalo.cn/images/202111061351625.png'/><span id="more"></span><h1 id="MySQL-知识点梳理（一）"><a href="#MySQL-知识点梳理（一）" class="headerlink" title="MySQL 知识点梳理（一）"></a>MySQL 知识点梳理（一）</h1><h2 id="MySQL-架构"><a href="#MySQL-架构" class="headerlink" title="MySQL 架构"></a>MySQL 架构</h2><p>MySQL 主要分为客户端、Server 端和存储引擎。</p><p><img src="/img/post/MySQL%E6%9E%B6%E6%9E%84.png" alt="MySQL 架构"></p><ul><li><p>客户端</p><p>客户端一般都是指一些应用，比如常见的一些可以连接到数据库的可视化软件，也可以理解为客户端，如果写一段代码通过 JDBC 连接到 MySQL，运行这段代码的程序也是客户端，一般客户端和 Server 端都是靠 TCP 做网络通讯。</p></li><li><p>Server 端</p><p>用来处理连接请求和各种增啥改查的请求。</p><ol><li><p>连接管理</p><p>MySQL 内部维护了一个连接线程池，并不是每个连接过来都是新建一个线程，连接断开后又销毁，这样太浪费资源。</p></li><li><p>查询缓存</p><p>顾名思义，就是如果同样的查询语句执行两次，两次都真正的去查询了，查出来的结果还是一样的，那就造成了浪费，完全可以把第一次的查询结果缓存下来，第二次查询的时候识别到是同样的查询语句，就可以将缓存直接返回而不用真的再次查询。</p><p>既然用到了缓存，那么肯定还涉及到缓存的维护，当两次查询中间多了一次修改数据的操作，那缓存相应的也应该失效。维护缓存也是需要一些资源消耗的，但是其实现在大部分的架构中，MySQL 正常情况下并不会真的承担很大的流量冲击，所以这个缓存也不是很有必要，在 MySQL8.0 的时候直接删除了。</p></li><li><p>语法解析</p><p>就是解析要执行的 SQL，毕竟 SQL 只是一个字符串，得解析成结构化的数据才知道一条 SQL 到底是做什么操作，像 SQL 中的一些语法错误就是在这个时候发现的。</p></li><li><p>查询优化</p><p>SQL 都是人写的，很多时候可能写的不是很优雅，明明能用索引却没用到等等，这种的一般都会影响 SQL 的执行效率，所以 Server 端为了效率考虑，在不影响 SQL 最终执行结果的情况下，对 SQL 做出一些优化。优化之后最终会生成执行计划，可以通过 <code>explain &lt;sql&gt;</code> 的形式查看。 </p></li></ol></li><li><p>存储引擎</p><p>MySQL 作为最受欢迎的开源数据库之一，发展到现在已经积累的很多种存储引擎，之所以能支持这么多的存储引擎，主要还是因为存储引擎对 MySQL 来说是以插件的方式集成的，所以才能灵活的支持多种不同的存储引擎。目前主要使用的存储引擎主要是 Innodb，其次是可能还会用到 MyISAM 引擎。</p><p>这两者主要的的异同点如下：</p><ol><li>两种都是使用 B+ 树作为索引的数据结构。</li><li>Innodb 使用的是聚簇索引，而 MyISAM 使用的是非聚簇索引。</li><li>Innodb 支持事务，而 MyISAM 不支持。</li><li>Innodb 支持行级锁、外键，而 MyISAM 不支持。</li></ol><p>除了上面的几个还有很多，其实记住也没用，反正会忘。</p><p>MySQL 在 5.5.5 版本开始，默认使用 Innodb 作为存储引擎，在这之前一直是默认使用 MyISAM 引擎。</p></li></ul><h2 id="文件预读缓存"><a href="#文件预读缓存" class="headerlink" title="文件预读缓存"></a>文件预读缓存</h2><p>众所周知，在数据库四大特性中由持久性，最终数据都会被落盘。而当处理查询数据的请求时，最终页是要读取磁盘上存储的内容来进行查询，但是总不能一条一条的数据读取，当数据量大的时候，这样太慢了，性能大部分耗费在了磁盘 IO 上。针对这种情况，Innodb 对数据进行了分页，每一页默认 16 kb 大小，每次都不是只读取一条数据，而是读取一页数据。</p><blockquote><p>这就像看书一样，虽然看是一行一行的看，但是每次进入你眼睛的肯定是一页，总不可能一页书那么多内容，眼睛就只能看见一行吧，这不科学。</p></blockquote><p>这里一页数据的大小由 <code>innodb_page_size</code>  设置，这项配置是在初始化 MySQL 的时候就得决定好，后续是无法更改的，因为这还涉及到建索引的一些细节。从配置的名字也能看出，这是 Innodb 存储引擎专有的配置。</p><h2 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B 树和 B+ 树"></a>B 树和 B+ 树</h2><p>MySQL 的 InnodDB 引擎索引是使用的 B+ Tree。</p><p>B 树和 B+ 树最大的区别在于，B 树的所有节点都存储了数据，而 B+ 树的数据都在叶子节点上，所有父节点只是方便查询，而不会真正存储数据，所有叶子节点之间还维护了双向链表的数据结构。</p><p>因为索引也是需要持久化到磁盘文件，所以不得不考虑索引的存储空间的问题。B 树因为不管是不是叶子节点都存储了数据，所以当数据量逐渐上升时，树的高度就会逐渐上升。</p><p>下面主要通过<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">数据结构可视化的工具</a>对比一下 B 树和 B+ 树。</p><ul><li><p>B 树</p><p><img src="/img/post/B-Tree.png" alt="B Tree"></p></li><li><p>B+ 树</p><p><img src="/img/post/B+Tree.png" alt="B+ 树"></p></li></ul><p>首先解释一下 <code>Degree</code>，翻译过来叫做<strong>度</strong>，主要是用来限制每个节点的大小，观察上面两两张图，发现有些节点里有两条数据，这个 Degree 就可以理解为对 B 树或者 B+ 树中每个节点的数据个数的限制。</p><p>接下来再来看看这两个数到底有什么区别，为什么 MySQL 要使用 B+ 树作为索引？</p><p>观察上面两张图，同样都是存储 10 条数据，发现似乎 B 树的节点更少，而 B+ 树的节点更多，甚至还有重复的节点。当我单独查找 1 这个数据的时候， B 树似乎还比 B+ 树要快点的样子。要知道 B+ 树其实算是针对特殊业务的 B 树的改良版，其实单独要查找一条数据的时候，确实 B 树要比 B+ 树快，因为 B 树可能还没到叶子节点就返回了，但是 B+ 树必须一路查找到叶子节点才算完。<strong>但是，MySQL 的 B+ 树一般也就 3 层的样子，性能差距基本体现不出来，这个在最后会讲。</strong></p><p>思考一个问题：</p><p><strong>如果现在要做范围查询，谁快？</strong></p><p>MySQL 并不可能只考虑单独查询一条数据的情况，更多的业务场景可能是范围查询。</p><p>当要做范围查询的时候，虽然两种树都算是有序的，但是 B 树在找到一个节点后，可能还得回到父节点，甚至可能还得回到爷爷辈的节点才能继续往下找到其他的目标节点，这是一种资源消耗；再看 B+ 树，发现所有的数据都在叶子节点上，而且所有叶子节点组成了有序链表， MySQL 中使用的还是双向链表，这样的设计，在做范围查询的时候，找到了第一个节点之后，跟着链表继续往后查询数据就行了，也就不用再考虑指针回到父节点这种事了，效率也就瞬间上去了。</p><p>现在知道为什么要用 B+ 树了。<strong>那么 B+ 树到底是怎么存储数据的？</strong></p><p>我们看到 B+ 树的数据结构图中，很多叶子节点在父结点中也存在，这样不会造成数据冗余吗？</p><p>其实这就是数据结构和实际运用的问题了。不管是什么数据库，索引都是针对某些字段建立的，比如主键索引，那 B+ 树中的非叶子节点村的其实不是某个主键值的行数据，而只是存了主键字段的值，方便查询的时候对比，而完整的行数据只是存在最终指向的叶子节点中，因为比较的时候并不需要完整的行数据，所以，不存在所谓的数据冗余。就像下图这样，这个图画的并不准确，只是为了表示行数据都存在了叶子节点而已。</p><p><img src="/img/post/B+Tree-Index.png" alt="B+Tree-Index"></p><h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>在前面讲到 Innodb 和 MyISAM 存储引擎的区别时，讲到 Innodb 使用的是聚簇索引，MyISAM 使用的是非聚簇索引。</p><p>聚簇索引和非聚簇索引的区别在于数据和索引是否放在一起，这里的在一起，也不是狭隘的指在同一个文件就行，我认为i在同一个文件是前提而已。</p><p>MySQL 的 Innodb 存储引擎，数据和索引放在一起，每个表都会有一个聚簇索引，聚簇索引主要是针对主键建立的，所以每一条数据的插入都必须插入主键对应的字段，如果表中没有主键，那就以唯一性字段作为聚簇索引，如果主键和唯一性字段都没有，就会以 MySQL 为每条数据默认生成的 rowId 建立聚簇索引，这个 row_id 对用户不可见，长度为 6 个字节，也就比 Java 中的 <code>int</code> 多 2 字节，比 Java 中的 <code>long</code> 少 2 字节，其实已经是一个很大的数了。</p><p>考虑到 MySQL 的索引使用的是 B+ Tree，所有数据都存在叶子节点上面，换个角度就是，聚簇索引的叶子节点已经包含和表中所有数据的内容，如果其他字段也单独建立索引，肯定也是基于 B+Tree，那么这个字段索引的叶子节点存储的将不是数据内容，而是数据主键，因为如果像主键索引一样存储数据内容，就造成和主键索引数据重复，没必要浪费这部分空间。</p><p>综上所述，Innodb 存储引擎的表中，只有一个且必须有一个聚簇索引，这个聚簇索引一般都是表的主键或者某个唯一性标识的字段或者 row_id，其他字段则是非聚簇索引。</p><p>MyISAM 使用的也是 B+Tree，不过使用的是非聚簇索引，也就是说，Myisam 引擎的数据文件和索引文件是分开存储的，索引树的叶子节点最终存储的不是行数据内容，而是数据的地址。</p><p>可以粗略对比一下 MyISAM 和 Innodb 的文件存储就知道了。</p><p>先创建两张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_inno(id <span class="type">int</span> <span class="keyword">primary</span> key,name <span class="type">varchar</span>(<span class="number">10</span>)); <span class="comment">-- 当前版本 5.7，默认Innodb</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_myisam(id <span class="type">int</span> <span class="keyword">primary</span> key,name <span class="type">varchar</span>(<span class="number">10</span>)) engine<span class="operator">=</span>MyISAM; <span class="comment">-- 设置存储引擎为 MyISAM</span></span><br></pre></td></tr></table></figure><p>可以通过下面的语句看看两张表的存储引擎是否和预想一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tab_inno;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tab_myisam;</span><br></pre></td></tr></table></figure><p>然后去到 MySQL 的数据目录下面查看这两张表的数据文件。</p><p>通过 <code>show variables like &#39;datadir&#39;</code> 可以查看数据目录的路径：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;datadir&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> datadir       <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>到了数据目录之后，里面每个数据库都分了自己的文件夹，找到目标数据库的文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@c3195fbafff8:/var/lib/mysql/study<span class="comment"># ls -l</span></span><br><span class="line">total 268</span><br><span class="line">-rw-r----- 1 mysql mysql     65 Mar 14 04:15 db.opt</span><br><span class="line">-rw-r----- 1 mysql mysql   8586 Mar 14 09:30 tab_inno.frm</span><br><span class="line">-rw-r----- 1 mysql mysql  98304 Mar 14 09:30 tab_inno.ibd</span><br><span class="line">-rw-r----- 1 mysql mysql      0 Mar 14 09:31 tab_myisam.MYD</span><br><span class="line">-rw-r----- 1 mysql mysql   1024 Mar 14 09:31 tab_myisam.MYI</span><br><span class="line">-rw-r----- 1 mysql mysql   8586 Mar 14 09:31 tab_myisam.frm</span><br><span class="line">-rw-r----- 1 mysql mysql   8648 Mar 14 04:46 tb_user.frm</span><br><span class="line">-rw-r----- 1 mysql mysql 131072 Mar 14 04:46 tb_user.ibd</span><br><span class="line">root@c3195fbafff8:/var/lib/mysql/study<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>可以看见 tab_inno 表对应的数据文件有两个，以 <code>.frm</code> 结尾的是表结构文件，<code>.idb</code> 结尾的文件表示是 <code>Innodb</code> 的数据文件。</p><p>而 tab_myisam 表的文件则有三个，一个 <code>.frm</code> 的表结构文件，一个 <code>.MYD</code> 结尾的数据文件，一个 <code>.MYI</code> 结尾的所以索引文件。</p><p>所以， 使用 MyISAM 存储引擎的表还真的不是聚簇索引。</p><h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>上面讲到了到两种索引，一个是主键 id 或者唯一性字段或这 row_id 建立索引，一般都是聚簇索引，这种的字段暂且统称为 key，还有一些字段，或许根本就不具备唯一性，但是我们为了方便查询，也建立了索引，比如 name，方便描述，先假设 key 的索引叫做 mainIndex，name 的索引叫做 nameIndex。</p><p>当我执行下面的查询语句时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,age <span class="keyword">from</span> tb_user <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;zhangsan&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此时，会先根据 <code>name=&#39;zhangsan&#39;</code> 在 nameIndex 这个索引中查找，但最终找到的只有目标数据的 id，因为 nameIndex 是叶子节点中村的不是数据，而是数据的 key，在这个查询结果中，不只是要 key(这里指 id 这个字段)，还需要 age，而通过 nameIndex 这个索引，只拿到了 name 和 id，所以还需要通过查找到的 key 再到 mainIndex 中查找一次，才能找到目标数据的 age。</p><p>这种先查找到主键 key，然后通过主键 key 再次查询的操作就叫做回表。</p><h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>和回表一样的背景，只不过查询语句改为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> tb_user <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;zhangsan&#x27;</span>;</span><br></pre></td></tr></table></figure><p>之所以要回表是因为要查询 age 这个字段的值，因为查询结果要返回这个字段，但是上面这条语句，不返回 age 字段了，只需要 id 和 name，这两个字段的值，在 nameIndex 这个索引中是可以找到的，直接就满足了要返回的数据要求，所以就不需要再查询 mainIndex，直接返回，这种情况叫做索引覆盖。</p><p>对比了索引覆盖和回表操作之后，也就能够理解为什么再写查询语句的时候要避免使用 <code>select *</code> 而要求只写需要的字段，就是为了避免不必要的回表操作，导致不必要的 B+ Tree 查询。</p><h2 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h2><p>最左匹配主要是针对联合索引。</p><p>比如建立如下的索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_user <span class="keyword">add</span> index name_gender (name,gender);</span><br></pre></td></tr></table></figure><p>这里是针对 name 和 gender 两个字段建立的联合索引。</p><p>紧接着执行如下的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, gender <span class="keyword">from</span> tb_user <span class="keyword">where</span> name<span class="operator">=</span>? <span class="keyword">and</span> gender<span class="operator">=</span>?;</span><br><span class="line"><span class="keyword">select</span> name, gender <span class="keyword">from</span> tb_user <span class="keyword">where</span> name<span class="operator">=</span>?;</span><br><span class="line"><span class="keyword">select</span> name, gender <span class="keyword">from</span> tb_user <span class="keyword">where</span> gender<span class="operator">=</span>?;</span><br><span class="line"><span class="keyword">select</span> name, gender <span class="keyword">from</span> tb_user <span class="keyword">where</span> gender<span class="operator">=</span>? <span class="keyword">and</span> name<span class="operator">=</span>?;</span><br></pre></td></tr></table></figure><p>第一条 sql 因为建立的索引就是 name 和 gender，所以肯定使用到了索引。</p><p>第二条 sql，也使用到了 name_gender 这个索引。</p><p>第三条 sql 没有使用索引。</p><p>第四条 sql 因为 MySQL 的 sql 优化，所以使用到了索引。</p><p>之所以第三条没使用到索引，就是因为联合索引的最左匹配原则，建立索引时，前面的字段在查询时优先匹配，如果没匹配上，就不会使用这个索引。</p><p>可以理解为，第三条语句在尝试使用 name_gender 这个索引的时候，首先检查了当前的查询条件中是否使用了 name 这个字段，发现并没有，所以就直接不是用 name_gender 这个字段了，之所以要首先要检查是否使用了 name 这个字段，是因为在定义所以的时候， name 字段写在前面，所以说，定义联合索引时，字段也是又优先级的区别的。</p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>在文章最开始的时候就讲过，MySQL 架构分为客户端、服务端和存储引擎，在没有索引下推这种机制的时候，执行以下 SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;Stom&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>此时存储引擎会根据 <code>name=&#39;Stom&#39;</code> 这个条件查询出结果，然后返回给服务端，然后由服务端来做 <code>age=12</code> 这部分的筛选。</p><p>这样做的坏处在于，可能在 <code>name=&#39;Stom&#39;</code> 阶段返回了几十上百条数据，但是最终 <code>age=12</code> 过滤后只剩下几条数据，这对于存储引擎和服务端之间的通讯来说，造成了极大的资源浪费。</p><p>所以索引下推就是将 <code>age=12</code> 这一步也放到了存储引擎里面去做，减少了存储引擎和服务端之间的资源浪费。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><strong>范围查询有回表时，到底是一条一条回表还是集中回表？</strong></li></ol><p>这个问题就涉及到 Server 层和存储引擎的交互了，其实不管怎样，这两者的交互一般都是以记录为单位的，所以一般都是找到一条记录，紧接着就去回表，然后返回给 Server 层，然后 Server 层会向存储引擎拿下一条数据。</p><ol start="2"><li><p><strong>既然是一条一条的记录交互，那范围查询怎么使用到的 B+ 树叶子节点的链表结构的？</strong>（其实是我自己突然想到了这个问题）</p><p>每条记录返回时还带了链表中下一条记录的地址。</p></li><li><p><strong>索引的 B+ 树有几层？</strong></p><p>这个问题，解释起来就比较麻烦。</p><p>首先，Innodb 有页缓存，默认 16 k，换句话说，每次从磁盘读取数据都是 16 k 的读，然后看看下面的图：</p><p><img src="/img/post/B+Tree_index2.png" alt="B+Tree_index2.png"></p></li></ol><p>最上面一层其实是一个节点，4、6、8 之间有颜色的部分指向具体的数据页的地址，数据然后将数据页加载出来，再在内存中查，最终才能找到行数据，而每一页只能读取到 16 kb 的数据。</p><p>在最开始讲到 B+ 树的时候涉及到一个 Degree 的概念，而 Degree 直接影响到了 B+ 树在同样数据量下的深度，Degree 越小，可能层数越大，反之层数越小，层数越小，查询提条数据所要做的 IO 次数就越少，这是个性能问题。</p><p>而 Degree 要怎么决定？</p><p>这个不是配置的，它的值和 <code>innodb_page_size</code> 和索引列的数据类型都有关，比如索引列的类型为 int，4 个字节，16 k = 4096 * 4 byte，也就是说一个索引节点能装 4096 条 int 类型索引列的值。那如果时是 long，8 个字节，那就只有 2048 了，相应的同样的数据量下，long 类型字段的索引树的层数可能就比 int 类型高了，MySQL 一般都只有三层的样子，3 层听起来不多，但是想想 B+ 树的结构，不管是 int 类型还是 long 类型，三层就基本上是三次方的索引数据量，这已经是一个很大的数字了。以 int 举例，大概是 4096 * 4096 * 4096 = 68719476736，数据条数都到了这个数量级了，早分库分表了，所以 3 次的 IO 基本上和 B 树也没多大的性能差别了。</p><p>所以从这一波分析也得出一个答非所问的结论：<strong>索引字段的类型占用空间越小越好。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池-ThreadPoolExecutor原理</title>
      <link href="posts/03055913085b.html"/>
      <url>posts/03055913085b.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/images/202111061349153.png'/><span id="more"></span><h1 id="ThreadPoolExecutor-原理"><a href="#ThreadPoolExecutor-原理" class="headerlink" title="ThreadPoolExecutor 原理"></a>ThreadPoolExecutor 原理</h1><p>上一讲中，从测试的角度了解了 <code>ThreadPoolExecutor</code>，但是并没有透过源码来解释它的运行。</p><p>在开始之前，需要解释一个 <code>ThreadPoolExecutor</code> 核心参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p><code>ctl</code> 算是最核心的控制参数，它是一个 <code>AtomicInteger</code> 类型，支持原子操作的 <code>int</code> 类型，在 Java 中，<code>int</code> 类型有 32 位，4 个字节，<code>ThreadPoolExecutor</code> 将这 32 位的高 3 位用来记录线程池的状态，低 29 位用来记录当前有效的工作线程数。</p><p>内部提供以下方法来解析 <code>ctl</code> 参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="comment">// 通过 ctl 计算当前线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125; <span class="comment">// 通过 ctl 计算当前工作线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125; <span class="comment">// 通过状态和线程数反算 ctl</span></span><br></pre></td></tr></table></figure><h2 id="execute-执行任务"><a href="#execute-执行任务" class="headerlink" title="execute() 执行任务"></a>execute() 执行任务</h2><p>那么，一切就从 <code>ThreadPoolExecutor.execute()</code> 开始吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// 当执行的任务为 null，抛出空指针</span></span><br><span class="line">        <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 比较当前工作线程数和配置的核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="comment">// 新增工作线程</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 走到这里，说明工作线程数已经达到了核心线程数</span></span><br><span class="line">    <span class="comment">// 如果线程池处于运行状态，尝试将新任务放入到缓存工作队列中</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="comment">// 任务成功放入工作队列后再次检测线程池运行状态</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 尝试增加新的线程来执行任务，这里其实就是线程数达到核心线程并且任务队列也已经满了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码中，已经有了注释。总结一下就是：</p><blockquote><ol><li>如果当前线程数还没达到核心线程数，则创建新的工作线程，当前任务作为工作线程的第一个任务执行。</li><li>如果当前工作线程数达到了核心线程数，尝试将任务放到任务的缓存队列中。</li><li>如果放入缓存队列失败，这种一般都是缓存队列也满了，那就尝试增加新的线程来执行当前任务，如果最终创建新的工作线程也失败，那就执行拒绝策略了。</li></ol></blockquote><p>那么接下来再深入婆媳以下 <code>addWorker()</code> 和 <code>reject()</code> 这两个方法。</p><h3 id="增加新的工作线程-addWorker"><a href="#增加新的工作线程-addWorker" class="headerlink" title="增加新的工作线程 addWorker()"></a>增加新的工作线程 addWorker()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也就是说，要么线程池是 RUNNING，要么是 SHUTDOWN 并且任务为 null 且任务队列不为空，</span></span><br><span class="line">        <span class="comment">// 不然直接返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">// 第一种情况，没有限制工作线程数，那么工作线程数上限为 2^32 - 1</span></span><br><span class="line">            <span class="comment">// 第二种情况，根据 core 来决定要不要创建新线程。</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 以 CAS 方式将工作线程数 +1，如果失败，跳转到 retry 重来</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 如果工作线程 +1 后线程池状态发生改变，依然跳转到 retry</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里，已经保证现在创建一个线程后，线程数不会超过核心线程数或者最大线程数（主要还是由方法参数 core 判断）</span></span><br><span class="line">    <span class="comment">// 开始真正创建工作线程</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 对与下增工作线程这个过程加锁，防止并发新建线程导致线程池持有不正确的线程数</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 再次检查线程池状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动工作线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addWorker</code> 方法有两个入参，第一个是 <code>firstWorker</code> ，也就是新线程要执行的第一个任务对象，第二个是 <code>core</code>，用来标识当前调用是否是要创建一个核心线程。</p><p>这里只考虑调用 <code>execute</code> 时创建核心线程和非核心线程的时候，可以知道，当 <code>core==true</code>，如果线程数已经达到 <code>corePoolSize</code>，或者 <code>core==false</code>，且当前线程数达到最大线程数 <code>maximumPoolSize</code>，将会返回 <code>false</code>。</p><h3 id="拒绝处理-reject"><a href="#拒绝处理-reject" class="headerlink" title="拒绝处理 reject()"></a>拒绝处理 reject()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadPoolExecutor</code> 提供了四种拒绝处理策略。</p><ol><li>AbortPolicy 直接抛出 RejectedExecutionException</li><li>CallerRunsPolicy  由调用线程池的线程去执行任务，如果线程池不是 RUNNING 状态，则任务会丢失</li><li>DiscardOldestPolicy 如果线程不是 RUNNING 状态，任务将丢失，如果是 RUNNING 状态，将会丢弃队列中最旧的任务，然后再次尝试执行任务</li><li>DiscardPolicy  直接丢弃任务，不做任何处理</li></ol><p>默认的拒绝处理策略时 <code>AbortPolicy</code>，也就是抛异常。</p><h2 id="工作线程-Worker"><a href="#工作线程-Worker" class="headerlink" title="工作线程 Worker"></a>工作线程 Worker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>thread 当前持有的线程对象</li><li>firstTask 当前执行的任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// 允许中断</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取要执行的任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 处理中断</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁工作线程</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实最终执行任务倒是没什么好讲的，主要是，这段代码里面还涉及到了工作线程的销毁。</p><p><code>runWorker</code> 方法内部通过一个 <code>while</code> 循环一直保持工作线程处于运行状态，但是循环的条件是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>第一个判断是判 worker 当前是否已经有了一个待执行任务，这种情况一般是，线程刚创建，执行第一个任务。</p><p>第二个判断先调用了 <code>getTask()</code> 方法来获取任务，然后才判空，所以接下来主要再看看 <code>getTask()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 最后一次调用工作队列的 poll 是否超时</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line">        <span class="comment">// 如果线程池状态不是运行中，调用了 shutdownNow() 或者工作队列为空，</span></span><br><span class="line">        <span class="comment">// 返回 false，此时需要将工作线程数减一，返回 null，该工作线程将会销毁</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut 用来控制核心线程在空闲一段时间后是否也要销毁，一般为 false</span></span><br><span class="line">        <span class="comment">// 所以这里主要是判断当前工作线程是否需要按照空闲的非核心线程处理，所以判断线程数是否大于核心线程数</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">// 如果线程数大于最大线程数或者需要做线程空闲超时处理</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            <span class="comment">// 在前一个判断的基础上，如果当线程数大于 1 或者工作缓存队列为空，则线程数减一，</span></span><br><span class="line">            <span class="comment">// 返回 null，将会销毁当前工作线程</span></span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里如果 timed 为 true 时，有两种情况</span></span><br><span class="line">            <span class="comment">// 1. 当前请求先任务的线程是核心线程并且核心线程也需要做空闲超时处理（不常用）</span></span><br><span class="line">            <span class="comment">// 2. 当前请求新任务的工作线程是非核心线程</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?                </span><br><span class="line">                <span class="comment">// 以上两种情况，将会调用 poll() 方法，并且有 keepAliveTime 的超时时间，</span></span><br><span class="line">                <span class="comment">// 谨记该时间是初始化线程池时可以构造函数传入的</span></span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                <span class="comment">// 如果不是上述两种情况，那么当前线程数没超过核心线程数，并且核心线程不做空闲超时处理</span></span><br><span class="line">                <span class="comment">// 所以调用 take() 方法获取新任务，该方法会一直阻塞到有新任务到来再返回</span></span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 标识最后一次 poll() 方法超时了，这会使席次循环直接返回 null，</span></span><br><span class="line">            <span class="comment">// 然后在 runWorker() 中销毁工作线程</span></span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码已经加上详细注释，主要还是得明白队列的 <code> poll(long timeout, TimeUnit unit))</code> 和 <code>take()</code> 的用法和区别。</p><p>其次就是还得明白这里面处理处理空闲超时，还优先处理了线程池调用了 <code>shutdown()</code> 和 <code>shutdownNow()</code> 这两种情况。</p><ul><li><p>如果调用了 <code>shutdown()</code> 将不会直接销毁线程，而是尝试让它继续执行任务队列中的任务，最终任务队列为空时才会销毁线程。</p></li><li><p>如果调用的是 <code>shutdownNow()</code>，将直接销毁线程，这样做，将会丢失任务队列中的所有任务。</p></li></ul><p>关于 <code>shutdown()</code> 和 <code>shutdownNow()</code> 的区别将在后面讲解，现在先深挖一下工作线程的销毁。</p><p>当 <code>getTask()</code> 返回 null 时，<code>runWorker()</code> 将会调用 <code>processWorkerExit()</code> 方法来销毁线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 从 workers 中删除当前工作线程的引用，留待 gc 来回收</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试设置线程池状态，这里一般都是销毁最后一个线程池了，不然其实没什么实际效果</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程资源的回收，主要依靠 JVM 的 GC，所以这里只是断开了引用而已，而线程数减一这一步操作其实在 <code>getTask()</code> 方法返回之前就已经做了。</p><h2 id="shutdown-和-shutdownNow"><a href="#shutdown-和-shutdownNow" class="headerlink" title="shutdown() 和 shutdownNow()"></a>shutdown() 和 shutdownNow()</h2><ul><li><p>shutdown()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁，方式并发调用 shutdown()</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 尝试设置状态为 SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 向工作线程发送中断</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 执行一些 shutdown 后的扩展处理</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>shutdownNow()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 尝试设置线程池状态为 STOP</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">//向工作线程发送中断</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 返回未执行的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两者最大的区别在于前者将线程池设置为为 <code>SHUTDOWN</code>，后者将线程池状态设置为 <code>STOP</code> 状态，而对于这两种状态，工作线程会有不同的处理，前面已经讲过了。</p><p>然后就是，因为 <code>shutdown()</code> 会等待线程池将所有任务执行完，而 <code>shutdownNow()</code> 会直接不再执行任务队列中的所有任务，所以为了方便处理，<code>shutdownNow()</code> 将未执行的任务返回。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 线程池</title>
      <link href="posts/b030c9fa77c3.html"/>
      <url>posts/b030c9fa77c3.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/images/202111061349789.png'/><span id="more"></span><p>之前有写过一篇讲 Executor 框架的，最近发现其实讲的不是很清晰，只是介绍了分别有什么特性，而没有真正的使用。</p><p>所以这一篇的宗旨是 <code>talk is cheap, show me the code</code>。</p><p>JDK 提供了原生的 <code>Executor</code> 接口，下面有很多的可以管理线程池的实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Executes the given command at some time in the future.  The command</span><br><span class="line">     * may execute in a new thread, in a pooled thread, or in the calling</span><br><span class="line">     * thread, at the discretion of the &#123;@code Executor&#125; implementation.</span><br><span class="line">     *</span><br><span class="line">     * @param command the runnable task</span><br><span class="line">     * @throws RejectedExecutionException if this task cannot be</span><br><span class="line">     * accepted for execution</span><br><span class="line">     * @throws NullPointerException if command is null</span><br><span class="line">     */</span><br><span class="line">    void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Executor</code> 接口提供了一个 <code>execute</code> 方法，入参是一个 <code>Runnable</code> 作为要执行的任务，方法执行时允许抛出一个 <code>RejectedExecutionException</code>，在接口的具体实现类中可以定义对这个异常的处理。</p><p><code>Executor</code> 主要的实现 <code>ThreadPoolExecutor</code> 和 <code>ScheduleThreadPoolExecutor</code> 两种，<code>ScheduleThreadPoolExecutor</code> 是 <code>ThreadPoolExecutor</code> 的子类。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><p>上面是 ThreadPoolExecutor 覆盖主要参数最齐全的构造函数。</p><ul><li><p>corePoolSize </p><p>线程池核心线程数，线程池并不是创建的时候就会创建很多个线程，而是在执行任务的时候才会开始创建，每次执行一个新的任务时，如果当前线程数小于核心线程池数，就选择建立一个新的线程来执行这个任务。</p></li><li><p>maximumPoolSize</p><p>线程池最大线程数，当线程创建得越来越多，为了避免资源占用过高，所以设置了最大的线程数，线程池中的线程数不会超过这个值。</p></li><li><p>keepAliveTime</p><p>线程池中空闲线程的存活时间。就像电商平台一样，可能有时候会有访问的高峰期，很多请求过来的时候，会创建很多的线程，但是当高峰期过了之后，可能就只需要几个线程就能处理所有请求，此时，为了避免资源浪费，需要释放掉其他的空闲状态的线程，当一个线程空闲时间超过 <code>keepAliveTime</code> 时，该线程就会关闭，资源释放。</p></li><li><p>unit</p><p><code>keepAliveTime</code> 的时间单位。</p></li><li><p>threadFactory</p><p>线程工厂，这个工厂会用来创建线程池的工作线程，一般都会在这里对每个线程进行命名，方便追踪线程的执行。</p></li><li><p>handler</p><p>是一个 RejectedExecutionHandler 接口。在最前面讲到 <code>Executor#execute</code> 方法时，讲到它可能会抛出 <code>RejectedExecutionException</code> 异常，而这个异常默认时不做任何处理，直接抛出来的。RejectedExecutionHandler 就是在抛出 <code>RejectedExecutionException</code> 异常时，调用的异常处理逻辑。</p></li><li><p>workQueue</p><p><code>BlockingQueue&lt;Runnable&gt;</code> 类型的阻塞队列。主要分为以下几种：</p><ol><li><code>ArrayBlockingQueue</code> 基于数组实现的有界队列，遵循先进先出（FIFO）原则，队列一旦创建，不能再更改大小，当队列满了的时候，调用 <code>put</code> 会阻塞，当队列是空队列时，调用 <code>take</code> 也会阻塞队列。</li><li><code>LinkedBlockingQueue</code> 基于链表实现的无界队列，这里无界的意思是容量上限为 <code>Integer.MAX_VALUE</code>，同样也遵循 <code>FIFO</code> 原则。</li><li><code>SynchronousQueue</code> 内部没有实际订单容量的队列，只有当一个线程在这个队列上调用了 <code>remove</code> 方法后，其他线程才可以调用 <code>put</code> 方法，否则会阻塞。</li><li><code>PriorityBlockingQueue</code> 优先级队列。</li></ol></li></ul><p>解释完了 <code>ThreadPoolExecutor</code> 的主要参数，现在尝试通过它创建一个线程池。</p><ul><li><p>创建一个 <code>corePoolSize=3, maximumPoolSize=5</code> 的线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">20</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), </span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">MyThreadFactory</span>(), </span><br><span class="line">                           (r, executor) -&gt; &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;exception handle, poolSize is: &quot;</span> + executor.getPoolSize());</span><br><span class="line">          System.out.println(<span class="string">&quot;exception handle: queueSize is&quot;</span> + executor.getQueue().size());</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line"><span class="comment">// 为每一个线程命名，方便追踪</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;thread-&quot;</span> + threadNumber++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面创建了一个核心线程数为 3，最大线程数为 5 的线程池，线程最大空闲时间为 20 秒，任务缓存使用了 <code>ArrayBlockingQueue</code>，可缓存数为 10，创建线程的工厂 <code>MyThreadFactory</code> 只是对每个工作线程命名，对与抛出 <code>RejectedExecutionException</code>，只是打印当前线程池中工作线程数和队列中缓存任务数。</p><p>下面通过一个测试来探索一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorTest</span> &#123;</span><br><span class="line">  <span class="comment">/** 线程编号 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 后续例子中，只展示 main 方法，其他部分代码默认不变</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MyThreadFactory</span>(),</span><br><span class="line">            (r, executor) -&gt; &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;exception handle, poolSize is: &quot;</span> + executor.getPoolSize());</span><br><span class="line">              System.out.println(<span class="string">&quot;exception handle, queueSize is:&quot;</span> + executor.getQueue().size());</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      threadPoolExecutor.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;poolSize is: &quot;</span> + threadPoolExecutor.getPoolSize());</span><br><span class="line">    System.out.println(<span class="string">&quot;queueSize is:&quot;</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 线程工厂，主要是命名线程</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;thread-&quot;</span> + threadNumber++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工作线程，启动先 sleep 5 秒，然后打印当前线程名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">poolSize is: 3</span><br><span class="line">queueSize is:7</span><br><span class="line">thread-2</span><br><span class="line">thread-3</span><br><span class="line">thread-1</span><br><span class="line">thread-2</span><br><span class="line">thread-1</span><br><span class="line">thread-3</span><br><span class="line">thread-3</span><br><span class="line">thread-1</span><br><span class="line">thread-2</span><br><span class="line">thread-3</span><br></pre></td></tr></table></figure><p>通过日志看到，当有 10 个任务放进线程池之后，线程池中的工作线程数依然是 3，不过任务队列中有 7 个待执行的任务，此时任务缓存还没被填满。</p><p>然后，现在将要执行的任务数量改为 14：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">          <span class="number">3</span>,</span><br><span class="line">          <span class="number">5</span>,</span><br><span class="line">          <span class="number">20</span>,</span><br><span class="line">          TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">MyThreadFactory</span>(),</span><br><span class="line">          (r, executor) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;exception handle, poolSize is: &quot;</span> + executor.getPoolSize());</span><br><span class="line">            System.out.println(<span class="string">&quot;exception handle, queueSize is:&quot;</span> + executor.getQueue().size());</span><br><span class="line">          &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;poolSize is: &quot;</span> + threadPoolExecutor.getPoolSize());</span><br><span class="line">  System.out.println(<span class="string">&quot;queueSize is:&quot;</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">  threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">poolSize is: <span class="number">4</span></span><br><span class="line">queueSize is:<span class="number">10</span></span><br><span class="line">thread-<span class="number">3</span></span><br><span class="line">thread-<span class="number">1</span></span><br><span class="line">thread-<span class="number">2</span></span><br><span class="line">thread-<span class="number">4</span></span><br><span class="line">thread-<span class="number">2</span></span><br><span class="line">thread-<span class="number">1</span></span><br><span class="line">thread-<span class="number">3</span></span><br><span class="line">thread-<span class="number">4</span></span><br><span class="line">thread-<span class="number">1</span></span><br><span class="line">thread-<span class="number">3</span></span><br><span class="line">thread-<span class="number">2</span></span><br><span class="line">thread-<span class="number">4</span></span><br><span class="line">thread-<span class="number">1</span></span><br><span class="line">thread-<span class="number">3</span></span><br></pre></td></tr></table></figure><p>可以看见，当任务数为 14 时，因为有 3 个任务由核心线程在执行，还剩 11 个任务待执行，而任务缓存队列是 <code>ArrayBlockingQueue</code> 类型的有界队列，创建时已经初始化容量为 10 不可更改，放入任务队列缓存后，还剩下一个任务，此时工作线程数为 3，小于最大线程数，所以选择创建一个新的线程来执行任务，所以最终输出的工作线程数为 4，而队列大小为 10。</p><p>通过上面两次试验可以知道，<strong>线程池在执行任务时，会尽量只开启 corePoolSize 个线程来执行任务；当待执行任务数大于了核心线程数时，会将剩余的任务放到缓存队列中；如果任务队列为有界队列，当队列满了且有新的待执行任务到来时，如果工作线程数还未达到最大值，会创建一个新的线程来执行任务。</strong></p><p>那么，如果工作线程数达到最大并都处于执行任务的状态中，且任务队列满了，此时如果有新的任务放入线程池会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">          <span class="number">3</span>,</span><br><span class="line">          <span class="number">5</span>,</span><br><span class="line">          <span class="number">20</span>,</span><br><span class="line">          TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">MyThreadFactory</span>(),</span><br><span class="line">          (r, executor) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;exception handle, poolSize is: &quot;</span> + executor.getPoolSize());</span><br><span class="line">            System.out.println(<span class="string">&quot;exception handle, queueSize is:&quot;</span> + executor.getQueue().size());</span><br><span class="line">          &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;poolSize is: &quot;</span> + threadPoolExecutor.getPoolSize());</span><br><span class="line">  System.out.println(<span class="string">&quot;queueSize is:&quot;</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">  threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">exception handle, poolSize is: 5</span><br><span class="line">exception handle, queueSize is:10</span><br><span class="line">poolSize is: 5</span><br><span class="line">queueSize is:10</span><br><span class="line">thread-4</span><br><span class="line">thread-2</span><br><span class="line">thread-3</span><br><span class="line">thread-5</span><br><span class="line">thread-1</span><br><span class="line">thread-5</span><br><span class="line">thread-3</span><br><span class="line">thread-2</span><br><span class="line">thread-1</span><br><span class="line">thread-4</span><br><span class="line">thread-2</span><br><span class="line">thread-4</span><br><span class="line">thread-1</span><br><span class="line">thread-5</span><br><span class="line">thread-3</span><br></pre></td></tr></table></figure><p>将任务数改为 16 后，刚好出现了上述问题锁描述的情况。通过输出日志可以看到，此时触发了 <code>RejectedExecutionException</code> 异常的处理逻辑，也就是说，**当工作线程数达到最大并都处于执行任务的状态中，且任务队列满了，此时如果有新的任务放入线程池，会抛出 <code>RejectedExecutionException</code>**。</p><p>接下来，在测试一下线程的销毁时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">          <span class="number">3</span>,</span><br><span class="line">          <span class="number">5</span>,</span><br><span class="line">          <span class="number">10</span>,</span><br><span class="line">          TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">MyThreadFactory</span>(),</span><br><span class="line">          (r, executor) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;exception handle, poolSize is: &quot;</span> + executor.getPoolSize());</span><br><span class="line">            System.out.println(<span class="string">&quot;exception handle, queueSize is:&quot;</span> + executor.getQueue().size());</span><br><span class="line">          &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;poolSize is: &quot;</span> + threadPoolExecutor.getPoolSize());</span><br><span class="line">  System.out.println(<span class="string">&quot;queueSize is:&quot;</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 休眠 26 秒，等待空闲线程释放资源</span></span><br><span class="line">    Thread.sleep(<span class="number">26000</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;poolSize is: &quot;</span> + threadPoolExecutor.getPoolSize());</span><br><span class="line">  threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面将线程空闲时间改为 10 秒，并且在所有任务提交后，休眠 26 秒，以等待空闲线程销毁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">poolSize is: 5</span><br><span class="line">queueSize is:10</span><br><span class="line">thread-5</span><br><span class="line">thread-3</span><br><span class="line">thread-1</span><br><span class="line">thread-2</span><br><span class="line">thread-4</span><br><span class="line">thread-5</span><br><span class="line">thread-3</span><br><span class="line">thread-4</span><br><span class="line">thread-1</span><br><span class="line">thread-2</span><br><span class="line">thread-5</span><br><span class="line">thread-3</span><br><span class="line">thread-4</span><br><span class="line">thread-2</span><br><span class="line">thread-1</span><br><span class="line">poolSize is: 3</span><br></pre></td></tr></table></figure><p>通过日志看出，线程池工作线程数达到最大值以后并执行完了所有任务。先算算时间，一共 15 个任务，5 个线程执行，每个任务执行 5 秒，所以理论上需要 15 秒就可以执行完所有任务，所以理论上主线程休眠 15 + 10 = 25 秒就可以看到工作线程数变为 3，但考虑到线程切换也需要少许时间，所以 sleep 的时间需要大于 25 秒。最终的结果也如配置一样， 10 秒后，多余的线程被销毁。</p><p>然后，还有一个问题，在上面所有例子中，最开始的 3 个核心工作线程，什么时候创建的？此时只需要将任务调到小于核心线程数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">          <span class="number">3</span>,</span><br><span class="line">          <span class="number">5</span>,</span><br><span class="line">          <span class="number">10</span>,</span><br><span class="line">          TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">MyThreadFactory</span>(),</span><br><span class="line">          (r, executor) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;exception handle, poolSize is: &quot;</span> + executor.getPoolSize());</span><br><span class="line">            System.out.println(<span class="string">&quot;exception handle, queueSize is:&quot;</span> + executor.getQueue().size());</span><br><span class="line">          &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;poolSize is: &quot;</span> + threadPoolExecutor.getPoolSize());</span><br><span class="line">  System.out.println(<span class="string">&quot;queueSize is:&quot;</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">  threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">poolSize is: 2</span><br><span class="line">queueSize is:0</span><br><span class="line">thread-1</span><br><span class="line">thread-2</span><br></pre></td></tr></table></figure><p>从输出可以知道，当任务数小于核心工作线程数时，工作线程数和任务数相等，由此可以的当结论，<strong>核心线程不是初始化线程池时创建，而是有任务提交时动态创建，只要当线程数小于核心线程数，就无条件创建新的工作线程。</strong></p><p>在上面的所有例子中，都会调用 <code>threadPoolExecutor.shutdown()</code> 方法来关闭线程池，但是在主线程中没有 sleep，而是提交了任务后直接就 <code>shutdown</code>，而最终所有任务都执行了，这说明，**<code>shutdown()</code> 方法会等待所有任务执行完之后才会真正的关闭线程池。**</p><p>最后一个问题，如果在调用 <code>shutdown()</code> 之后，线程池正真关闭之前，再提交任务会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">          <span class="number">3</span>,</span><br><span class="line">          <span class="number">5</span>,</span><br><span class="line">          <span class="number">10</span>,</span><br><span class="line">          TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">MyThreadFactory</span>(),</span><br><span class="line">          (r, executor) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;exception handle, poolSize is: &quot;</span> + executor.getPoolSize());</span><br><span class="line">            System.out.println(<span class="string">&quot;exception handle, queueSize is:&quot;</span> + executor.getQueue().size());</span><br><span class="line">          &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;poolSize is: &quot;</span> + threadPoolExecutor.getPoolSize());</span><br><span class="line">  System.out.println(<span class="string">&quot;queueSize is:&quot;</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">  </span><br><span class="line">  threadPoolExecutor.shutdown();</span><br><span class="line">  System.out.println(<span class="string">&quot;-----------shutdown-------&quot;</span>);</span><br><span class="line">  threadPoolExecutor.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">poolSize is: 2</span><br><span class="line">queueSize is:0</span><br><span class="line">-----------shutdown-------</span><br><span class="line">exception handle, poolSize is: 2</span><br><span class="line">exception handle, queueSize is:0</span><br><span class="line">thread-2</span><br><span class="line">thread-1</span><br></pre></td></tr></table></figure><p>通过日志可以得到结论，<strong>在 <code>shutdown()</code> 后在提交任务会抛出 <code>RejectedExecutionException</code>，触发异常处理逻辑。</strong></p></li></ul><p>终于，将 <code>ThreadPoolExecutor</code> 的基本流程搞明白了，关于内部的一些原理，就在下一篇文章中在讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态代理和动态代理</title>
      <link href="posts/b8f5ebf685e8.html"/>
      <url>posts/b8f5ebf685e8.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/images/202111061313856.png'/><span id="more"></span><p>在使用了很久的 Spring 之后，当有人问到 Spring 有什么特性时，肯定毫不犹豫就回答到依赖注入和面向切面编程，这篇文章暂且不论依赖注入的原理，只谈谈面向切面编程。</p><p>在这之前，先来看一个的业务场景：</p><p>现在我们一个接口（这里特指 Java 里面的 interface 关键字），执行的时候，我想将它的入参和返回都打印到日志中记录，做法或许是这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ProductService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ProductServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">query</span><span class="params">(ProductId productId)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;productService 入参: &#123;&#125;&quot;</span>, productId);</span><br><span class="line">        <span class="keyword">return</span> query(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子可能举得不是很具有普适性，但足以说明问题。</p><p>需要知道的是，这里局的例子是要打印日志，那如果我还想要做更多的与业务无关的事，难道都写在这里吗？为了使编码的过程更关注于业务，这样的做法不合适，而且当有新人来到项目组来看这样一段代码时还会疑惑，这个跟业务没关系为什么也写在这里。</p><p>那么，要如何做到将这段日志逻辑与实际的业务逻辑分离？</p><p>熟悉 Spring 的同学都知道这样的直接使用 AOP 拦截就行了。</p><p>那如果我不会 AOP 怎么办？那就只能静态代理。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理类似装饰器模式，就是对要代理的对象再封装一层代理，以上面的 ProductService 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ProductService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">query</span><span class="params">(ProductId productId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> query(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">ProductService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ProductServiceProxy.class);</span><br><span class="line">    <span class="keyword">private</span> ProductServiceImpl productService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">query</span><span class="params">(ProductId productId)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;productService 入参: &#123;&#125;&quot;</span>, productId);</span><br><span class="line">        <span class="keyword">return</span> productService.query(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理上其实就是新建一个实现同样的接口的 <code>ProductServiceProxy</code> 类，该类持有 <code>ProductServiceImpl</code> 的实例引用，调用查询的时候其实通过 <code>ProductServiceProxy</code> 调用而不是直接调用 <code>ProductServceImpl</code>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>因为是封装一层，所以不用修改原来的业务实现代码。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>会有很多业务无关的代理类，如果出现很多的接口都需要额外的同样的操作的情况，会发现很多代理类的内容都是一样的（其实很多时候就是这样的），甚至当有一天要变动这部分逻辑的时候，要修改的代理类也是很多的。不易于维护。</p><p>所以接下来才用到动态代理。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>目前的动态代理解决方案分为两种：</p><ol><li><p>JDK 动态代理</p><p>JDK 原生支持的特性，只能代理接口的实现类，如果没有实现任何接口，那就不能被代理。</p></li><li><p>Cglib 动态代理</p><p>需要引入第三方 jar 包，普通类和实现类都能代理。</p></li></ol><p>下面将以 ProductService 作为基础来演示两种代理方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(String productId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">(String productId)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;search product by id:&quot;</span> + productId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><ol><li>代理实现：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object targetObject;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取一个代理对象</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">newProxyInstance</span><span class="params">(Object targetObject)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.targetObject = targetObject;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">        targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Jdk dynamic proxy, call method &quot;</span> + method.getName() + <span class="string">&quot; before&quot;</span>);</span><br><span class="line">        result = method.invoke(targetObject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;Jdk dynamic proxy, call method &quot;</span> + method.getName() + <span class="string">&quot; after&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">JdkProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkProxy</span>();</span><br><span class="line">    <span class="type">ProductServiceImpl</span> <span class="variable">productService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductServiceImpl</span>();</span><br><span class="line">    <span class="type">ProductService</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (ProductService) proxy.newProxyInstance(productService);</span><br><span class="line">    proxyInstance.search(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">// 测试代理类是否是 ProductService 的实现类</span></span><br><span class="line">    System.out.println(proxyInstance.getClass().getInterfaces()[<span class="number">0</span>].getName());</span><br><span class="line">    <span class="comment">// 测试代理类是否是 ProductServiceImpl 的实例</span></span><br><span class="line">    System.out.println(proxyInstance <span class="keyword">instanceof</span> ProductServiceImpl);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Jdk dynamic proxy, call method search before</span><br><span class="line">search product by id:111</span><br><span class="line">Jdk dynamic proxy, call method search after</span><br><span class="line">org.hanelalo.proxy.ProductService</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>从最后两行输出可以知道，代理类其实是实现了和被代理类同样的接口，并不是被代理类的子类，Debug 也可以发现，这个代理类对象中持有一个 ProductServiceImpl 的实例，而这个实例就是在 <code>proxy.newProxyInstance()</code> 中传入的对象。</p><p><img src="https://hanelalo.github.io/img/post/jdk-dynamic-proxy-debug.png" alt="JDK 动态代理 Debug"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>JDK 动态代理通过生成一个实现与被代理类相同接口的方式来实现动态代理，比静态代理灵活。同时，也受限与实现方式，导致 JDK 动态代理只能代理接口实现类，而不能代理没有实现任何接口的类。</p><h3 id="基于-Cglib-的动态代理"><a href="#基于-Cglib-的动态代理" class="headerlink" title="基于 Cglib 的动态代理"></a>基于 Cglib 的动态代理</h3><p>Cglib 本身只是一个字节码生成器，动态代理可以使用它来实现而已，这个概念之前混淆了，现在才明白。</p><p>Cglib 开源项目地址：<a href="https://github.com/cglib/cglib">https://github.com/cglib/cglib</a></p><p>同样还是以前面的 ProductService 为例。</p><ol><li>实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object targetObject;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个 Cglib 代理的实例</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">newProxyInstance</span><span class="params">(Object object)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.targetObject = object;</span><br><span class="line">    <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">    enhancer.setSuperclass(object.getClass());</span><br><span class="line">    enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> enhancer.create();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span></span><br><span class="line">      <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Cglib dynamic proxy, call method &quot;</span> + method.getName() + <span class="string">&quot; before&quot;</span>);</span><br><span class="line">      result = methodProxy.invoke(targetObject, objects);</span><br><span class="line">      System.out.println(<span class="string">&quot;Cglib dynamic proxy, call method &quot;</span> + method.getName() + <span class="string">&quot; after&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">CglibProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line">    <span class="type">ProductServiceImpl</span> <span class="variable">productService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductServiceImpl</span>();</span><br><span class="line">    <span class="type">ProductService</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (ProductService) proxy.newProxyInstance(productService);</span><br><span class="line">    proxyInstance.search(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">// 测试代理类是否是 ProductService 的实现类</span></span><br><span class="line">    Arrays.stream(proxyInstance.getClass().getInterfaces())</span><br><span class="line">        .forEach(inter -&gt; System.out.println(inter.getName()));</span><br><span class="line">    <span class="comment">// 测试代理类是否是 ProductServiceImpl 的实例</span></span><br><span class="line">    System.out.println(proxyInstance <span class="keyword">instanceof</span> ProductServiceImpl);</span><br><span class="line">    <span class="comment">// 打印出代理类的 class 信息</span></span><br><span class="line">    System.out.println(proxyInstance.getClass());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cglib dynamic proxy, call method search before</span><br><span class="line">search product by id:<span class="number">111</span></span><br><span class="line">Cglib dynamic proxy, call method search after</span><br><span class="line">org.springframework.cglib.proxy.Factory</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.hanelalo.proxy.ProductServiceImpl$$EnhancerByCGLIB$$42eb8c39</span><br></pre></td></tr></table></figure><p>通过输出日志可以看见代理成功，但是代理类并不是 ProductService 的实现类，却又是 ProductServiceImpl 的实例，但其实又不同同一个 Class 对象的实例，这只能说明代理类是被代理类的子类了，也就是说， Cglib 实现的动态代理其实是添加了一个被代理类的子类，通过<strong>继承</strong>方式，使用 Java 多态的特性，实现了代理。</p><p>既然是通过继承关系实现的动态代理，那么按照 Java 的设计，Cglib 就不能代理以 final 修饰的类，但是对普通类中 final 修饰的方法进行增强还是可以的。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>Cglib 本身是一个字节码生成器，只不过 AOP 依托于它才实现了动态代理。</p><p>Spring AOP 使用 Cglib 做动态代理，因为是基于继承关系实现，所以不管是否是接口实现类都可以代理，但同时也是因为继承关系，Cglib 实现的 AOP 功能不能代理 final 修饰的类。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记（一）</title>
      <link href="posts/029a84da15fd.html"/>
      <url>posts/029a84da15fd.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-学习笔记（一）"><a href="#Redis-学习笔记（一）" class="headerlink" title="Redis 学习笔记（一）"></a>Redis 学习笔记（一）</h1><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Redis 提供了两种持久化策略，AOF 和 RDB，AOF 是直接保存服务器保存的指令，服务器启动时再重新执行这些指令即可，而 RDB 则是保存一份内存的二进制快照，Redis 启动时加载，如果服务器开启了 AOF 功能，会优先加载 AOF 的文件，如果没开启 AOF 功能，才会加载 RDB 文件。</p><h3 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h3><p>AOF 持久化是以命令请求的方式保存，AOF 分为命令追加、文件写入、文件同步三个步骤。</p><ol><li><p>命令追加。AOF 配置打开时，每执行完一个写命令之后，这次命令执行会以协议格式写到 aof_buf 缓冲区。</p></li><li><p>文件写入与同步。Redis 的进程从实现上是一个事件循环，这个循环中文件事件负责接收客户端命令请求和回复命令，时间事件执行一些定时任务，比如定期删除过期键。每次文件事件可能会处理一些写命令请求，就可能会有新的内容写入到 aof_buf 中，所以每个事件循环之后，都会考虑是否要将 aof_buf 中的内容写入到磁盘文件中。而在将 aof_buf 中的内容持久化时，根据<code>appendfsync</code>配置又会有不同的行为，在讲解<code>appendfsync</code>配置之前，先了解一下文件同步，现代操作系统在写入文件时，其实并不是调用写方法就真的写到文件里去，为了提高性能，采取按页存储的策略，当要写入的数据达到一定的大小时才真正的写到磁盘文件中，在此之前其实是将数据保存在缓存中，这个缓存叫做 PageCache，前面讲的文件写入，其实是将文件内容从 aof_buf 写入到了 PageCache，而同步的意思就是从 PageCache 将文件内容写入到真正的文件磁盘中。接下来看看<code>appendfsync</code>这项配置的说明及其特性：</p><ul><li><p>always</p><p>将 aof_buf 中所有内容写入 PageCache 并同步到 AOF 文件中。因此 always 是三种配置种效率最低的一个，但是也因为是实时写入和同步的，安全性也是最高的。</p></li><li><p>everysec</p><p>将 aof_buf 中的内容写入 AOF 文件的 PageCache 中，如果当前距离上次同步文件超过 1 秒，则同步文件，这个动作由单独的线程完成。因为并不是每个事件循环都会同步，所以效率上比 always 快，就算故障停机，也只会丢失 1 秒的数据而已，安全性也还在可接受的范围内。</p></li><li><p>no</p><p>仅仅只是将 aof_buf 中的内容写入到 PageCache 中，不主动同步，何时同步交由操作系统决定。因为该模式下无需执行同步操作，所以效率是最快的，但是因为同步依赖于操作系统的判断，所以该模式的同步时间也是三种模式种最长的，并且安全性也不如前两种，如果不小心故障停机，会丢失上次同步之后的所有数据。</p></li></ul></li></ol><h4 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h4><p>因为 AOF 是以命令请求的方式存储，当 AOF 中的文件的内容越来越多时，文件越来越大，可能会造成一些意想不到的问题，为避免一些不必要的文件膨胀，Redis 提供了文件重写的功能。这个功能具体有什么作用呢？</p><p>举个例子，假如 redis 连续执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH list <span class="string">&quot;A&quot;</span> <span class="string">&quot;B&quot;</span></span><br><span class="line">redis&gt; RPUSH list <span class="string">&quot;C&quot;</span></span><br><span class="line">redis&gt; RPUSH list <span class="string">&quot;D&quot;</span></span><br></pre></td></tr></table></figure><p>三条命令都是向 list 里面加入一个元素，按照前面对 AOF 的理解，会保存三条命令请求的记录到 AOF 文件中，但是仔细想想，其实只需要保存一条命令请求就行了，一条命令将上面三条命令的内容全都写入，其实这就是重写的原理了。</p><p>执行 AOF 重写的指令是<code>BGREWRITEAOF</code>。</p><p>AOF 重写的时候并不是读取已经存在的 AOF 文件再进行重写，而是直接将当前内存中各个键值对最新的值以命令请求的方式保存。</p><p>这里还会涉及到一个问题，就是缓冲区溢出的问题，如果一个键值对的内容很多的时候，比如哈希表、列表等，不加限制的话，可能会造成客户端的缓冲区溢出，所以 Redis 设定了保存的每条指令的大小，当一条指令的内容超过这个阈值时，就会使用新的指令记录剩下的内容。</p><p>当执行 AOF 重写时，会阻塞当前的线程，所以 Redis 将这个指令的执行放到了子进程里面，当子进程执行重写的时候，如果服务器的服务进程又处理了写命令的请求，就会导致子进程重写完之后的结果和现在的内存实际的数据不一致。</p><p>为了解决上面的问题，Redis 又提供了一个重写的缓冲区，在创建子进程执行重写开始，服务器接受的写命令，不仅会写入到 AOF 缓冲区，还会写入到 AOF 重写缓冲区，当子进程执行完之后，会通知父进程将 AOF 重写缓冲区的内容写入并同步到 AOF 重写的文件中，然后再将重写的文件改名，覆盖之前的 AOF 文件，整个过程中，父进程只在将重写缓冲区的内容写入和同步到文件以及改名时会阻塞，其他时候都可以正常处理请求。</p><p>经过上面的讲解，其实 AOF 重写后的文件肯定是比普通的 AOF 持久化文件要小很多的，毕竟对指令进行了“压缩”。</p><h3 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h3><p>RDB 持久化策略，是将当前内存中的键值对以二进制的形式保存到磁盘，Redis 启动时会自动加载 RDB 文件。</p><p>要通过 RDB 的方式持久化，执行的命令是 <code>SAVE</code> 或者 <code>BGSAVE</code>，这两者的区别在于，<code>SAVE</code>会阻塞服务器进程，指令执行过程中，服务器不能处理任何指令请求，而<code>BGSAVE</code>则是派生一个子进程来持久化，父进程继续处理指令请求。</p><p>因为 BGSAVE 是交由子进程执行，不会阻塞父进程处理命令请求，所以 redis 提供了<code>save</code> 配置项，用来配置自动执行<code>BGSAVE</code>。</p><p>以官方提供的配置为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>这三行配置的意思分别是：</p><ul><li>900 秒内至少进行了 1 次修改，则执行<code>BGSAVE</code></li><li>300 秒内至少进行了 10 次修改，则执行<code>BGSAVE</code></li><li>60 秒内至少执行了 1000 次修改，则执行<code>BGSAVE</code></li></ul><h2 id="Redis-过期键删除策略"><a href="#Redis-过期键删除策略" class="headerlink" title="Redis 过期键删除策略"></a>Redis 过期键删除策略</h2><p>解决方案分为三种：</p><ul><li><p>定时删除</p><p>为每个设置过期时间的键建立一个定时器，到时间就删除该键。如果为每个有时效的键都建立一个定时器，那么当过期键数量到达一定量级时，就算内存充裕，就会造成 CPU 资源的紧张。</p></li><li><p>惰性删除</p><p>当键过期时先不管，访问键时，再判断当前键是否过期，过期就执行删除逻辑，没过期就返回值，这种策略对 CPU 来说很友好，但是如果一个过期键长期不被访问，就会长期存在于内存中，当这样的键较多时，就会造成内存的浪费。</p></li><li><p>定期删除</p><p>设定一个时间周期，每隔一个时间周期对数据库检查一次，删除里面的过期键。从定时删除和惰性删除的介绍来看，都并不是很完美，总会顾此失彼，定时删除对 CPU 不友好，惰性删除可能对内存不是很友好，定时删除则更像是两者折中的策略，既不会造成很大的内存浪费，也不用建立很多定时器对 CPU 造成很大压力。</p></li></ul><p>Redis 采用的是<strong>惰性删除+定期删除</strong>的组合策略。</p><h3 id="RDB-和-AOF-对过期键的处理"><a href="#RDB-和-AOF-对过期键的处理" class="headerlink" title="RDB 和 AOF 对过期键的处理"></a>RDB 和 AOF 对过期键的处理</h3><p>在之前讲过 RDB 和 AOF 两种持久化方案，那么这两种持久化方案针对过期键会怎么处理呢。主要关注以下三个问题：</p><ol><li><p><strong>RDB 和 AOF 在持久化时，如何处理过期键？</strong></p><p>RDB 在持久化时，会对过期键检查，过期的键不会持久化到二进制文件中。</p><p>AOF 持久化时，并不会查看键是否过期，但是因为 AOF 会记录每个写指令，所以当键过期后，惰性删除或者定时删除时，肯定会有一个删除过期键的指令，这个指令也会被显式记录到 AOF 文件中。</p></li><li><p><strong>RDB 和 AOF 在加载时，如何处理过期键？</strong></p><p>当 RDB 文件加载时，如果  redis 运行在复制模式下，那么主服务器不会加载已经过期的键，从服务则全部都会加载，但是主从同步的时候，因为主服务器上已经没有了过期键，所以从服务器上过期的键也会被同步掉。</p></li><li><p><strong>AOF 重写时，如何处理过期键？</strong></p><p>AOF 重写和 RDB 持久化一样，会忽略掉过期键。</p></li></ol><h3 id="主从复制对过期键的处理"><a href="#主从复制对过期键的处理" class="headerlink" title="主从复制对过期键的处理"></a>主从复制对过期键的处理</h3><p>主服务器接收到读请求时，会检查键是否过期，过期则删除键，并向从服务器发送删除指令，使从服务器上的过期键也被删除。</p><p>但是如果读指令发送到了从服务器，从服务器并不会检查键是否过期，而是直接返回键的值，直到接收到主服务器发来的删除该过期键的指令之后，从服务器上的过期键才会被删除。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>redis 主从复制有两个版本，一个是 redis 2.8 以前的版本，一个是从 redis 2.8 开始的版本。</p><p>不管是新的还是旧的版本，对于主从复制大方向上考虑两种情况：</p><ul><li>从服务器第一次和主服务器同步数据</li><li>从服务器和主服务器断开连接一段时间后，重新连接时同步数据</li></ul><p>不管哪种情况，都是为了保证主从服务器上的数据一致性，所以当主服务器执行了写命令时，会发生命令传播，就是主服务器会向所有从服务器发送刚刚执行的写指令，保证数据一致性。</p><p><strong>那么 redis 2.8 以前的版本和新版本的区别在哪里？</strong></p><p><em>先看看 redis 2.8 以前的版本：</em></p><p>当从服务器第一次向主服务器同步数据。</p><ol><li>向主服务器发送一条 <code>SYNC</code> 指令。</li><li>主服务器收到 <code>SYNC</code> 指令后，执行 <code>BGSAVE</code> 生成 RDB 文件，同时生成一个缓冲区记录从执行 <code>BGSAVE</code> 开始执行的所有写命令。</li><li>主服务器生成 RDB 后，将 RDB 文件发送给从服务器。</li><li>从服务器载入接收到了 RDB 文件到内存。</li><li>主服务器将刚生成的缓冲区中的指令发送给从服务器，从服务器执行后，和主服务器的数据达成一致。</li></ol><p>执行完以上步骤，当主服务器再接受到写指令时，会向从服务器也发送一次相同的指令，保证数据一致。</p><p>如果从服务器和主服务器意外断开连接，再重新连接时，会再次执行上面所有步骤，虽然最终达到了数据一致，但是其实没必要这样做，因为如果断开连接之前的数据，从服务器有持久化，那重新连接时其实只需要同步在断开连接期间主服务器进行的修改即可。</p><p>所以旧版复制实现，在重连时，效率不够。</p><p><em>在 redis 2.8 开始，实现了新的复制方式。</em></p><p>redis 2.8 版本开始的复制实现，依靠 <code>PSYNC</code> 命令。</p><p><code>PSYNC</code> 有两种模式，一种时完整重同步，是针对从服务器第一次同步数据的实现，一种是部分重同步，针对从服务器断开重连的实现。</p><p>针对第一次同步数据的情况，也就是完整重同步，和 <code>SYNC</code> 一样的处理。</p><p>如果是断开重连的情况，触发的就是部分重同步，这里涉及到一个复制偏移量的概念，主服务器会记录当前已经被从服务器同步的偏移量，从服务器也会记录自己的同步偏移量，断开重连后，当主从偏移量不一致时，就复制偏差的这部分数据就好了。</p><p>举个例子，最开始主服务器 M 复制偏移量为 10000，从服务器 A、B、C 的偏移量也是 10000，此时主从数据一致，然后从服务器 A 和主服务器断开连接，此后，主服务器执行了写指令，发生指令传播，B、C 从服务器复制成功，M、B、C 三台服务器的偏移量变为 10033，然后  A 服务器恢复连接，此时和主服务器有 33 个偏移量的数据未复制，向从服务器发送 <code>PSYNC</code> 指令，并报告当前偏移量时 10000，最终主从服务器就会同步中间这 33 个偏移量的数据。</p><h3 id="基于-Docker-搭建一个主从架构"><a href="#基于-Docker-搭建一个主从架构" class="headerlink" title="基于 Docker 搭建一个主从架构"></a>基于 Docker 搭建一个主从架构</h3><h4 id="主服务器配置"><a href="#主服务器配置" class="headerlink" title="主服务器配置"></a>主服务器配置</h4><p>主要修改以下几项配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requirepass &lt;password&gt; # 设置主服务器 redis 密码</span><br><span class="line"># bind 127.0.0.1 </span><br><span class="line">pretected-mode no</span><br></pre></td></tr></table></figure><h4 id="从服务器配置"><a href="#从服务器配置" class="headerlink" title="从服务器配置"></a>从服务器配置</h4><p>从服务器修改配置项如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requirepass &lt;password&gt; # 从服务器 redis 密码</span><br><span class="line">slaveof &lt;master_ip&gt; &lt;master_port&gt;</span><br><span class="line">masterauth &lt;master_password&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Executor框架</title>
      <link href="posts/5decb74418e5.html"/>
      <url>posts/5decb74418e5.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/images/202111061348509.png'/><span id="more"></span><p>虽然 Java 提供了手动创建线程的操作方式，但是实际生产环境中，肯定不会允许无限创建线程，因为服务器会炸，所以 JDK 提供了 Exexutor 框架用来管理线程。</p><p>Executor 是一个接口，也是整个框架最核心的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &#123;<span class="doctag">@code</span> Executor&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个 Executor 框架的主要成员和相应的功能如下：</p><ul><li><p><code>ThreadPoolExecutor</code></p><p>ThreadPoolExecutor 的核心参数如下：</p><ul><li><p><code>corePoolSize</code></p><p>核心线程数。</p></li><li><p>maximumPoolSize</p><p>最大线程数</p></li><li><p><code>keepAliveTime</code></p><p>线程空闲时间</p></li><li><p><code>unit</code></p><p>线程空闲时间单位</p></li><li><p><code>workQueue</code></p><p>任务队列，是一个阻塞队列。</p></li><li><p><code>threadFactory</code></p><p>线程工厂。</p></li></ul><p>通常通过 Executors 工厂类创建，Executors 能创建三种 ThreadPoolExecutor：</p><ul><li><p><code>SingleThreadExecutor</code></p><p>只有一个工作线程，所以初始化 ThreadPoolExecutor 时传入的核心线程数和最大线程数都是 1。适用于需要异步但是也需要按照某种顺序执行的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>FixedThreadPool</code></p><p>固定线程数的线程池。核心线程数和最大线程数一样。适用于需要进行资源管理的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>CachedThreadPool</code></p><p>核心线程数为 0，但是最大线程数位 <code>Integer.MAX_VALUE</code> 基本相当于不限制，线程空闲存活时间位为 1 分钟，因为线程可以无限创建，所以更适合做一些能快速完成的任务，不然就会出现一台服务器上创建成千上万个线程的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>ScheduledThreadPoolExecutor</code></p><p>和 ThreadPoolExecutor 一样，通常也是通过 Executors 创建。创建的 ScheduledThreadPoolExecutor 其实最后也是基于 ThreadPoolExecutor 实现的，不同点在于前面讲到的三种普通的 ThreadPoolExecutor 传入的任务队列是基于链表实现的<code>LinkedBlockingQueue</code>， 因为 <code>ScheduledThreadPoolExecutor</code> 一般都是用来做定时任务或者延迟任务，所以传入的是<code>DelayWorkQueue</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executors 可以创建两种 <code>ScheduledThreadPoolExecutor</code>:</p><ul><li><p><code>ScheduledThreadPoolExecutor</code></p><p><code>ScheduledThreadPoolExecutor</code>是<code>ThreadPoolExecutor</code>的子类，适用于有多个定时任务的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>SingleThreadScheduledExecutor</code></p><p>适用于需要单个线程执行后台任务且有顺序要求的场景。</p></li></ul></li><li><p><code>Future</code>接口</p><p>当一个任务需要返回值时，通过 <code>submit</code> 方法将任务（<code>Runnable</code>或<code>Callable</code>接口的实现）提交到 <code>ThreadPoolExecutor</code>或 <code>ScheduledThreadPoolExecutor</code> ，会返回一个 Future 接口的实现类，一般是 <code>FutureTask</code>。</p></li><li><p><code>Runnable</code> 和 <code>Callable</code></p><p>这两个接口的实现都可以当作任务提交到 ThreadPoolExecutor 执行，区别在于 <code>Runnable</code> 没有返回值，<code>Callable</code> 有返回值，<code>Executors</code>提供了一个将 <code>Runnable</code>接口封装成 <code>Callable</code> 接口的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">callable</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 submit 的任务是 Runnable 接口时，会调用上面的方法进行转换。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重入锁和读写锁</title>
      <link href="posts/0f6e2ae61275.html"/>
      <url>posts/0f6e2ae61275.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/images/202111061346558.png'/><span id="more"></span><h1 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h1><p>在前面的文章中已经实现过一个简单的独占式获取同步状态的锁 <code>Mutext</code> ，当有一个线程持有该锁之后，不管是谁再获取锁都会失败，包括占有锁的线程，我们认为 <code>Mutex</code> 这种锁是不支持重入的锁，而支持一个线程多次获取锁，我们把这种锁叫做重入锁，JDK 提供了一个支持重入的锁 <code>ReentrantLock</code>。</p><p><code>ReentrantLock</code> 内部实现了两个队列同步器，一个是公平的，一个是非公平的，这里的公平、非公平是什么意思呢？</p><p><strong>公平锁。</strong>在之前讲到队列同步器原理的时候，我们直到队列同步器内部维护了一个同步队列，每个同步节点释放锁之后，会唤醒后继节点的线程获取同步状态，而每个节点本身也一直在检查本身的前驱节点是否是头节点，整个队列保持先入先出（FIFO）的原则，等待越久的线程总是优先获取到同步状态，这样的锁，是公平的。</p><p><strong>非公平锁。</strong>上面讲过了公平锁，保持 FIFO 的原则，那么非公平所肯定就不会再遵循这个原则。非公平锁更倾向于将获取同步状态的权利交给目前占有锁的线程。举个例子，现在有 A、B 两个线程，一个非公平锁 lock，A 首先获取到了 lock，紧接着 B 尝试获取 lock，因为 A 占有锁，B 进入同步队列自旋，然后 A 线程再次获取 lock，虽然 A 线程依然还没有释放锁，但是当前持有锁的线程就是 A，而 lock 是一个非公平锁，所以 A 线程第二次获取锁成功。</p><p>个人认为，在极端点的情况下，那怕是重入锁，如果是公平锁，也有可能最终结果看起来跟非重入锁一样，因为会发现，多个线程竞争锁的时候，很可能上一秒 A 线程持有锁，下一秒 B 线程持有锁，再下一秒又是 A 线程持有锁，一直都没有某个线程重入过，此时也发现了另外一个问题，那就是公平锁会比非公平锁更频繁的切换线程上下文，这是有资源消耗的，所以可以认为，非公平锁的性能是比公平锁要高的。</p><p>讲了这么多，来看看 <code>ReentrantLock</code> 的实现方式。</p><p>首先 <code>ReentrantLock</code> 是否公平，是通过构造函数传参决定。无参构造默认初始化的是非公平的队列同步器，也就是默认初始化成非公平锁，如果要使用公平锁，就需要调用<code>ReentrantLock(boolean fair)</code>有参构造，参数<code>fair</code>决定锁是否公平。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看 <code>ReentrantLock</code> 如何支持线程重入，以公平锁为例看看。在前面讲解队列同步器时就知道 <code>AbstractQueueSynchronizer</code> 需要实现类实现 <code>tryAcquire(int arg)</code> 用来获取同步状态，所以直接看公平的队列同步器的 <code>tryAcquire(int arg)</code>就可以理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁的实现比较简单。首先判断当前同步状态是否为 0，如果是 0，当前线程尝试获取同步状态，如果不为 0，说明有线程已经获取到了同步状态，那就判断当前占有同步状态的是否为当前要获取同步状态的线程，如果是，那就设置新的同步状态，一般都是同步状态 +1，而最终释放同步状态时，只有同步状态置为 0 之后才认为真的释放了。</p><p>现在再看看非公平锁的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说过，非公平锁不再遵循 FIFO 的原则，更倾向于让当前线程获取到同步状态，所以当当前同步状态为 0 时，也不判断前驱节点是否为头节点，直接就调用 <code>compareAndSetState</code> 方法尝试设置状态，设置成功了就占有了同步状态。</p><p>如果当前同步状态不为 0，就和公平锁一样了。</p><p>总结一下，公平锁和非公平锁，在实现上主要的区别是，当同步状态为 0 时，公平锁要求前驱节点必须是头节点才能尝试获取同步状态，而非公平锁则没有限制，直接尝试获取同步状态。</p><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p>刚好今天有用到这个锁的场景，之前写过一个系统，启动后会将某些数据缓存到内存中，定时刷新，有请求来的时候会读取这个缓存，但是缓存加载需要时间，应用启动后，有请求进来，但是缓存还没加载完成，导致请求的返回结果时空的。此时就可以使用一个读写锁（虽然在这个场景下可能并不是最优解），当缓存加载或者刷新的时候，获取写锁，缓存加载或刷新完成后，释放写锁，当有请求进来查询缓存时，获取读锁，查询完后，释放读锁，如果获取读锁的时候，写锁已经被获取且未释放，获取读锁的线程就阻塞，直到写锁释放，如果获取读锁的时候，有其他线程已经获取读锁，就算读锁未释放，依然可以获取读锁成功，但是如果此时有哦请求进来获取到了读锁，碰巧又到了刷新缓存的时间，那么刷新缓存的线程获取写锁时就会阻塞，等待读锁释放。</p><p>前面自定义实现的 <code>Mutex</code> 和 JDK 提供的 <code>ReentrantLock</code> 同时都只允许一个线程获取到锁，这样的锁，叫做排他锁，但是通过上面的描述，读写锁明显不是排他锁，对于读锁，它在一定情况下允许其他线程也同时获取到读锁，但是对于写锁，则不允许其他线程同时获取到写锁。</p><p>读写锁的机制，一定要保证的原则是，写操作的线程更改的东西一定要对所有读线程可见，所以当一个线程获取了写锁之后，不释放写锁，继续获取读锁，此时时允许，然后再释放写锁，此时写锁降级成了读锁，写锁从获取到释放的整个过程对所有获取读锁的线程都是可见的。但是如果一个线程先获取读锁，不释放，反而进一步获取写锁，这是不被允许的，因为如果获取成功，会导致获取写锁的线程对资源的更改对于其他获取到读锁的线程并不可见。</p><p>所以，读写锁只有写锁降级成读锁，而没有读锁升级成写锁。</p><p>从上面的描述可以知道，读写锁似乎维护了两把锁，但内部有只有一个同步状态，要如何使用一个 int 类型的值同时维护两种同步状态呢？</p><p>以 JDK 提供的读写锁 <code>ReentrantReadWriteLock</code> 为例，一个 int 类型的数据，4 个字节，32 位，读写锁将这 32 位高 16 为用来保存读锁的同步状态，低 16 位用来保存写锁的同步状态。</p><p>假设当前读写锁的同步状态为 S，如果获取一次写锁之后的同步状态为 S + 1，获取一次读锁之后的同步状态为 S + (1 &lt;&lt; 16)，同样，如果在同步状态为 S 时释放一次写锁之后的状态为 S - 1，释放一次读锁之后的状态为 S - (1 &gt;&gt;&gt; 16)。</p><p>所以，当同步状态不为 0，但是同步状态 S &amp; 0x0000FFFF &gt; 0时，说明读锁已经被获取。</p><p>接下来看看<code>ReentrantReadWriteLock</code>如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(<span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">       sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">       readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line">       writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>和 <code>ReentrantLock</code> 类似，读写锁也提供了公平锁和非公平锁两种同步器。</p><p>然后先看看读锁获取锁的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReadLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 当前是否写锁已经被获取</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            getExclusiveOwnerThread() != current)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">        <span class="keyword">if</span> (r == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">                <span class="comment">// 设置当前线程 ThreadLocal 中的读锁占用次数</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exclusiveCount()</code>返回的时写锁状态，如果不为 0，说明写锁已经被获取，如果写锁被获取，判断获取读锁的线程是否是占有写锁的线程，如果不是，获取锁失败。</p><p>然后将当前状态右移 16 位，得到读锁状态，如果读锁等于 (1 &lt;&lt; 16) - 1，说明读锁获取次数已达上限，抛异常。</p><p>然后尝试设置同步状态为原状态值加上 1 &lt;&lt; 16，因为这里只有读锁的高 16 位加 1。</p><p>如果当前是读锁第一次被获取，设置当前线程为第一个获取读锁的线程<code>firstReader</code>，第一个获取读锁线程的锁持有次数<code>firstReaderHoldCount</code>为 1，如果当前读锁已经被持有，但是当前线程持有锁的第一个线程是同一线程，则 <code>firstReaderHoldCount</code> 自增 1。如果不是，则设置当前线程的 ThreadLocal 中的读锁占用次数。</p><p>上面是读锁获取同步状态，接下来看看写锁获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetState(c, c + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写锁同步状态的获取，和一般的排他锁类似，只不过因为高 16 位被占用，所以，写锁最多只能被占用的次数只用 (1 &lt;&lt; 16) - 1 次，并且当读锁被占用时，不能获取写锁同步状态。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁和队列同步器</title>
      <link href="posts/65b6ec5c6209.html"/>
      <url>posts/65b6ec5c6209.html</url>
      
        <content type="html"><![CDATA[<img src='https://image.hanelalo.cn/images/202111061342377.png'/><span id="more"></span><h1 id="锁和队列同步器"><a href="#锁和队列同步器" class="headerlink" title="锁和队列同步器"></a>锁和队列同步器</h1><h2 id="锁（Lock）"><a href="#锁（Lock）" class="headerlink" title="锁（Lock）"></a>锁（Lock）</h2><p>在 JDK 1.5 之前，Java 一直是通过 synchronized 关键字实现锁，在 JDK 1.5 时，增加了 Lock 接口，提供了 synchronized 关键字所有的功能，不过需要显示调用获取锁和释放锁，虽然相对要麻烦一点点，但也是因为需要显示调用、显示释放，就保证了锁的灵活性，支持更多更复杂的场景。</p><p>Lock 所具有的 synchronized 关键字不具备的特点有：</p><ul><li>尝试非阻塞的获取锁。当前线程尝试获取锁，如果这一时刻没有其他线程获取到锁，那么成功获取并持有锁。</li><li>能被中断的获取锁。当获取到锁的线程被中断，会抛出异常并释放锁。</li><li>超时获取锁。在指定的时间内获取锁，如果截至时间过了依然无法获取锁，返回，获取锁失败。</li></ul><p>Lock 接口提供的方法主要有：</p><ul><li><p><code>lock()</code></p><p>阻塞式获取锁，获取到锁之后返回。</p></li><li><p><code>lockInterruptibly() throws InterruptedException</code></p><p>可中断的获取锁，和 <code>lock()</code> 的区别在于本方法响应中断，而 <code>lock()</code> 不响应中断。</p></li><li><p><code>tryLock()</code></p><p>非阻塞的尝试获取锁，立刻返回。</p></li><li><p><code>tryLock(long time, TimeUnit unit) throws InterruptedException</code></p><p>超时获取锁，会在一下三种情况下返回：</p><ul><li>当在超时时间内获取到锁。</li><li>超时时间内被中断。</li><li>超时时间已到，但是未获取到锁。</li></ul></li><li><p><code>unlock()</code></p><p>释放锁。</p></li><li><p><code>newCondition()</code></p><p>获取等待通知组件，只有当前线程获取到了锁之后才能调用该组件的 <code>wait()</code> 方法，调用后线程会释放锁。</p></li></ul><h2 id="队列同步器（AbstractQueueSynhronizer）"><a href="#队列同步器（AbstractQueueSynhronizer）" class="headerlink" title="队列同步器（AbstractQueueSynhronizer）"></a>队列同步器（AbstractQueueSynhronizer）</h2><p>队列同步器使用一个 int 类型的成员变量 <code>state</code> 表示同步状态，内部维护一个 FIFO 的队列完成获取锁的线程的排队工作。</p><p>队列同步器对外提供了三个方法来获取和修改同步状态：</p><ul><li><p><code>getState()</code> </p><p>获取当前同步状态</p></li><li><p><code>setState()</code> </p><p>设置当前同步状态</p></li><li><p><code>compareAndSetState(int expect, int update)</code> </p><p>使用 CAS 设置当前状态，保证状态设置的原子性</p></li></ul><p>从队列同步器的名字就能看出它是一个抽象类，一般都是把它的实现类定义在并发组件内部。它提供了如下可重写的方法。</p><ul><li><p><code>tryAcquire(int arg)</code> </p><p>独占式获取同步状态。实现该方法需要查询当前同步状态，判断是否符合预期，然后再设置同步状态。</p></li><li><p><code>tryRelease(int arg)</code> </p><p>独占式释放同步状态。等待获取同步状态的线程酱油机会获取到同步状态。</p></li><li><p><code>tryAcquireShared(int arg)</code> </p><p>共享式获取同步状态。返回值大于 0 表示获取成功，否则获取失败。</p></li><li><p><code>tryReleaseShared(int arg)</code> </p><p>共享式释放同步状态。</p></li><li><p><code>isHeldExclusively()</code> </p><p>当前同步状态是否被某线程独占式的占用，一般用于判断占用的是否是当前线程。</p></li></ul><p>队列同步器提供的模板方法：</p><ul><li><p><code>acquire(int arg)</code></p><p>独占式获取同步状态，如果获取成功则返回，否则进入同步队列等待，该方法会调用重写的 <code>tryAcquire</code> 方法。</p></li><li><p><code>acquireInterruptibly(int arg)</code></p><p>和<code>acquire()</code> 方法一样，不过本方法响应中断。</p></li><li><p><code>tryAcquireNanos(int arg, long nanos)</code></p><p>在<code>acquireInterruptibly(int arg)</code> 基础上增加超时机制，如果超时限制内获取到同步状态就返回 true，否则返回 false。</p></li><li><p><code>acquireShared(int arg)</code></p><p>共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，和独占式获取的区别在于，每次可以有多个线程获取到同步状态。</p></li><li><p><code>acquireSharedInterruptibly(int arg)</code></p><p>在<code>acquire</code> 的基础上增加响应中断的机制。</p></li><li><p><code>tryAcquireSharedNanos(int arg, long nanos)</code></p><p>在 <code>acquireSharedInterruptibly</code> 基础上增加超时机制。</p></li><li><p><code>release(int arg)</code></p><p>独占式释放同步状态，释放后将会唤醒同步队列中第一个节点包含的线程。</p></li><li><p><code>releaseShared(int arg)</code></p><p>共享式释放同步状态。</p></li><li><p><code>getQueueThread()</code></p><p>获取等待同步队列上的线程集合。</p></li></ul><h2 id="实现一个简单的锁"><a href="#实现一个简单的锁" class="headerlink" title="实现一个简单的锁"></a>实现一个简单的锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mutex</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">      setState(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toMillis(time));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来写个测试看看。</p><p>测试启动两个线程，一个线程先启动并获取锁，然后休眠 5 秒，第二个线程循环调用 <code>tryLock()</code> 尝试获取锁，如果获取失败，就打印一条日志并休眠 1 秒，然后再次尝试获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutexTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shouldAcquireFailedWhenOtherThreadAcquired</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mutex</span>();</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">acquiredThread</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;Acquired_Thread started...&quot;</span>);</span><br><span class="line">              lock.lock();</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">              lock.unlock();</span><br><span class="line">              System.out.println(<span class="string">&quot;Acquired_Thread unlock...&quot;</span>);</span><br><span class="line">              countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">    acquiredThread.start();</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">shouldAcquireThread</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;Should_Acquire_Thread started...&quot;</span>);</span><br><span class="line">              <span class="keyword">while</span> (!lock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  System.out.println(</span><br><span class="line">                      <span class="string">&quot;Should_Acquire_Thread tryLock() return false, thread sleep 1000ms ...&quot;</span>);</span><br><span class="line">                  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              System.out.println(<span class="string">&quot;Should_Acquire_Thread acquired&quot;</span>);</span><br><span class="line">              lock.unlock();</span><br><span class="line">              System.out.println(<span class="string">&quot;Should_Acquire_Thread unlock...&quot;</span>);</span><br><span class="line">              countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">    shouldAcquireThread.start();</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;shutdown...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Acquired_Thread started...</span><br><span class="line">Should_Acquire_Thread started...</span><br><span class="line">Should_Acquire_Thread tryLock() return false, thread sleep 1000ms ...</span><br><span class="line">Should_Acquire_Thread tryLock() return false, thread sleep 1000ms ...</span><br><span class="line">Should_Acquire_Thread tryLock() return false, thread sleep 1000ms ...</span><br><span class="line">Should_Acquire_Thread tryLock() return false, thread sleep 1000ms ...</span><br><span class="line">Should_Acquire_Thread tryLock() return false, thread sleep 1000ms ...</span><br><span class="line">Acquired_Thread unlock...</span><br><span class="line">Should_Acquire_Thread acquired</span><br><span class="line">Should_Acquire_Thread unlock...</span><br><span class="line">shutdown...</span><br></pre></td></tr></table></figure><p>可以看见，第二个线程尝试了 5 次之后才成功获取到锁，获取到锁的日志在线程一释放锁之后，和预期一致。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
